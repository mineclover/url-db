package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	// Core imports
	"url-db/internal/config"
	"url-db/internal/constants"
	"url-db/internal/database"
	"url-db/internal/interfaces/mcp"
	"url-db/internal/interface/setup"

	"github.com/gin-gonic/gin"
	"github.com/jmoiron/sqlx"

	_ "url-db/docs" // docs is generated by Swag CLI, you have to import it.
)

// @title           URL Database API
// @version         1.0
// @description     A URL management system with attribute support and MCP integration.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api

// @securityDefinitions.basic  BasicAuth

func main() {
	// Parse command line flags
	var (
		mcpMode  = flag.String("mcp-mode", "sse", "MCP server mode: 'stdio' for stdin/stdout, 'sse' for HTTP server")
		dbPath   = flag.String("db-path", "", "Path to the database file (overrides DATABASE_URL)")
		toolName = flag.String("tool-name", "", "Tool name for composite keys (default: "+constants.DefaultServerName+")")
		port     = flag.String("port", "", "Port for HTTP server (default: "+strconv.Itoa(constants.DefaultPort)+")")
		showHelp = flag.Bool("help", false, "Show help message")
		version  = flag.Bool("version", false, "Show version information")
	)
	flag.Parse()

	if *showHelp {
		fmt.Println("URL Database Server")
		fmt.Println("Usage:")
		fmt.Println("  url-db [options]")
		fmt.Println()
		fmt.Println("Options:")
		fmt.Println("  -mcp-mode string")
		fmt.Println("        MCP server mode: 'stdio' for stdin/stdout, 'sse' for HTTP server (default \"sse\")")
		fmt.Println("  -db-path string")
		fmt.Println("        Path to the database file (e.g., ~/url-db.db)")
		fmt.Println("  -tool-name string")
		fmt.Println("        Tool name for composite keys (default: url-db)")
		fmt.Println("  -port string")
		fmt.Println("        Port for HTTP server (default: 8080)")
		fmt.Println("  -help")
		fmt.Println("        Show help message")
		fmt.Println("  -version")
		fmt.Println("        Show version information")
		fmt.Println()
		fmt.Println("Examples:")
		fmt.Println("  url-db                                          # Start HTTP server")
		fmt.Println("  url-db -mcp-mode=stdio -db-path=~/url-db.db    # MCP stdio mode")
		fmt.Println("  url-db -mcp-mode=stdio -db-path=~/work.db -tool-name=work")
		fmt.Println("  url-db -help                                    # Show this help")
		os.Exit(0)
	}

	if *version {
		fmt.Println("URL Database Server v" + constants.DefaultServerVersion)
		fmt.Println("Built with Go", "runtime.Version()")
		os.Exit(0)
	}

	// Set gin mode early if in stdio mode to prevent debug output
	if *mcpMode == "stdio" {
		gin.SetMode(gin.ReleaseMode)
		log.SetOutput(io.Discard)
	}

	cfg := config.Load()

	// Override configuration with command-line flags
	if *dbPath != "" {
		// If tool name is not specified, extract from db filename
		if *toolName == "" {
			// Extract base name from path (e.g., "work.db" -> "work")
			baseName := filepath.Base(*dbPath)
			if ext := filepath.Ext(baseName); ext != "" {
				baseName = strings.TrimSuffix(baseName, ext)
			}
			// Use the base name as tool name if valid
			if baseName != "" && baseName != "." {
				*toolName = baseName
			}
		}
		cfg.DatabaseURL = "file:" + *dbPath
	}
	if *toolName != "" {
		cfg.ToolName = *toolName
	}
	if *port != "" {
		cfg.Port = *port
	}

	db, err := database.InitDB(cfg.DatabaseURL)
	if err != nil {
		log.Fatal("Failed to initialize database:", err)
	}
	defer db.Close()

	// Get the underlying *sql.DB for standard repos
	sqlDB := db.DB()

	// Create sqlx.DB for nodeattributes repo
	sqlxDB := sqlx.NewDb(sqlDB, "sqlite3")

	// Initialize all dependencies
	deps := setup.InitializeDependencies(sqlDB, sqlxDB, cfg.ToolName)

	// Setup router with all routes
	r := setup.SetupRouter(deps)

	// Handle different MCP modes
	switch *mcpMode {
	case "stdio":
		// stdio mode: MCP communication via stdin/stdout, then exit
		stdioServer := mcp.NewStdioServer(deps.Legacy.MCPService, cfg)
		if err := stdioServer.Start(); err != nil {
			os.Exit(1)
		}
		return

	case "sse":
		// SSE mode: HTTP server with MCP endpoints (default)
		log.Println("Starting MCP SSE mode (HTTP server)...")

		log.Printf("Server starting on port %s", cfg.Port)
		if err := r.Run(":" + cfg.Port); err != nil {
			log.Fatal("Failed to start server:", err)
		}
	}
}
