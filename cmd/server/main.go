package main

import (
	"context"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"url-db/internal/attributes"
	"url-db/internal/compositekey"
	"url-db/internal/config"
	"url-db/internal/database"
	"url-db/internal/domains"
	"url-db/internal/handlers"
	"url-db/internal/mcp"
	"url-db/internal/models"
	"url-db/internal/nodeattributes"
	"url-db/internal/nodes"
	"url-db/internal/repositories"
	"url-db/internal/services"

	"github.com/gin-gonic/gin"
	"github.com/jmoiron/sqlx"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	_ "url-db/docs" // docs is generated by Swag CLI, you have to import it.
)

// @title           URL Database API
// @version         1.0
// @description     A URL management system with attribute support and MCP integration.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api

// @securityDefinitions.basic  BasicAuth

func main() {
	// Parse command line flags
	var (
		mcpMode = flag.String("mcp-mode", "sse", "MCP server mode: 'stdio' for stdin/stdout, 'sse' for HTTP server")
		dbPath = flag.String("db-path", "", "Path to the database file (overrides DATABASE_URL)")
		toolName = flag.String("tool-name", "", "Tool name for composite keys (default: url-db)")
		port = flag.String("port", "", "Port for HTTP server (default: 8080)")
		showHelp = flag.Bool("help", false, "Show help message")
		version = flag.Bool("version", false, "Show version information")
	)
	flag.Parse()

	if *showHelp {
		fmt.Println("URL Database Server")
		fmt.Println("Usage:")
		fmt.Println("  url-db [options]")
		fmt.Println()
		fmt.Println("Options:")
		fmt.Println("  -mcp-mode string")
		fmt.Println("        MCP server mode: 'stdio' for stdin/stdout, 'sse' for HTTP server (default \"sse\")")
		fmt.Println("  -db-path string")
		fmt.Println("        Path to the database file (e.g., ~/url-db.db)")
		fmt.Println("  -tool-name string")
		fmt.Println("        Tool name for composite keys (default: url-db)")
		fmt.Println("  -port string")
		fmt.Println("        Port for HTTP server (default: 8080)")
		fmt.Println("  -help")
		fmt.Println("        Show help message")
		fmt.Println("  -version")
		fmt.Println("        Show version information")
		fmt.Println()
		fmt.Println("Examples:")
		fmt.Println("  url-db                                          # Start HTTP server")
		fmt.Println("  url-db -mcp-mode=stdio -db-path=~/url-db.db    # MCP stdio mode")
		fmt.Println("  url-db -mcp-mode=stdio -db-path=~/work.db -tool-name=work")
		fmt.Println("  url-db -help                                    # Show this help")
		os.Exit(0)
	}

	if *version {
		fmt.Println("URL Database Server v1.0")
		fmt.Println("Built with Go", "runtime.Version()")
		os.Exit(0)
	}

	// Set gin mode early if in stdio mode to prevent debug output
	if *mcpMode == "stdio" {
		gin.SetMode(gin.ReleaseMode)
		log.SetOutput(io.Discard)
	}

	cfg := config.Load()

	// Override configuration with command-line flags
	if *dbPath != "" {
		// If tool name is not specified, extract from db filename
		if *toolName == "" {
			// Extract base name from path (e.g., "work.db" -> "work")
			baseName := filepath.Base(*dbPath)
			if ext := filepath.Ext(baseName); ext != "" {
				baseName = strings.TrimSuffix(baseName, ext)
			}
			// Use the base name as tool name if valid
			if baseName != "" && baseName != "." {
				*toolName = baseName
			}
		}
		cfg.DatabaseURL = "file:" + *dbPath
	}
	if *toolName != "" {
		cfg.ToolName = *toolName
	}
	if *port != "" {
		cfg.Port = *port
	}

	db, err := database.InitDB(cfg.DatabaseURL)
	if err != nil {
		log.Fatal("Failed to initialize database:", err)
	}
	defer db.Close()

	// Get the underlying *sql.DB for standard repos
	sqlDB := db.DB()

	// Create sqlx.DB for nodeattributes repo
	sqlxDB := sqlx.NewDb(sqlDB, "sqlite3")

	// Initialize repositories
	domainRepo := domains.NewDomainRepository(sqlDB)
	nodeRepo := nodes.NewSQLiteNodeRepository(sqlDB)
	attributeRepo := attributes.NewSQLiteAttributeRepository(sqlDB)
	nodeAttributeRepo := nodeattributes.NewRepository(sqlxDB)

	// Use the repositories package for MCP service dependencies
	repos := repositories.NewRepositories(sqlDB)
	
	// Initialize external dependency repositories
	subscriptionRepo := repositories.NewSubscriptionRepository(sqlxDB)
	dependencyRepo := repositories.NewDependencyRepository(sqlxDB)
	eventRepo := repositories.NewEventRepository(sqlxDB)

	// Initialize services
	domainService := domains.NewDomainService(domainRepo)
	nodeService := nodes.NewNodeService(nodeRepo)
	attributeService := attributes.NewAttributeService(attributeRepo, domainService)

	// Initialize validators and managers for node attributes
	nodeAttributeValidator := nodeattributes.NewValidator()
	nodeAttributeOrderManager := nodeattributes.NewOrderManager(nodeAttributeRepo)
	nodeAttributeService := nodeattributes.NewService(nodeAttributeRepo, nodeAttributeValidator, nodeAttributeOrderManager)
	
	// Initialize external dependency services
	subscriptionService := services.NewSubscriptionService(subscriptionRepo, repos.Node, eventRepo)
	dependencyService := services.NewDependencyService(dependencyRepo, repos.Node, eventRepo)
	eventService := services.NewEventService(eventRepo, repos.Node)

	// Create adapter services for MCP
	mcpDomainService := &mcpDomainServiceAdapter{domainService: domainService, domainRepo: domainRepo}
	mcpNodeService := &mcpNodeServiceAdapter{nodeService: nodeService}
	mcpAttributeService := &mcpAttributeServiceAdapter{nodeAttributeService: nodeAttributeService, attributeService: attributeService}

	// Initialize additional services
	nodeCountService := &nodeCountServiceAdapter{nodeRepo: repos.Node}

	// Initialize composite key service
	compositeKeyService := compositekey.NewService(cfg.ToolName)
	compositeKeyAdapter := mcp.NewCompositeKeyAdapter(compositeKeyService)

	// Initialize MCP converter and service
	mcpConverter := mcp.NewConverter(compositeKeyAdapter)
	mcpService := mcp.NewMCPService(mcpNodeService, mcpDomainService, mcpAttributeService, nodeCountService, mcpConverter)

	// Initialize handlers
	domainHandler := domains.NewDomainHandler(domainService)
	nodeHandler := nodes.NewNodeHandler(nodeService)
	attributeHandler := attributes.NewAttributeHandler(attributeService)
	nodeAttributeHandler := nodeattributes.NewHandler(nodeAttributeService)
	
	// Initialize external dependency handlers
	subscriptionHandler := handlers.NewSubscriptionHandler(subscriptionService)
	dependencyHandler := handlers.NewDependencyHandler(dependencyService)
	eventHandler := handlers.NewEventHandler(eventService)

	// Create MCP handler with service adapter
	mcpHandlerService := &mcpHandlerServiceAdapter{mcpService: mcpService}
	mcpHandler := handlers.NewMCPHandler(mcpHandlerService)

	// Setup routes
	r := gin.Default()

	// Setup CORS middleware
	r.Use(func(c *gin.Context) {
		c.Header("Access-Control-Allow-Origin", "*")
		c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	})

	// Health check endpoint
	r.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"status":  "healthy",
			"service": "url-db",
		})
	})

	// Swagger documentation
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Register all routes manually to avoid conflicts
	api := r.Group("/api")

	// Domain routes
	api.POST("/domains", domainHandler.CreateDomain)
	api.GET("/domains", domainHandler.ListDomains)
	api.GET("/domains/:domain_id", func(c *gin.Context) {
		// Convert :domain_id to :id for the domain handler
		domainID := c.Param("domain_id")
		c.Params = []gin.Param{{Key: "id", Value: domainID}}
		domainHandler.GetDomain(c)
	})
	api.PUT("/domains/:domain_id", func(c *gin.Context) {
		// Convert :domain_id to :id for the domain handler
		domainID := c.Param("domain_id")
		c.Params = []gin.Param{{Key: "id", Value: domainID}}
		domainHandler.UpdateDomain(c)
	})
	api.DELETE("/domains/:domain_id", func(c *gin.Context) {
		// Convert :domain_id to :id for the domain handler
		domainID := c.Param("domain_id")
		c.Params = []gin.Param{{Key: "id", Value: domainID}}
		domainHandler.DeleteDomain(c)
	})

	// Domain attribute routes
	api.POST("/domains/:domain_id/attributes", attributeHandler.CreateAttribute)
	api.GET("/domains/:domain_id/attributes", attributeHandler.ListAttributes)

	// Attribute detail routes
	api.GET("/attributes/:id", attributeHandler.GetAttribute)
	api.PUT("/attributes/:id", attributeHandler.UpdateAttribute)
	api.DELETE("/attributes/:id", attributeHandler.DeleteAttribute)

	// Node routes
	api.POST("/domains/:domain_id/urls", nodeHandler.CreateNode)
	api.GET("/domains/:domain_id/urls", nodeHandler.GetNodesByDomain)
	api.POST("/domains/:domain_id/urls/find", nodeHandler.FindNodeByURL)
	api.GET("/urls/:id", nodeHandler.GetNode)
	api.PUT("/urls/:id", nodeHandler.UpdateNode)
	api.DELETE("/urls/:id", nodeHandler.DeleteNode)

	// Node attribute routes
	api.POST("/urls/:id/attributes", func(c *gin.Context) {
		// Convert :id to :url_id for the node attribute handler
		urlID := c.Param("id")
		c.Params = []gin.Param{{Key: "url_id", Value: urlID}}
		nodeAttributeHandler.CreateNodeAttribute(c)
	})
	api.GET("/urls/:id/attributes", func(c *gin.Context) {
		// Convert :id to :url_id for the node attribute handler
		urlID := c.Param("id")
		c.Params = []gin.Param{{Key: "url_id", Value: urlID}}
		nodeAttributeHandler.GetNodeAttributesByNodeID(c)
	})
	api.GET("/url-attributes/:id", nodeAttributeHandler.GetNodeAttributeByID)
	api.PUT("/url-attributes/:id", nodeAttributeHandler.UpdateNodeAttribute)
	api.DELETE("/url-attributes/:id", nodeAttributeHandler.DeleteNodeAttribute)
	api.DELETE("/urls/:id/attributes/:attribute_id", func(c *gin.Context) {
		// Convert :id to :url_id for the node attribute handler
		urlID := c.Param("id")
		attributeID := c.Param("attribute_id")
		c.Params = []gin.Param{
			{Key: "url_id", Value: urlID},
			{Key: "attribute_id", Value: attributeID},
		}
		nodeAttributeHandler.DeleteNodeAttributeByNodeIDAndAttributeID(c)
	})

	// External dependency routes
	// Subscription routes
	api.POST("/nodes/:nodeId/subscriptions", subscriptionHandler.CreateSubscription)
	api.GET("/nodes/:nodeId/subscriptions", subscriptionHandler.GetNodeSubscriptions)
	api.GET("/subscriptions", subscriptionHandler.GetServiceSubscriptions)
	api.GET("/subscriptions/:id", subscriptionHandler.GetSubscription)
	api.PUT("/subscriptions/:id", subscriptionHandler.UpdateSubscription)
	api.DELETE("/subscriptions/:id", subscriptionHandler.DeleteSubscription)

	// Dependency routes
	api.POST("/nodes/:nodeId/dependencies", dependencyHandler.CreateDependency)
	api.GET("/nodes/:nodeId/dependencies", dependencyHandler.GetNodeDependencies)
	api.GET("/nodes/:nodeId/dependents", dependencyHandler.GetNodeDependents)
	api.GET("/dependencies/:id", dependencyHandler.GetDependency)
	api.DELETE("/dependencies/:id", dependencyHandler.DeleteDependency)

	// Event routes
	api.GET("/nodes/:nodeId/events", eventHandler.GetNodeEvents)
	api.GET("/events/pending", eventHandler.GetPendingEvents)
	api.GET("/events", eventHandler.GetEventsByType)
	api.GET("/events/stats", eventHandler.GetEventStats)
	api.POST("/events/:eventId/process", eventHandler.ProcessEvent)
	api.POST("/events/cleanup", eventHandler.CleanupEvents)

	// Handle different MCP modes
	switch *mcpMode {
	case "stdio":
		// stdio mode: MCP communication via stdin/stdout, then exit
		stdioServer := mcp.NewStdioServer(mcpService)
		if err := stdioServer.Start(); err != nil {
			os.Exit(1)
		}
		return

	case "sse":
		// SSE mode: HTTP server with MCP endpoints (default)
		log.Println("Starting MCP SSE mode (HTTP server)...")
		
		// Register MCP routes
		mcpHandler.RegisterRoutes(r)

		log.Printf("Server starting on port %s", cfg.Port)
		if err := r.Run(":" + cfg.Port); err != nil {
			log.Fatal("Failed to start server:", err)
		}
	}
}

// Adapter services to bridge interface differences

type mcpDomainServiceAdapter struct {
	domainService domains.DomainService
	domainRepo    domains.DomainRepository
}

func (a *mcpDomainServiceAdapter) CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*models.Domain, error) {
	return a.domainService.CreateDomain(ctx, req)
}

func (a *mcpDomainServiceAdapter) GetDomain(ctx context.Context, domainID int) (*models.Domain, error) {
	return a.domainService.GetDomain(ctx, domainID)
}

func (a *mcpDomainServiceAdapter) GetDomainByName(ctx context.Context, name string) (*models.Domain, error) {
	return a.domainRepo.GetByName(ctx, name)
}

func (a *mcpDomainServiceAdapter) ListDomains(ctx context.Context, page, size int) (*models.DomainListResponse, error) {
	return a.domainService.ListDomains(ctx, page, size)
}

func (a *mcpDomainServiceAdapter) UpdateDomain(ctx context.Context, domainID int, req *models.UpdateDomainRequest) (*models.Domain, error) {
	return a.domainService.UpdateDomain(ctx, domainID, req)
}

func (a *mcpDomainServiceAdapter) DeleteDomain(ctx context.Context, domainID int) error {
	return a.domainService.DeleteDomain(ctx, domainID)
}

type mcpNodeServiceAdapter struct {
	nodeService nodes.NodeService
}

func (a *mcpNodeServiceAdapter) CreateNode(ctx context.Context, domainID int, req *models.CreateNodeRequest) (*models.Node, error) {
	return a.nodeService.CreateNode(domainID, req)
}

func (a *mcpNodeServiceAdapter) GetNode(ctx context.Context, nodeID int) (*models.Node, error) {
	return a.nodeService.GetNodeByID(nodeID)
}

func (a *mcpNodeServiceAdapter) UpdateNode(ctx context.Context, nodeID int, req *models.UpdateNodeRequest) (*models.Node, error) {
	return a.nodeService.UpdateNode(nodeID, req)
}

func (a *mcpNodeServiceAdapter) DeleteNode(ctx context.Context, nodeID int) error {
	return a.nodeService.DeleteNode(nodeID)
}

func (a *mcpNodeServiceAdapter) ListNodes(ctx context.Context, domainID int, page, size int, search string) (*models.NodeListResponse, error) {
	if search != "" {
		return a.nodeService.SearchNodes(domainID, search, page, size)
	}
	return a.nodeService.GetNodesByDomainID(domainID, page, size)
}

func (a *mcpNodeServiceAdapter) FindNodeByURL(ctx context.Context, domainID int, req *models.FindNodeByURLRequest) (*models.Node, error) {
	return a.nodeService.FindNodeByURL(domainID, req)
}

type mcpAttributeServiceAdapter struct {
	nodeAttributeService nodeattributes.Service
	attributeService     attributes.AttributeService
}

func (a *mcpAttributeServiceAdapter) GetNodeAttributes(ctx context.Context, nodeID int) ([]models.NodeAttributeWithInfo, error) {
	response, err := a.nodeAttributeService.GetNodeAttributesByNodeID(nodeID)
	if err != nil {
		return nil, err
	}
	return response.Attributes, nil
}

func (a *mcpAttributeServiceAdapter) SetNodeAttribute(ctx context.Context, nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttributeWithInfo, error) {
	attr, err := a.nodeAttributeService.CreateNodeAttribute(nodeID, req)
	if err != nil {
		return nil, err
	}

	// Convert NodeAttribute to NodeAttributeWithInfo - we need to get additional info
	return &models.NodeAttributeWithInfo{
		ID:          attr.ID,
		NodeID:      attr.NodeID,
		AttributeID: attr.AttributeID,
		Value:       attr.Value,
		OrderIndex:  attr.OrderIndex,
		CreatedAt:   attr.CreatedAt,
	}, nil
}

func (a *mcpAttributeServiceAdapter) GetAttributeByName(ctx context.Context, domainID int, name string) (*models.Attribute, error) {
	// Get all attributes for the domain and find by name
	response, err := a.attributeService.ListAttributes(ctx, domainID)
	if err != nil {
		return nil, err
	}

	for _, attr := range response.Attributes {
		if attr.Name == name {
			return &attr, nil
		}
	}

	return nil, fmt.Errorf("attribute '%s' not found in domain %d", name, domainID)
}

func (a *mcpAttributeServiceAdapter) DeleteNodeAttribute(ctx context.Context, nodeID, attributeID int) error {
	return a.nodeAttributeService.DeleteNodeAttributeByNodeIDAndAttributeID(nodeID, attributeID)
}

// Domain attribute management methods
func (a *mcpAttributeServiceAdapter) ListAttributes(ctx context.Context, domainID int) (*models.AttributeListResponse, error) {
	return a.attributeService.ListAttributes(ctx, domainID)
}

func (a *mcpAttributeServiceAdapter) CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error) {
	return a.attributeService.CreateAttribute(ctx, domainID, req)
}

func (a *mcpAttributeServiceAdapter) GetAttribute(ctx context.Context, id int) (*models.Attribute, error) {
	return a.attributeService.GetAttribute(ctx, id)
}

func (a *mcpAttributeServiceAdapter) UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error) {
	return a.attributeService.UpdateAttribute(ctx, id, req)
}

func (a *mcpAttributeServiceAdapter) DeleteAttribute(ctx context.Context, id int) error {
	return a.attributeService.DeleteAttribute(ctx, id)
}

type nodeCountServiceAdapter struct {
	nodeRepo repositories.NodeRepository
}

func (a *nodeCountServiceAdapter) GetNodeCountByDomain(ctx context.Context, domainID int) (int, error) {
	return a.nodeRepo.CountNodesByDomain(ctx, domainID)
}

type mcpHandlerServiceAdapter struct {
	mcpService mcp.MCPService
}

func (a *mcpHandlerServiceAdapter) CreateMCPNode(req *models.CreateMCPNodeRequest) (*models.MCPNode, error) {
	return a.mcpService.CreateNode(context.Background(), req)
}

func (a *mcpHandlerServiceAdapter) GetMCPNodeByCompositeID(compositeID string) (*models.MCPNode, error) {
	return a.mcpService.GetNode(context.Background(), compositeID)
}

func (a *mcpHandlerServiceAdapter) GetMCPNodes(domainName string, page, size int, search string) (*models.MCPNodeListResponse, error) {
	return a.mcpService.ListNodes(context.Background(), domainName, page, size, search)
}

func (a *mcpHandlerServiceAdapter) UpdateMCPNode(compositeID string, req *models.UpdateMCPNodeRequest) (*models.MCPNode, error) {
	// Convert UpdateMCPNodeRequest to UpdateNodeRequest
	nodeReq := &models.UpdateNodeRequest{
		Title:       req.Title,
		Description: req.Description,
	}
	return a.mcpService.UpdateNode(context.Background(), compositeID, nodeReq)
}

func (a *mcpHandlerServiceAdapter) DeleteMCPNode(compositeID string) error {
	return a.mcpService.DeleteNode(context.Background(), compositeID)
}

func (a *mcpHandlerServiceAdapter) FindMCPNodeByURL(req *models.FindMCPNodeRequest) (*models.MCPNode, error) {
	return a.mcpService.FindNodeByURL(context.Background(), req)
}

func (a *mcpHandlerServiceAdapter) BatchGetMCPNodes(req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error) {
	return a.mcpService.BatchGetNodes(context.Background(), req)
}

func (a *mcpHandlerServiceAdapter) GetMCPDomains() ([]models.MCPDomain, error) {
	response, err := a.mcpService.ListDomains(context.Background())
	if err != nil {
		return nil, err
	}

	// Convert mcp.MCPDomain to models.MCPDomain
	result := make([]models.MCPDomain, len(response.Domains))
	for i, domain := range response.Domains {
		result[i] = models.MCPDomain{
			Name:        domain.Name,
			Description: domain.Description,
			NodeCount:   domain.NodeCount,
			CreatedAt:   domain.CreatedAt,
			UpdatedAt:   domain.UpdatedAt,
		}
	}
	return result, nil
}

func (a *mcpHandlerServiceAdapter) CreateMCPDomain(req *models.CreateMCPDomainRequest) (*models.MCPDomain, error) {
	// Convert CreateMCPDomainRequest to CreateDomainRequest
	domainReq := &models.CreateDomainRequest{
		Name:        req.Name,
		Description: req.Description,
	}

	mcpDomain, err := a.mcpService.CreateDomain(context.Background(), domainReq)
	if err != nil {
		return nil, err
	}

	// Convert mcp.MCPDomain to models.MCPDomain
	return &models.MCPDomain{
		Name:        mcpDomain.Name,
		Description: mcpDomain.Description,
		NodeCount:   mcpDomain.NodeCount,
		CreatedAt:   mcpDomain.CreatedAt,
		UpdatedAt:   mcpDomain.UpdatedAt,
	}, nil
}

func (a *mcpHandlerServiceAdapter) GetMCPNodeAttributes(compositeID string) (*models.MCPNodeAttributesResponse, error) {
	response, err := a.mcpService.GetNodeAttributes(context.Background(), compositeID)
	if err != nil {
		return nil, err
	}

	// Convert MCPNodeAttributeResponse to MCPNodeAttributesResponse
	return &models.MCPNodeAttributesResponse{
		CompositeID: response.CompositeID,
		Attributes:  response.Attributes,
	}, nil
}

func (a *mcpHandlerServiceAdapter) SetMCPNodeAttributes(compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributesResponse, error) {
	response, err := a.mcpService.SetNodeAttributes(context.Background(), compositeID, req)
	if err != nil {
		return nil, err
	}

	// Convert MCPNodeAttributeResponse to MCPNodeAttributesResponse
	return &models.MCPNodeAttributesResponse{
		CompositeID: response.CompositeID,
		Attributes:  response.Attributes,
	}, nil
}

func (a *mcpHandlerServiceAdapter) GetMCPServerInfo() (*models.MCPServerInfo, error) {
	serverInfo, err := a.mcpService.GetServerInfo(context.Background())
	if err != nil {
		return nil, err
	}

	// Convert mcp.MCPServerInfo to models.MCPServerInfo
	return &models.MCPServerInfo{
		Name:               serverInfo.Name,
		Version:            serverInfo.Version,
		Description:        serverInfo.Description,
		Capabilities:       serverInfo.Capabilities,
		CompositeKeyFormat: serverInfo.CompositeKeyFormat,
	}, nil
}

// Domain attribute management methods
func (a *mcpHandlerServiceAdapter) ListDomainAttributes(domainName string) (*models.MCPDomainAttributeListResponse, error) {
	return a.mcpService.ListDomainAttributes(context.Background(), domainName)
}

func (a *mcpHandlerServiceAdapter) CreateDomainAttribute(domainName string, req *models.CreateAttributeRequest) (*models.MCPDomainAttribute, error) {
	return a.mcpService.CreateDomainAttribute(context.Background(), domainName, req)
}

func (a *mcpHandlerServiceAdapter) GetDomainAttribute(compositeID string) (*models.MCPDomainAttribute, error) {
	return a.mcpService.GetDomainAttribute(context.Background(), compositeID)
}

func (a *mcpHandlerServiceAdapter) UpdateDomainAttribute(compositeID string, req *models.UpdateAttributeRequest) (*models.MCPDomainAttribute, error) {
	return a.mcpService.UpdateDomainAttribute(context.Background(), compositeID, req)
}

func (a *mcpHandlerServiceAdapter) DeleteDomainAttribute(compositeID string) error {
	return a.mcpService.DeleteDomainAttribute(context.Background(), compositeID)
}
