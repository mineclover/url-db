
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">url-db/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">url-db/docs/docs.go (0.0%)</option>
				
				<option value="file2">url-db/generated/tool_constants.go (0.0%)</option>
				
				<option value="file3">url-db/internal/attributes/handler.go (0.0%)</option>
				
				<option value="file4">url-db/internal/attributes/repository.go (82.1%)</option>
				
				<option value="file5">url-db/internal/attributes/service.go (84.1%)</option>
				
				<option value="file6">url-db/internal/attributes/types.go (75.0%)</option>
				
				<option value="file7">url-db/internal/attributes/validators.go (94.1%)</option>
				
				<option value="file8">url-db/internal/compositekey/composite_key.go (100.0%)</option>
				
				<option value="file9">url-db/internal/compositekey/errors.go (83.3%)</option>
				
				<option value="file10">url-db/internal/compositekey/normalizer.go (100.0%)</option>
				
				<option value="file11">url-db/internal/compositekey/service.go (100.0%)</option>
				
				<option value="file12">url-db/internal/compositekey/validator.go (100.0%)</option>
				
				<option value="file13">url-db/internal/config/config.go (100.0%)</option>
				
				<option value="file14">url-db/internal/core/domain/models/dependency.go (0.0%)</option>
				
				<option value="file15">url-db/internal/core/domain/models/subscription.go (0.0%)</option>
				
				<option value="file16">url-db/internal/core/usecases/handler.go (0.0%)</option>
				
				<option value="file17">url-db/internal/core/usecases/repository.go (82.1%)</option>
				
				<option value="file18">url-db/internal/core/usecases/service.go (84.1%)</option>
				
				<option value="file19">url-db/internal/core/usecases/services/attribute.go (0.0%)</option>
				
				<option value="file20">url-db/internal/core/usecases/services/composite_key.go (0.0%)</option>
				
				<option value="file21">url-db/internal/core/usecases/services/dependency_service.go (0.0%)</option>
				
				<option value="file22">url-db/internal/core/usecases/services/domain.go (0.0%)</option>
				
				<option value="file23">url-db/internal/core/usecases/services/errors.go (50.0%)</option>
				
				<option value="file24">url-db/internal/core/usecases/services/event_service.go (0.0%)</option>
				
				<option value="file25">url-db/internal/core/usecases/services/mcp.go (0.0%)</option>
				
				<option value="file26">url-db/internal/core/usecases/services/node.go (0.0%)</option>
				
				<option value="file27">url-db/internal/core/usecases/services/node_attribute.go (0.0%)</option>
				
				<option value="file28">url-db/internal/core/usecases/services/node_count_service.go (0.0%)</option>
				
				<option value="file29">url-db/internal/core/usecases/services/subscription_service.go (0.0%)</option>
				
				<option value="file30">url-db/internal/core/usecases/services/testutils.go (0.0%)</option>
				
				<option value="file31">url-db/internal/core/usecases/services/validators.go (58.6%)</option>
				
				<option value="file32">url-db/internal/core/usecases/types.go (75.0%)</option>
				
				<option value="file33">url-db/internal/core/usecases/validators.go (94.1%)</option>
				
				<option value="file34">url-db/internal/database/config.go (100.0%)</option>
				
				<option value="file35">url-db/internal/database/database.go (69.0%)</option>
				
				<option value="file36">url-db/internal/domains/errors.go (0.0%)</option>
				
				<option value="file37">url-db/internal/domains/handler.go (0.0%)</option>
				
				<option value="file38">url-db/internal/domains/repository.go (0.0%)</option>
				
				<option value="file39">url-db/internal/domains/service.go (0.0%)</option>
				
				<option value="file40">url-db/internal/handlers/attribute_handler.go (76.1%)</option>
				
				<option value="file41">url-db/internal/handlers/base_handler.go (100.0%)</option>
				
				<option value="file42">url-db/internal/handlers/dependency_handler.go (0.0%)</option>
				
				<option value="file43">url-db/internal/handlers/domain_handler.go (89.8%)</option>
				
				<option value="file44">url-db/internal/handlers/errors.go (100.0%)</option>
				
				<option value="file45">url-db/internal/handlers/event_handler.go (0.0%)</option>
				
				<option value="file46">url-db/internal/handlers/health_handler.go (100.0%)</option>
				
				<option value="file47">url-db/internal/handlers/mcp_handler.go (0.0%)</option>
				
				<option value="file48">url-db/internal/handlers/middleware.go (0.0%)</option>
				
				<option value="file49">url-db/internal/handlers/node_attribute_handler.go (0.0%)</option>
				
				<option value="file50">url-db/internal/handlers/node_handler.go (82.0%)</option>
				
				<option value="file51">url-db/internal/handlers/router.go (0.0%)</option>
				
				<option value="file52">url-db/internal/handlers/routes.go (0.0%)</option>
				
				<option value="file53">url-db/internal/handlers/subscription_handler.go (0.0%)</option>
				
				<option value="file54">url-db/internal/infrastructure/config/config.go (0.0%)</option>
				
				<option value="file55">url-db/internal/infrastructure/database/config.go (66.7%)</option>
				
				<option value="file56">url-db/internal/infrastructure/database/database.go (69.0%)</option>
				
				<option value="file57">url-db/internal/infrastructure/repositories/attribute.go (0.0%)</option>
				
				<option value="file58">url-db/internal/infrastructure/repositories/base.go (47.7%)</option>
				
				<option value="file59">url-db/internal/infrastructure/repositories/dependency_repository.go (0.0%)</option>
				
				<option value="file60">url-db/internal/infrastructure/repositories/domain.go (67.8%)</option>
				
				<option value="file61">url-db/internal/infrastructure/repositories/errors.go (42.9%)</option>
				
				<option value="file62">url-db/internal/infrastructure/repositories/event_repository.go (0.0%)</option>
				
				<option value="file63">url-db/internal/infrastructure/repositories/interfaces.go (0.0%)</option>
				
				<option value="file64">url-db/internal/infrastructure/repositories/node.go (60.0%)</option>
				
				<option value="file65">url-db/internal/infrastructure/repositories/node_attribute.go (0.0%)</option>
				
				<option value="file66">url-db/internal/infrastructure/repositories/node_connection.go (0.0%)</option>
				
				<option value="file67">url-db/internal/infrastructure/repositories/subscription_repository.go (0.0%)</option>
				
				<option value="file68">url-db/internal/infrastructure/repositories/testutils.go (44.4%)</option>
				
				<option value="file69">url-db/internal/interfaces/http/attribute_handler.go (0.0%)</option>
				
				<option value="file70">url-db/internal/interfaces/http/base_handler.go (0.0%)</option>
				
				<option value="file71">url-db/internal/interfaces/http/dependency_handler.go (0.0%)</option>
				
				<option value="file72">url-db/internal/interfaces/http/domain_handler.go (0.0%)</option>
				
				<option value="file73">url-db/internal/interfaces/http/errors.go (100.0%)</option>
				
				<option value="file74">url-db/internal/interfaces/http/event_handler.go (0.0%)</option>
				
				<option value="file75">url-db/internal/interfaces/http/health_handler.go (0.0%)</option>
				
				<option value="file76">url-db/internal/interfaces/http/mcp_handler.go (0.0%)</option>
				
				<option value="file77">url-db/internal/interfaces/http/middleware.go (0.0%)</option>
				
				<option value="file78">url-db/internal/interfaces/http/node_attribute_handler.go (0.0%)</option>
				
				<option value="file79">url-db/internal/interfaces/http/node_handler.go (0.0%)</option>
				
				<option value="file80">url-db/internal/interfaces/http/router.go (0.0%)</option>
				
				<option value="file81">url-db/internal/interfaces/http/routes.go (0.0%)</option>
				
				<option value="file82">url-db/internal/interfaces/http/subscription_handler.go (0.0%)</option>
				
				<option value="file83">url-db/internal/interfaces/mcp/attribute.go (0.0%)</option>
				
				<option value="file84">url-db/internal/interfaces/mcp/attribute_operations.go (0.0%)</option>
				
				<option value="file85">url-db/internal/interfaces/mcp/batch.go (0.0%)</option>
				
				<option value="file86">url-db/internal/interfaces/mcp/composite_key_adapter.go (63.6%)</option>
				
				<option value="file87">url-db/internal/interfaces/mcp/converter.go (0.0%)</option>
				
				<option value="file88">url-db/internal/interfaces/mcp/domain.go (0.0%)</option>
				
				<option value="file89">url-db/internal/interfaces/mcp/domain_operations.go (0.0%)</option>
				
				<option value="file90">url-db/internal/interfaces/mcp/errors.go (100.0%)</option>
				
				<option value="file91">url-db/internal/interfaces/mcp/external_operations.go (0.0%)</option>
				
				<option value="file92">url-db/internal/interfaces/mcp/handler.go (0.0%)</option>
				
				<option value="file93">url-db/internal/interfaces/mcp/jsonrpc.go (100.0%)</option>
				
				<option value="file94">url-db/internal/interfaces/mcp/metadata.go (0.0%)</option>
				
				<option value="file95">url-db/internal/interfaces/mcp/node_operations.go (0.0%)</option>
				
				<option value="file96">url-db/internal/interfaces/mcp/query_operations.go (0.0%)</option>
				
				<option value="file97">url-db/internal/interfaces/mcp/resources.go (86.6%)</option>
				
				<option value="file98">url-db/internal/interfaces/mcp/service.go (0.0%)</option>
				
				<option value="file99">url-db/internal/interfaces/mcp/stdio_server.go (0.0%)</option>
				
				<option value="file100">url-db/internal/interfaces/mcp/tool_constants.go (0.0%)</option>
				
				<option value="file101">url-db/internal/interfaces/mcp/tools.go (39.0%)</option>
				
				<option value="file102">url-db/internal/mcp/attribute.go (0.0%)</option>
				
				<option value="file103">url-db/internal/mcp/attribute_operations.go (0.0%)</option>
				
				<option value="file104">url-db/internal/mcp/batch.go (0.0%)</option>
				
				<option value="file105">url-db/internal/mcp/composite_key_adapter.go (63.6%)</option>
				
				<option value="file106">url-db/internal/mcp/converter.go (0.0%)</option>
				
				<option value="file107">url-db/internal/mcp/domain.go (0.0%)</option>
				
				<option value="file108">url-db/internal/mcp/domain_operations.go (0.0%)</option>
				
				<option value="file109">url-db/internal/mcp/errors.go (100.0%)</option>
				
				<option value="file110">url-db/internal/mcp/external_operations.go (0.0%)</option>
				
				<option value="file111">url-db/internal/mcp/handler.go (0.0%)</option>
				
				<option value="file112">url-db/internal/mcp/jsonrpc.go (100.0%)</option>
				
				<option value="file113">url-db/internal/mcp/metadata.go (0.0%)</option>
				
				<option value="file114">url-db/internal/mcp/node_operations.go (0.0%)</option>
				
				<option value="file115">url-db/internal/mcp/query_operations.go (0.0%)</option>
				
				<option value="file116">url-db/internal/mcp/resources.go (86.6%)</option>
				
				<option value="file117">url-db/internal/mcp/service.go (0.0%)</option>
				
				<option value="file118">url-db/internal/mcp/stdio_server.go (0.0%)</option>
				
				<option value="file119">url-db/internal/mcp/tool_constants.go (0.0%)</option>
				
				<option value="file120">url-db/internal/mcp/tools.go (39.0%)</option>
				
				<option value="file121">url-db/internal/models/dependency.go (0.0%)</option>
				
				<option value="file122">url-db/internal/models/subscription.go (0.0%)</option>
				
				<option value="file123">url-db/internal/nodeattributes/handler.go (0.0%)</option>
				
				<option value="file124">url-db/internal/nodeattributes/order_manager.go (0.0%)</option>
				
				<option value="file125">url-db/internal/nodeattributes/repository.go (0.0%)</option>
				
				<option value="file126">url-db/internal/nodeattributes/service.go (32.9%)</option>
				
				<option value="file127">url-db/internal/nodeattributes/validators.go (93.5%)</option>
				
				<option value="file128">url-db/internal/nodes/handler.go (0.0%)</option>
				
				<option value="file129">url-db/internal/nodes/repository.go (83.5%)</option>
				
				<option value="file130">url-db/internal/nodes/service.go (0.0%)</option>
				
				<option value="file131">url-db/internal/nodes/service_with_events.go (0.0%)</option>
				
				<option value="file132">url-db/internal/nodes/url_utils.go (93.0%)</option>
				
				<option value="file133">url-db/internal/repositories/attribute.go (0.0%)</option>
				
				<option value="file134">url-db/internal/repositories/base.go (47.7%)</option>
				
				<option value="file135">url-db/internal/repositories/dependency_repository.go (0.0%)</option>
				
				<option value="file136">url-db/internal/repositories/domain.go (67.8%)</option>
				
				<option value="file137">url-db/internal/repositories/errors.go (42.9%)</option>
				
				<option value="file138">url-db/internal/repositories/event_repository.go (0.0%)</option>
				
				<option value="file139">url-db/internal/repositories/interfaces.go (0.0%)</option>
				
				<option value="file140">url-db/internal/repositories/node.go (60.0%)</option>
				
				<option value="file141">url-db/internal/repositories/node_attribute.go (0.0%)</option>
				
				<option value="file142">url-db/internal/repositories/node_connection.go (0.0%)</option>
				
				<option value="file143">url-db/internal/repositories/subscription_repository.go (0.0%)</option>
				
				<option value="file144">url-db/internal/repositories/testutils.go (44.4%)</option>
				
				<option value="file145">url-db/internal/services/advanced/dependency_graph.go (0.0%)</option>
				
				<option value="file146">url-db/internal/services/advanced/dependency_impact.go (0.0%)</option>
				
				<option value="file147">url-db/internal/services/attribute.go (0.0%)</option>
				
				<option value="file148">url-db/internal/services/composite_key.go (0.0%)</option>
				
				<option value="file149">url-db/internal/services/dependency_service.go (0.0%)</option>
				
				<option value="file150">url-db/internal/services/domain.go (53.8%)</option>
				
				<option value="file151">url-db/internal/services/errors.go (16.7%)</option>
				
				<option value="file152">url-db/internal/services/event_service.go (0.0%)</option>
				
				<option value="file153">url-db/internal/services/mcp.go (0.0%)</option>
				
				<option value="file154">url-db/internal/services/node.go (49.6%)</option>
				
				<option value="file155">url-db/internal/services/node_attribute.go (0.0%)</option>
				
				<option value="file156">url-db/internal/services/node_count_service.go (0.0%)</option>
				
				<option value="file157">url-db/internal/services/subscription_service.go (0.0%)</option>
				
				<option value="file158">url-db/internal/services/testutils.go (72.4%)</option>
				
				<option value="file159">url-db/internal/services/validators.go (27.1%)</option>
				
				<option value="file160">url-db/internal/shared/utils/composite_key.go (100.0%)</option>
				
				<option value="file161">url-db/internal/shared/utils/errors.go (83.3%)</option>
				
				<option value="file162">url-db/internal/shared/utils/normalizer.go (100.0%)</option>
				
				<option value="file163">url-db/internal/shared/utils/service.go (100.0%)</option>
				
				<option value="file164">url-db/internal/shared/utils/validator.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "url-db/internal/attributes"
        "url-db/internal/compositekey"
        "url-db/internal/config"
        "url-db/internal/constants"
        "url-db/internal/database"
        "url-db/internal/domains"
        "url-db/internal/handlers"
        "url-db/internal/mcp"
        "url-db/internal/models"
        "url-db/internal/nodeattributes"
        "url-db/internal/nodes"
        "url-db/internal/repositories"
        "url-db/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/jmoiron/sqlx"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"

        _ "url-db/docs" // docs is generated by Swag CLI, you have to import it.
)

// @title           URL Database API
// @version         1.0
// @description     A URL management system with attribute support and MCP integration.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api

// @securityDefinitions.basic  BasicAuth

func main() <span class="cov0" title="0">{
        // Parse command line flags
        var (
                mcpMode  = flag.String("mcp-mode", "sse", "MCP server mode: 'stdio' for stdin/stdout, 'sse' for HTTP server")
                dbPath   = flag.String("db-path", "", "Path to the database file (overrides DATABASE_URL)")
                toolName = flag.String("tool-name", "", "Tool name for composite keys (default: "+constants.DefaultServerName+")")
                port     = flag.String("port", "", "Port for HTTP server (default: "+strconv.Itoa(constants.DefaultPort)+")")
                showHelp = flag.Bool("help", false, "Show help message")
                version  = flag.Bool("version", false, "Show version information")
        )
        flag.Parse()

        if *showHelp </span><span class="cov0" title="0">{
                fmt.Println("URL Database Server")
                fmt.Println("Usage:")
                fmt.Println("  url-db [options]")
                fmt.Println()
                fmt.Println("Options:")
                fmt.Println("  -mcp-mode string")
                fmt.Println("        MCP server mode: 'stdio' for stdin/stdout, 'sse' for HTTP server (default \"sse\")")
                fmt.Println("  -db-path string")
                fmt.Println("        Path to the database file (e.g., ~/url-db.db)")
                fmt.Println("  -tool-name string")
                fmt.Println("        Tool name for composite keys (default: url-db)")
                fmt.Println("  -port string")
                fmt.Println("        Port for HTTP server (default: 8080)")
                fmt.Println("  -help")
                fmt.Println("        Show help message")
                fmt.Println("  -version")
                fmt.Println("        Show version information")
                fmt.Println()
                fmt.Println("Examples:")
                fmt.Println("  url-db                                          # Start HTTP server")
                fmt.Println("  url-db -mcp-mode=stdio -db-path=~/url-db.db    # MCP stdio mode")
                fmt.Println("  url-db -mcp-mode=stdio -db-path=~/work.db -tool-name=work")
                fmt.Println("  url-db -help                                    # Show this help")
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">if *version </span><span class="cov0" title="0">{
                fmt.Println("URL Database Server v" + constants.DefaultServerVersion)
                fmt.Println("Built with Go", "runtime.Version()")
                os.Exit(0)
        }</span>

        // Set gin mode early if in stdio mode to prevent debug output
        <span class="cov0" title="0">if *mcpMode == "stdio" </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
                log.SetOutput(io.Discard)
        }</span>

        <span class="cov0" title="0">cfg := config.Load()

        // Override configuration with command-line flags
        if *dbPath != "" </span><span class="cov0" title="0">{
                // If tool name is not specified, extract from db filename
                if *toolName == "" </span><span class="cov0" title="0">{
                        // Extract base name from path (e.g., "work.db" -&gt; "work")
                        baseName := filepath.Base(*dbPath)
                        if ext := filepath.Ext(baseName); ext != "" </span><span class="cov0" title="0">{
                                baseName = strings.TrimSuffix(baseName, ext)
                        }</span>
                        // Use the base name as tool name if valid
                        <span class="cov0" title="0">if baseName != "" &amp;&amp; baseName != "." </span><span class="cov0" title="0">{
                                *toolName = baseName
                        }</span>
                }
                <span class="cov0" title="0">cfg.DatabaseURL = "file:" + *dbPath</span>
        }
        <span class="cov0" title="0">if *toolName != "" </span><span class="cov0" title="0">{
                cfg.ToolName = *toolName
        }</span>
        <span class="cov0" title="0">if *port != "" </span><span class="cov0" title="0">{
                cfg.Port = *port
        }</span>

        <span class="cov0" title="0">db, err := database.InitDB(cfg.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to initialize database:", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Get the underlying *sql.DB for standard repos
        sqlDB := db.DB()

        // Create sqlx.DB for nodeattributes repo
        sqlxDB := sqlx.NewDb(sqlDB, "sqlite3")

        // Initialize repositories
        domainRepo := domains.NewDomainRepository(sqlDB)
        nodeRepo := nodes.NewSQLiteNodeRepository(sqlDB)
        attributeRepo := attributes.NewSQLiteAttributeRepository(sqlDB)
        nodeAttributeRepo := nodeattributes.NewRepository(sqlxDB)

        // Use the repositories package for MCP service dependencies
        repos := repositories.NewRepositories(sqlDB)

        // Initialize external dependency repositories
        subscriptionRepo := repositories.NewSubscriptionRepository(sqlxDB)
        dependencyRepo := repositories.NewDependencyRepository(sqlxDB)
        eventRepo := repositories.NewEventRepository(sqlxDB)

        // Initialize external dependency services
        subscriptionService := services.NewSubscriptionService(subscriptionRepo, repos.Node, eventRepo)
        dependencyService := services.NewDependencyService(dependencyRepo, repos.Node, eventRepo)
        eventService := services.NewEventService(eventRepo, repos.Node)

        // Initialize services
        domainService := domains.NewDomainService(domainRepo)
        basicNodeService := nodes.NewNodeService(nodeRepo)
        // Wrap node service with event tracking
        nodeService := nodes.NewNodeServiceWithEvents(basicNodeService, eventService)
        attributeService := attributes.NewAttributeService(attributeRepo, domainService)

        // Initialize validators and managers for node attributes
        nodeAttributeValidator := nodeattributes.NewValidator()
        nodeAttributeOrderManager := nodeattributes.NewOrderManager(nodeAttributeRepo)
        nodeAttributeService := nodeattributes.NewService(nodeAttributeRepo, nodeAttributeValidator, nodeAttributeOrderManager)

        // Create adapter services for MCP
        mcpDomainService := &amp;mcpDomainServiceAdapter{domainService: domainService, domainRepo: domainRepo}
        mcpNodeService := &amp;mcpNodeServiceAdapter{nodeService: nodeService}
        mcpAttributeService := &amp;mcpAttributeServiceAdapter{nodeAttributeService: nodeAttributeService, attributeService: attributeService}

        // Initialize additional services
        nodeCountService := &amp;nodeCountServiceAdapter{nodeRepo: repos.Node}

        // Initialize composite key service
        compositeKeyService := compositekey.NewService(cfg.ToolName)
        compositeKeyAdapter := mcp.NewCompositeKeyAdapter(compositeKeyService)

        // Initialize MCP converter and service
        mcpConverter := mcp.NewConverter(compositeKeyAdapter, cfg.ToolName)
        mcpService := mcp.NewMCPService(mcpNodeService, mcpDomainService, mcpAttributeService, nodeCountService, subscriptionService, dependencyService, eventService, mcpConverter)

        // Initialize handlers
        domainHandler := domains.NewDomainHandler(domainService)
        nodeHandler := nodes.NewNodeHandler(nodeService)
        attributeHandler := attributes.NewAttributeHandler(attributeService)
        nodeAttributeHandler := nodeattributes.NewHandler(nodeAttributeService)

        // Initialize external dependency handlers
        subscriptionHandler := handlers.NewSubscriptionHandler(subscriptionService)
        dependencyHandler := handlers.NewDependencyHandler(dependencyService)
        eventHandler := handlers.NewEventHandler(eventService)

        // Create MCP handler with service adapter
        mcpHandlerService := &amp;mcpHandlerServiceAdapter{mcpService: mcpService}
        mcpHandler := handlers.NewMCPHandler(mcpHandlerService)

        // Setup routes
        r := gin.Default()

        // Setup CORS middleware
        r.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })

        // Health check endpoint
        <span class="cov0" title="0">r.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(constants.StatusOK, gin.H{
                        "status":  "healthy",
                        "service": constants.DefaultServerName,
                })
        }</span>)

        // Swagger documentation
        <span class="cov0" title="0">r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        // Register all routes manually to avoid conflicts
        api := r.Group("/api")

        // Domain routes
        api.POST("/domains", domainHandler.CreateDomain)
        api.GET("/domains", domainHandler.ListDomains)
        api.GET("/domains/:domain_id", func(c *gin.Context) </span><span class="cov0" title="0">{
                // Convert :domain_id to :id for the domain handler
                domainID := c.Param("domain_id")
                c.Params = []gin.Param{{Key: "id", Value: domainID}}
                domainHandler.GetDomain(c)
        }</span>)
        <span class="cov0" title="0">api.PUT("/domains/:domain_id", func(c *gin.Context) </span><span class="cov0" title="0">{
                // Convert :domain_id to :id for the domain handler
                domainID := c.Param("domain_id")
                c.Params = []gin.Param{{Key: "id", Value: domainID}}
                domainHandler.UpdateDomain(c)
        }</span>)
        <span class="cov0" title="0">api.DELETE("/domains/:domain_id", func(c *gin.Context) </span><span class="cov0" title="0">{
                // Convert :domain_id to :id for the domain handler
                domainID := c.Param("domain_id")
                c.Params = []gin.Param{{Key: "id", Value: domainID}}
                domainHandler.DeleteDomain(c)
        }</span>)

        // Domain attribute routes
        <span class="cov0" title="0">api.POST("/domains/:domain_id/attributes", attributeHandler.CreateAttribute)
        api.GET("/domains/:domain_id/attributes", attributeHandler.ListAttributes)

        // Attribute detail routes
        api.GET("/attributes/:id", attributeHandler.GetAttribute)
        api.PUT("/attributes/:id", attributeHandler.UpdateAttribute)
        api.DELETE("/attributes/:id", attributeHandler.DeleteAttribute)

        // Node routes
        api.POST("/domains/:domain_id/urls", nodeHandler.CreateNode)
        api.GET("/domains/:domain_id/urls", nodeHandler.GetNodesByDomain)
        api.POST("/domains/:domain_id/urls/find", nodeHandler.FindNodeByURL)
        api.GET("/urls/:id", nodeHandler.GetNode)
        api.PUT("/urls/:id", nodeHandler.UpdateNode)
        api.DELETE("/urls/:id", nodeHandler.DeleteNode)

        // Node attribute routes
        api.POST("/urls/:id/attributes", func(c *gin.Context) </span><span class="cov0" title="0">{
                // Convert :id to :url_id for the node attribute handler
                urlID := c.Param("id")
                c.Params = []gin.Param{{Key: "url_id", Value: urlID}}
                nodeAttributeHandler.CreateNodeAttribute(c)
        }</span>)
        <span class="cov0" title="0">api.GET("/urls/:id/attributes", func(c *gin.Context) </span><span class="cov0" title="0">{
                // Convert :id to :url_id for the node attribute handler
                urlID := c.Param("id")
                c.Params = []gin.Param{{Key: "url_id", Value: urlID}}
                nodeAttributeHandler.GetNodeAttributesByNodeID(c)
        }</span>)
        <span class="cov0" title="0">api.GET("/url-attributes/:id", nodeAttributeHandler.GetNodeAttributeByID)
        api.PUT("/url-attributes/:id", nodeAttributeHandler.UpdateNodeAttribute)
        api.DELETE("/url-attributes/:id", nodeAttributeHandler.DeleteNodeAttribute)
        api.DELETE("/urls/:id/attributes/:attribute_id", func(c *gin.Context) </span><span class="cov0" title="0">{
                // Convert :id to :url_id for the node attribute handler
                urlID := c.Param("id")
                attributeID := c.Param("attribute_id")
                c.Params = []gin.Param{
                        {Key: "url_id", Value: urlID},
                        {Key: "attribute_id", Value: attributeID},
                }
                nodeAttributeHandler.DeleteNodeAttributeByNodeIDAndAttributeID(c)
        }</span>)

        // External dependency routes
        // Subscription routes
        <span class="cov0" title="0">api.POST("/nodes/:nodeId/subscriptions", subscriptionHandler.CreateSubscription)
        api.GET("/nodes/:nodeId/subscriptions", subscriptionHandler.GetNodeSubscriptions)
        api.GET("/subscriptions", subscriptionHandler.GetServiceSubscriptions)
        api.GET("/subscriptions/:id", subscriptionHandler.GetSubscription)
        api.PUT("/subscriptions/:id", subscriptionHandler.UpdateSubscription)
        api.DELETE("/subscriptions/:id", subscriptionHandler.DeleteSubscription)

        // Dependency routes
        api.POST("/nodes/:nodeId/dependencies", dependencyHandler.CreateDependency)
        api.GET("/nodes/:nodeId/dependencies", dependencyHandler.GetNodeDependencies)
        api.GET("/nodes/:nodeId/dependents", dependencyHandler.GetNodeDependents)
        api.GET("/dependencies/:id", dependencyHandler.GetDependency)
        api.DELETE("/dependencies/:id", dependencyHandler.DeleteDependency)

        // Event routes
        api.GET("/nodes/:nodeId/events", eventHandler.GetNodeEvents)
        api.GET("/events/pending", eventHandler.GetPendingEvents)
        api.GET("/events", eventHandler.GetEventsByType)
        api.GET("/events/stats", eventHandler.GetEventStats)
        api.POST("/events/:eventId/process", eventHandler.ProcessEvent)
        api.POST("/events/cleanup", eventHandler.CleanupEvents)

        // Handle different MCP modes
        switch *mcpMode </span>{
        case "stdio":<span class="cov0" title="0">
                // stdio mode: MCP communication via stdin/stdout, then exit
                stdioServer := mcp.NewStdioServer(mcpService)
                if err := stdioServer.Start(); err != nil </span><span class="cov0" title="0">{
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return</span>

        case "sse":<span class="cov0" title="0">
                // SSE mode: HTTP server with MCP endpoints (default)
                log.Println("Starting MCP SSE mode (HTTP server)...")

                // Register MCP routes
                mcpHandler.RegisterRoutes(r)

                log.Printf("Server starting on port %s", cfg.Port)
                if err := r.Run(":" + cfg.Port); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Failed to start server:", err)
                }</span>
        }
}

// Adapter services to bridge interface differences

type mcpDomainServiceAdapter struct {
        domainService domains.DomainService
        domainRepo    domains.DomainRepository
}

func (a *mcpDomainServiceAdapter) CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*models.Domain, error) <span class="cov0" title="0">{
        return a.domainService.CreateDomain(ctx, req)
}</span>

func (a *mcpDomainServiceAdapter) GetDomain(ctx context.Context, domainID int) (*models.Domain, error) <span class="cov0" title="0">{
        return a.domainService.GetDomain(ctx, domainID)
}</span>

func (a *mcpDomainServiceAdapter) GetDomainByName(ctx context.Context, name string) (*models.Domain, error) <span class="cov0" title="0">{
        return a.domainRepo.GetByName(ctx, name)
}</span>

func (a *mcpDomainServiceAdapter) ListDomains(ctx context.Context, page, size int) (*models.DomainListResponse, error) <span class="cov0" title="0">{
        return a.domainService.ListDomains(ctx, page, size)
}</span>

func (a *mcpDomainServiceAdapter) UpdateDomain(ctx context.Context, domainID int, req *models.UpdateDomainRequest) (*models.Domain, error) <span class="cov0" title="0">{
        return a.domainService.UpdateDomain(ctx, domainID, req)
}</span>

func (a *mcpDomainServiceAdapter) DeleteDomain(ctx context.Context, domainID int) error <span class="cov0" title="0">{
        return a.domainService.DeleteDomain(ctx, domainID)
}</span>

type mcpNodeServiceAdapter struct {
        nodeService nodes.NodeService
}

func (a *mcpNodeServiceAdapter) CreateNode(ctx context.Context, domainID int, req *models.CreateNodeRequest) (*models.Node, error) <span class="cov0" title="0">{
        return a.nodeService.CreateNode(domainID, req)
}</span>

func (a *mcpNodeServiceAdapter) GetNode(ctx context.Context, nodeID int) (*models.Node, error) <span class="cov0" title="0">{
        return a.nodeService.GetNodeByID(nodeID)
}</span>

func (a *mcpNodeServiceAdapter) UpdateNode(ctx context.Context, nodeID int, req *models.UpdateNodeRequest) (*models.Node, error) <span class="cov0" title="0">{
        return a.nodeService.UpdateNode(nodeID, req)
}</span>

func (a *mcpNodeServiceAdapter) DeleteNode(ctx context.Context, nodeID int) error <span class="cov0" title="0">{
        return a.nodeService.DeleteNode(nodeID)
}</span>

func (a *mcpNodeServiceAdapter) ListNodes(ctx context.Context, domainID int, page, size int, search string) (*models.NodeListResponse, error) <span class="cov0" title="0">{
        if search != "" </span><span class="cov0" title="0">{
                return a.nodeService.SearchNodes(domainID, search, page, size)
        }</span>
        <span class="cov0" title="0">return a.nodeService.GetNodesByDomainID(domainID, page, size)</span>
}

func (a *mcpNodeServiceAdapter) FindNodeByURL(ctx context.Context, domainID int, req *models.FindNodeByURLRequest) (*models.Node, error) <span class="cov0" title="0">{
        return a.nodeService.FindNodeByURL(domainID, req)
}</span>

type mcpAttributeServiceAdapter struct {
        nodeAttributeService nodeattributes.Service
        attributeService     attributes.AttributeService
}

func (a *mcpAttributeServiceAdapter) GetNodeAttributes(ctx context.Context, nodeID int) ([]models.NodeAttributeWithInfo, error) <span class="cov0" title="0">{
        response, err := a.nodeAttributeService.GetNodeAttributesByNodeID(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return response.Attributes, nil</span>
}

func (a *mcpAttributeServiceAdapter) SetNodeAttribute(ctx context.Context, nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttributeWithInfo, error) <span class="cov0" title="0">{
        attr, err := a.nodeAttributeService.CreateNodeAttribute(nodeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert NodeAttribute to NodeAttributeWithInfo - we need to get additional info
        <span class="cov0" title="0">return &amp;models.NodeAttributeWithInfo{
                ID:          attr.ID,
                NodeID:      attr.NodeID,
                AttributeID: attr.AttributeID,
                Value:       attr.Value,
                OrderIndex:  attr.OrderIndex,
                CreatedAt:   attr.CreatedAt,
        }, nil</span>
}

func (a *mcpAttributeServiceAdapter) GetAttributeByName(ctx context.Context, domainID int, name string) (*models.Attribute, error) <span class="cov0" title="0">{
        // Get all attributes for the domain and find by name
        response, err := a.attributeService.ListAttributes(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, attr := range response.Attributes </span><span class="cov0" title="0">{
                if attr.Name == name </span><span class="cov0" title="0">{
                        return &amp;attr, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("attribute '%s' not found in domain %d", name, domainID)</span>
}

func (a *mcpAttributeServiceAdapter) DeleteNodeAttribute(ctx context.Context, nodeID, attributeID int) error <span class="cov0" title="0">{
        return a.nodeAttributeService.DeleteNodeAttributeByNodeIDAndAttributeID(nodeID, attributeID)
}</span>

// Domain attribute management methods
func (a *mcpAttributeServiceAdapter) ListAttributes(ctx context.Context, domainID int) (*models.AttributeListResponse, error) <span class="cov0" title="0">{
        return a.attributeService.ListAttributes(ctx, domainID)
}</span>

func (a *mcpAttributeServiceAdapter) CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error) <span class="cov0" title="0">{
        return a.attributeService.CreateAttribute(ctx, domainID, req)
}</span>

func (a *mcpAttributeServiceAdapter) GetAttribute(ctx context.Context, id int) (*models.Attribute, error) <span class="cov0" title="0">{
        return a.attributeService.GetAttribute(ctx, id)
}</span>

func (a *mcpAttributeServiceAdapter) UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error) <span class="cov0" title="0">{
        return a.attributeService.UpdateAttribute(ctx, id, req)
}</span>

func (a *mcpAttributeServiceAdapter) DeleteAttribute(ctx context.Context, id int) error <span class="cov0" title="0">{
        return a.attributeService.DeleteAttribute(ctx, id)
}</span>

type nodeCountServiceAdapter struct {
        nodeRepo repositories.NodeRepository
}

func (a *nodeCountServiceAdapter) GetNodeCountByDomain(ctx context.Context, domainID int) (int, error) <span class="cov0" title="0">{
        return a.nodeRepo.CountNodesByDomain(ctx, domainID)
}</span>

type mcpHandlerServiceAdapter struct {
        mcpService mcp.MCPService
}

func (a *mcpHandlerServiceAdapter) CreateMCPNode(req *models.CreateMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        return a.mcpService.CreateNode(context.Background(), req)
}</span>

func (a *mcpHandlerServiceAdapter) GetMCPNodeByCompositeID(compositeID string) (*models.MCPNode, error) <span class="cov0" title="0">{
        return a.mcpService.GetNode(context.Background(), compositeID)
}</span>

func (a *mcpHandlerServiceAdapter) GetMCPNodes(domainName string, page, size int, search string) (*models.MCPNodeListResponse, error) <span class="cov0" title="0">{
        return a.mcpService.ListNodes(context.Background(), domainName, page, size, search)
}</span>

func (a *mcpHandlerServiceAdapter) UpdateMCPNode(compositeID string, req *models.UpdateMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        // Convert UpdateMCPNodeRequest to UpdateNodeRequest
        nodeReq := &amp;models.UpdateNodeRequest{
                Title:       req.Title,
                Description: req.Description,
        }
        return a.mcpService.UpdateNode(context.Background(), compositeID, nodeReq)
}</span>

func (a *mcpHandlerServiceAdapter) DeleteMCPNode(compositeID string) error <span class="cov0" title="0">{
        return a.mcpService.DeleteNode(context.Background(), compositeID)
}</span>

func (a *mcpHandlerServiceAdapter) FindMCPNodeByURL(req *models.FindMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        return a.mcpService.FindNodeByURL(context.Background(), req)
}</span>

func (a *mcpHandlerServiceAdapter) BatchGetMCPNodes(req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error) <span class="cov0" title="0">{
        return a.mcpService.BatchGetNodes(context.Background(), req)
}</span>

func (a *mcpHandlerServiceAdapter) GetMCPDomains() ([]models.MCPDomain, error) <span class="cov0" title="0">{
        response, err := a.mcpService.ListDomains(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert mcp.MCPDomain to models.MCPDomain
        <span class="cov0" title="0">result := make([]models.MCPDomain, len(response.Domains))
        for i, domain := range response.Domains </span><span class="cov0" title="0">{
                result[i] = models.MCPDomain{
                        Name:        domain.Name,
                        Description: domain.Description,
                        NodeCount:   domain.NodeCount,
                        CreatedAt:   domain.CreatedAt,
                        UpdatedAt:   domain.UpdatedAt,
                }
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (a *mcpHandlerServiceAdapter) CreateMCPDomain(req *models.CreateMCPDomainRequest) (*models.MCPDomain, error) <span class="cov0" title="0">{
        // Convert CreateMCPDomainRequest to CreateDomainRequest
        domainReq := &amp;models.CreateDomainRequest{
                Name:        req.Name,
                Description: req.Description,
        }

        mcpDomain, err := a.mcpService.CreateDomain(context.Background(), domainReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert mcp.MCPDomain to models.MCPDomain
        <span class="cov0" title="0">return &amp;models.MCPDomain{
                Name:        mcpDomain.Name,
                Description: mcpDomain.Description,
                NodeCount:   mcpDomain.NodeCount,
                CreatedAt:   mcpDomain.CreatedAt,
                UpdatedAt:   mcpDomain.UpdatedAt,
        }, nil</span>
}

func (a *mcpHandlerServiceAdapter) GetMCPNodeAttributes(compositeID string) (*models.MCPNodeAttributesResponse, error) <span class="cov0" title="0">{
        response, err := a.mcpService.GetNodeAttributes(context.Background(), compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert MCPNodeAttributeResponse to MCPNodeAttributesResponse
        <span class="cov0" title="0">return &amp;models.MCPNodeAttributesResponse{
                CompositeID: response.CompositeID,
                Attributes:  response.Attributes,
        }, nil</span>
}

func (a *mcpHandlerServiceAdapter) SetMCPNodeAttributes(compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributesResponse, error) <span class="cov0" title="0">{
        response, err := a.mcpService.SetNodeAttributes(context.Background(), compositeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert MCPNodeAttributeResponse to MCPNodeAttributesResponse
        <span class="cov0" title="0">return &amp;models.MCPNodeAttributesResponse{
                CompositeID: response.CompositeID,
                Attributes:  response.Attributes,
        }, nil</span>
}

func (a *mcpHandlerServiceAdapter) GetMCPServerInfo() (*models.MCPServerInfo, error) <span class="cov0" title="0">{
        serverInfo, err := a.mcpService.GetServerInfo(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert mcp.MCPServerInfo to models.MCPServerInfo
        <span class="cov0" title="0">return &amp;models.MCPServerInfo{
                Name:               serverInfo.Name,
                Version:            serverInfo.Version,
                Description:        serverInfo.Description,
                Capabilities:       serverInfo.Capabilities,
                CompositeKeyFormat: serverInfo.CompositeKeyFormat,
        }, nil</span>
}

// Domain attribute management methods
func (a *mcpHandlerServiceAdapter) ListDomainAttributes(domainName string) (*models.MCPDomainAttributeListResponse, error) <span class="cov0" title="0">{
        return a.mcpService.ListDomainAttributes(context.Background(), domainName)
}</span>

func (a *mcpHandlerServiceAdapter) CreateDomainAttribute(domainName string, req *models.CreateAttributeRequest) (*models.MCPDomainAttribute, error) <span class="cov0" title="0">{
        return a.mcpService.CreateDomainAttribute(context.Background(), domainName, req)
}</span>

func (a *mcpHandlerServiceAdapter) GetDomainAttribute(compositeID string) (*models.MCPDomainAttribute, error) <span class="cov0" title="0">{
        return a.mcpService.GetDomainAttribute(context.Background(), compositeID)
}</span>

func (a *mcpHandlerServiceAdapter) UpdateDomainAttribute(compositeID string, req *models.UpdateAttributeRequest) (*models.MCPDomainAttribute, error) <span class="cov0" title="0">{
        return a.mcpService.UpdateDomainAttribute(context.Background(), compositeID, req)
}</span>

func (a *mcpHandlerServiceAdapter) DeleteDomainAttribute(compositeID string) error <span class="cov0" title="0">{
        return a.mcpService.DeleteDomainAttribute(context.Background(), compositeID)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/dependencies/{id}": {
            "get": {
                "description": "Get a dependency by ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "dependencies"
                ],
                "summary": "Get dependency",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Dependency ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NodeDependency"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a dependency relationship",
                "tags": [
                    "dependencies"
                ],
                "summary": "Delete dependency",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Dependency ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/events": {
            "get": {
                "description": "Get events by type within a date range",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Get events by type",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Event type",
                        "name": "type",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Start date (RFC3339)",
                        "name": "start",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "End date (RFC3339)",
                        "name": "end",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.NodeEvent"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/events/cleanup": {
            "post": {
                "description": "Delete processed events older than specified days",
                "tags": [
                    "events"
                ],
                "summary": "Cleanup old events",
                "parameters": [
                    {
                        "minimum": 1,
                        "type": "integer",
                        "description": "Number of days to retain events",
                        "name": "days",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/events/pending": {
            "get": {
                "description": "Get unprocessed events for processing",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Get pending events",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 100,
                        "description": "Maximum number of events to return",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.NodeEvent"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/events/stats": {
            "get": {
                "description": "Get statistics about events in the system",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Get event statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/events/{eventId}/process": {
            "post": {
                "description": "Mark an event as processed",
                "tags": [
                    "events"
                ],
                "summary": "Process event",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Event ID",
                        "name": "eventId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/nodes/{nodeId}/dependencies": {
            "get": {
                "description": "Get all dependencies where the node is dependent",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "dependencies"
                ],
                "summary": "Get node dependencies",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node ID",
                        "name": "nodeId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.NodeDependency"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new dependency relationship between nodes",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "dependencies"
                ],
                "summary": "Create dependency",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Dependent Node ID",
                        "name": "nodeId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Dependency details",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateNodeDependencyRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.NodeDependency"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Circular dependency detected",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/nodes/{nodeId}/dependents": {
            "get": {
                "description": "Get all nodes that depend on this node",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "dependencies"
                ],
                "summary": "Get node dependents",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node ID",
                        "name": "nodeId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.NodeDependency"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/nodes/{nodeId}/events": {
            "get": {
                "description": "Get events for a specific node",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Get node events",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node ID",
                        "name": "nodeId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "default": 50,
                        "description": "Maximum number of events to return",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.NodeEvent"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/nodes/{nodeId}/subscriptions": {
            "get": {
                "description": "Get all subscriptions for a specific node",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "subscriptions"
                ],
                "summary": "Get node subscriptions",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node ID",
                        "name": "nodeId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.NodeSubscription"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new subscription for node events",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "subscriptions"
                ],
                "summary": "Create subscription",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node ID",
                        "name": "nodeId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Subscription details",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateNodeSubscriptionRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.NodeSubscription"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/subscriptions": {
            "get": {
                "description": "Get all subscriptions for a specific service",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "subscriptions"
                ],
                "summary": "Get service subscriptions",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Service name",
                        "name": "service",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.NodeSubscription"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/subscriptions/{id}": {
            "get": {
                "description": "Get a subscription by ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "subscriptions"
                ],
                "summary": "Get subscription",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Subscription ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NodeSubscription"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update a subscription",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "subscriptions"
                ],
                "summary": "Update subscription",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Subscription ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Update details",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateNodeSubscriptionRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NodeSubscription"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a subscription",
                "tags": [
                    "subscriptions"
                ],
                "summary": "Delete subscription",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Subscription ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/attributes/{id}": {
            "get": {
                "description": "Get attribute by ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "attributes"
                ],
                "summary": "Get an attribute",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Attribute ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Attribute"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update attribute description by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "attributes"
                ],
                "summary": "Update an attribute",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Attribute ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated attribute data",
                        "name": "attribute",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateAttributeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Attribute"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete attribute by ID (only if no associated values exist)",
                "tags": [
                    "attributes"
                ],
                "summary": "Delete an attribute",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Attribute ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/domains": {
            "get": {
                "description": "Get all domains with pagination",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "domains"
                ],
                "summary": "List domains",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Page size",
                        "name": "size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.DomainListResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new domain with name and description",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "domains"
                ],
                "summary": "Create a new domain",
                "parameters": [
                    {
                        "description": "Domain data",
                        "name": "domain",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateDomainRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.Domain"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/domains/{domain_id}/attributes": {
            "get": {
                "description": "Get all attributes for a domain",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "attributes"
                ],
                "summary": "List attributes",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Domain ID",
                        "name": "domain_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.AttributeListResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new attribute for a domain",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "attributes"
                ],
                "summary": "Create a new attribute",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Domain ID",
                        "name": "domain_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Attribute data",
                        "name": "attribute",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateAttributeRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.Attribute"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/domains/{domain_id}/urls": {
            "get": {
                "description": "Get all nodes in a domain with pagination and optional search",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "nodes"
                ],
                "summary": "Get nodes by domain",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Domain ID",
                        "name": "domain_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Page size",
                        "name": "size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Search term for URL content",
                        "name": "search",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NodeListResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new URL node in a domain",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "nodes"
                ],
                "summary": "Create a new URL node",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Domain ID",
                        "name": "domain_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Node data",
                        "name": "node",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateNodeRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.Node"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/domains/{domain_id}/urls/find": {
            "post": {
                "description": "Find a node by its URL within a domain",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "nodes"
                ],
                "summary": "Find node by URL",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Domain ID",
                        "name": "domain_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "URL to search for",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.FindNodeByURLRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Node"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/domains/{id}": {
            "get": {
                "description": "Get domain by ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "domains"
                ],
                "summary": "Get a domain",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Domain ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Domain"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update domain description by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "domains"
                ],
                "summary": "Update a domain",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Domain ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated domain data",
                        "name": "domain",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateDomainRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Domain"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete domain by ID",
                "tags": [
                    "domains"
                ],
                "summary": "Delete a domain",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Domain ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/mcp/attributes/{composite_id}": {
            "get": {
                "description": "Get a specific attribute definition by composite ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Get domain attribute",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Composite ID (domain:attribute_id)",
                        "name": "composite_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPDomainAttribute"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update an attribute definition by composite ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Update domain attribute",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Composite ID (domain:attribute_id)",
                        "name": "composite_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Attribute update data",
                        "name": "attribute",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateAttributeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPDomainAttribute"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete an attribute definition by composite ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Delete domain attribute",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Composite ID (domain:attribute_id)",
                        "name": "composite_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/mcp/domains": {
            "get": {
                "description": "Get all domains with their node counts in MCP format",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "List MCP domains",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new domain using MCP format",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Create a new MCP domain",
                "parameters": [
                    {
                        "description": "MCP domain data",
                        "name": "domain",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateMCPDomainRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.MCPDomain"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/mcp/domains/{domain_name}/attributes": {
            "get": {
                "description": "Get all attribute definitions for a domain",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "List domain attributes",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Domain name",
                        "name": "domain_name",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPDomainAttributeListResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new attribute definition for a domain",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Create domain attribute",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Domain name",
                        "name": "domain_name",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Attribute data",
                        "name": "attribute",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateAttributeRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.MCPDomainAttribute"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/mcp/nodes": {
            "get": {
                "description": "Get all MCP nodes with pagination, domain filtering, and search",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "List MCP nodes",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by domain name",
                        "name": "domain_name",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Page size (max 100)",
                        "name": "size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Search term for URL content",
                        "name": "search",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPNodeListResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new URL node using MCP composite key format",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Create a new MCP node",
                "parameters": [
                    {
                        "description": "MCP node data",
                        "name": "node",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateMCPNodeRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.MCPNode"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/mcp/nodes/batch": {
            "post": {
                "description": "Get multiple MCP nodes by their composite IDs in a single request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Batch get MCP nodes",
                "parameters": [
                    {
                        "description": "List of composite IDs",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.BatchMCPNodeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.BatchMCPNodeResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/mcp/nodes/find": {
            "post": {
                "description": "Find an MCP node by its URL within a domain",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Find MCP node by URL",
                "parameters": [
                    {
                        "description": "Domain and URL to search for",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.FindMCPNodeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPNode"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/mcp/nodes/{composite_id}": {
            "get": {
                "description": "Get MCP node by composite ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Get an MCP node",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Composite ID (domain::url)",
                        "name": "composite_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPNode"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update MCP node title and description by composite ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Update an MCP node",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Composite ID (domain::url)",
                        "name": "composite_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated MCP node data",
                        "name": "node",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateMCPNodeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPNode"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete MCP node by composite ID",
                "tags": [
                    "mcp"
                ],
                "summary": "Delete an MCP node",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Composite ID (domain::url)",
                        "name": "composite_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/mcp/nodes/{composite_id}/attributes": {
            "get": {
                "description": "Get all attribute values for an MCP node by composite ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Get MCP node attributes",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Composite ID (domain::url)",
                        "name": "composite_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPNodeAttributesResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Set or update attribute values for an MCP node by composite ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Set MCP node attributes",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Composite ID (domain::url)",
                        "name": "composite_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Attribute data to set",
                        "name": "attributes",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.SetMCPNodeAttributesRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPNodeAttributesResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/mcp/server/info": {
            "get": {
                "description": "Get server capabilities and configuration information",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "mcp"
                ],
                "summary": "Get MCP server information",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.MCPServerInfo"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/url-attributes/{id}": {
            "get": {
                "description": "Get a specific node attribute by ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "node-attributes"
                ],
                "summary": "Get a node attribute",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node Attribute ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NodeAttribute"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update a node attribute value and order index by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "node-attributes"
                ],
                "summary": "Update a node attribute",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node Attribute ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated node attribute data",
                        "name": "attribute",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateNodeAttributeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NodeAttribute"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a node attribute by ID",
                "tags": [
                    "node-attributes"
                ],
                "summary": "Delete a node attribute",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node Attribute ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/urls/{id}": {
            "get": {
                "description": "Get node by ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "nodes"
                ],
                "summary": "Get a node",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Node"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update node title and description by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "nodes"
                ],
                "summary": "Update a node",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated node data",
                        "name": "node",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateNodeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Node"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete node by ID",
                "tags": [
                    "nodes"
                ],
                "summary": "Delete a node",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Node ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/urls/{url_id}/attributes": {
            "get": {
                "description": "Get all attribute values for a URL node",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "node-attributes"
                ],
                "summary": "Get node attributes",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "URL Node ID",
                        "name": "url_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NodeAttributeListResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new attribute value for a URL node",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "node-attributes"
                ],
                "summary": "Create a node attribute",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "URL Node ID",
                        "name": "url_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Node attribute data",
                        "name": "attribute",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateNodeAttributeRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.NodeAttribute"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/urls/{url_id}/attributes/{attribute_id}": {
            "delete": {
                "description": "Delete a specific node attribute by URL node ID and attribute ID",
                "tags": [
                    "node-attributes"
                ],
                "summary": "Delete a node attribute by node and attribute ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "URL Node ID",
                        "name": "url_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Attribute ID",
                        "name": "attribute_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "handlers.ErrorResponse": {
            "type": "object",
            "properties": {
                "details": {},
                "error": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "models.Attribute": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "domain_id": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "type": {
                    "$ref": "#/definitions/models.AttributeType"
                }
            }
        },
        "models.AttributeFilter": {
            "type": "object",
            "properties": {
                "attribute_name": {
                    "type": "string"
                },
                "operator": {
                    "type": "string"
                },
                "value": {}
            }
        },
        "models.AttributeListResponse": {
            "type": "object",
            "properties": {
                "attributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Attribute"
                    }
                },
                "domain": {
                    "$ref": "#/definitions/models.Domain"
                }
            }
        },
        "models.AttributeType": {
            "type": "string",
            "enum": [
                "tag",
                "ordered_tag",
                "number",
                "string",
                "markdown",
                "image"
            ],
            "x-enum-varnames": [
                "AttributeTypeTag",
                "AttributeTypeOrderedTag",
                "AttributeTypeNumber",
                "AttributeTypeString",
                "AttributeTypeMarkdown",
                "AttributeTypeImage"
            ]
        },
        "models.BatchMCPNodeRequest": {
            "type": "object",
            "required": [
                "composite_ids"
            ],
            "properties": {
                "composite_ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "models.BatchMCPNodeResponse": {
            "type": "object",
            "properties": {
                "errors": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "nodes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.MCPNode"
                    }
                },
                "not_found": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "models.ChangeFilter": {
            "type": "object",
            "properties": {
                "fields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ignore_fields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "models.CreateAttributeRequest": {
            "type": "object",
            "required": [
                "name",
                "type"
            ],
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 1000
                },
                "name": {
                    "type": "string",
                    "maxLength": 255
                },
                "type": {
                    "$ref": "#/definitions/models.AttributeType"
                }
            }
        },
        "models.CreateDomainRequest": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 1000
                },
                "name": {
                    "type": "string",
                    "maxLength": 255
                }
            }
        },
        "models.CreateMCPDomainRequest": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 1000
                },
                "name": {
                    "type": "string",
                    "maxLength": 255
                }
            }
        },
        "models.CreateMCPNodeRequest": {
            "type": "object",
            "required": [
                "domain_name",
                "url"
            ],
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 1000
                },
                "domain_name": {
                    "type": "string"
                },
                "title": {
                    "type": "string",
                    "maxLength": 255
                },
                "url": {
                    "type": "string",
                    "maxLength": 2048
                }
            }
        },
        "models.CreateNodeAttributeRequest": {
            "type": "object",
            "required": [
                "attribute_id",
                "value"
            ],
            "properties": {
                "attribute_id": {
                    "type": "integer"
                },
                "order_index": {
                    "type": "integer"
                },
                "value": {
                    "type": "string",
                    "maxLength": 2048
                }
            }
        },
        "models.CreateNodeDependencyRequest": {
            "type": "object",
            "required": [
                "dependency_node_id",
                "dependency_type"
            ],
            "properties": {
                "cascade_delete": {
                    "type": "boolean"
                },
                "cascade_update": {
                    "type": "boolean"
                },
                "dependency_node_id": {
                    "type": "integer"
                },
                "dependency_type": {
                    "type": "string",
                    "enum": [
                        "hard",
                        "soft",
                        "reference"
                    ]
                },
                "metadata": {
                    "$ref": "#/definitions/models.DependencyMetadata"
                }
            }
        },
        "models.CreateNodeRequest": {
            "type": "object",
            "required": [
                "url"
            ],
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 1000
                },
                "title": {
                    "type": "string",
                    "maxLength": 255
                },
                "url": {
                    "type": "string",
                    "maxLength": 2048
                }
            }
        },
        "models.CreateNodeSubscriptionRequest": {
            "type": "object",
            "required": [
                "event_types",
                "subscriber_service"
            ],
            "properties": {
                "event_types": {
                    "type": "array",
                    "minItems": 1,
                    "items": {
                        "type": "string"
                    }
                },
                "filter_conditions": {
                    "$ref": "#/definitions/models.FilterCondition"
                },
                "subscriber_endpoint": {
                    "type": "string"
                },
                "subscriber_service": {
                    "type": "string"
                }
            }
        },
        "models.DependencyMetadata": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "relationship": {
                    "type": "string"
                }
            }
        },
        "models.Domain": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "models.DomainListResponse": {
            "type": "object",
            "properties": {
                "domains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Domain"
                    }
                },
                "page": {
                    "type": "integer"
                },
                "size": {
                    "type": "integer"
                },
                "total_count": {
                    "type": "integer"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "models.EventChanges": {
            "type": "object",
            "properties": {
                "after": {
                    "type": "object",
                    "additionalProperties": true
                },
                "before": {
                    "type": "object",
                    "additionalProperties": true
                }
            }
        },
        "models.EventData": {
            "type": "object",
            "properties": {
                "changes": {
                    "$ref": "#/definitions/models.EventChanges"
                },
                "event_id": {
                    "type": "string"
                },
                "event_type": {
                    "type": "string"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true
                },
                "node_id": {
                    "type": "integer"
                },
                "timestamp": {
                    "type": "string"
                }
            }
        },
        "models.FilterCondition": {
            "type": "object",
            "properties": {
                "attribute_filters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.AttributeFilter"
                    }
                },
                "change_filters": {
                    "$ref": "#/definitions/models.ChangeFilter"
                }
            }
        },
        "models.FindMCPNodeRequest": {
            "type": "object",
            "required": [
                "domain_name",
                "url"
            ],
            "properties": {
                "domain_name": {
                    "type": "string"
                },
                "url": {
                    "type": "string",
                    "maxLength": 2048
                }
            }
        },
        "models.FindNodeByURLRequest": {
            "type": "object",
            "required": [
                "url"
            ],
            "properties": {
                "url": {
                    "type": "string",
                    "maxLength": 2048
                }
            }
        },
        "models.MCPAttribute": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "models.MCPDomain": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "node_count": {
                    "type": "integer"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "models.MCPDomainAttribute": {
            "type": "object",
            "properties": {
                "composite_id": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "type": {
                    "$ref": "#/definitions/models.AttributeType"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "models.MCPDomainAttributeListResponse": {
            "type": "object",
            "properties": {
                "attributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.MCPDomainAttribute"
                    }
                },
                "domain_name": {
                    "type": "string"
                },
                "total_count": {
                    "type": "integer"
                }
            }
        },
        "models.MCPNode": {
            "type": "object",
            "properties": {
                "composite_id": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "domain_name": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "url": {
                    "type": "string"
                }
            }
        },
        "models.MCPNodeAttributesResponse": {
            "type": "object",
            "properties": {
                "attributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.MCPAttribute"
                    }
                },
                "composite_id": {
                    "type": "string"
                }
            }
        },
        "models.MCPNodeListResponse": {
            "type": "object",
            "properties": {
                "nodes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.MCPNode"
                    }
                },
                "page": {
                    "type": "integer"
                },
                "size": {
                    "type": "integer"
                },
                "total_count": {
                    "type": "integer"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "models.MCPServerInfo": {
            "type": "object",
            "properties": {
                "capabilities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "composite_key_format": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                }
            }
        },
        "models.Node": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "domain_id": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "models.NodeAttribute": {
            "type": "object",
            "properties": {
                "attribute_id": {
                    "type": "integer"
                },
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "node_id": {
                    "type": "integer"
                },
                "order_index": {
                    "type": "integer"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "models.NodeAttributeListResponse": {
            "type": "object",
            "properties": {
                "attributes": {
                    "description": "For backward compatibility",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.NodeAttributeWithInfo"
                    }
                },
                "node_attributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.NodeAttributeWithInfo"
                    }
                }
            }
        },
        "models.NodeAttributeWithInfo": {
            "type": "object",
            "properties": {
                "attribute_id": {
                    "type": "integer"
                },
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "node_id": {
                    "type": "integer"
                },
                "order_index": {
                    "type": "integer"
                },
                "type": {
                    "$ref": "#/definitions/models.AttributeType"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "models.NodeDependency": {
            "type": "object",
            "properties": {
                "cascade_delete": {
                    "type": "boolean"
                },
                "cascade_update": {
                    "type": "boolean"
                },
                "created_at": {
                    "type": "string"
                },
                "dependency_node_id": {
                    "type": "integer"
                },
                "dependency_type": {
                    "type": "string"
                },
                "dependent_node_id": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "metadata": {
                    "$ref": "#/definitions/models.DependencyMetadata"
                }
            }
        },
        "models.NodeEvent": {
            "type": "object",
            "properties": {
                "event_data": {
                    "$ref": "#/definitions/models.EventData"
                },
                "event_type": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "node_id": {
                    "type": "integer"
                },
                "occurred_at": {
                    "type": "string"
                },
                "processed_at": {
                    "type": "string"
                }
            }
        },
        "models.NodeListResponse": {
            "type": "object",
            "properties": {
                "nodes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Node"
                    }
                },
                "page": {
                    "type": "integer"
                },
                "size": {
                    "type": "integer"
                },
                "total_count": {
                    "type": "integer"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "models.NodeSubscription": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "event_types": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "filter_conditions": {
                    "$ref": "#/definitions/models.FilterCondition"
                },
                "id": {
                    "type": "integer"
                },
                "is_active": {
                    "type": "boolean"
                },
                "subscribed_node_id": {
                    "type": "integer"
                },
                "subscriber_endpoint": {
                    "type": "string"
                },
                "subscriber_service": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "models.SetMCPNodeAttributesRequest": {
            "type": "object",
            "required": [
                "attributes"
            ],
            "properties": {
                "attributes": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": [
                            "name",
                            "value"
                        ],
                        "properties": {
                            "name": {
                                "type": "string"
                            },
                            "order_index": {
                                "type": "integer"
                            },
                            "value": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "models.UpdateAttributeRequest": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 1000
                }
            }
        },
        "models.UpdateDomainRequest": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 1000
                }
            }
        },
        "models.UpdateMCPNodeRequest": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 1000
                },
                "title": {
                    "type": "string",
                    "maxLength": 255
                }
            }
        },
        "models.UpdateNodeAttributeRequest": {
            "type": "object",
            "required": [
                "value"
            ],
            "properties": {
                "order_index": {
                    "type": "integer"
                },
                "value": {
                    "type": "string",
                    "maxLength": 2048
                }
            }
        },
        "models.UpdateNodeRequest": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 1000
                },
                "title": {
                    "type": "string",
                    "maxLength": 255
                }
            }
        },
        "models.UpdateNodeSubscriptionRequest": {
            "type": "object",
            "properties": {
                "event_types": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "filter_conditions": {
                    "$ref": "#/definitions/models.FilterCondition"
                },
                "is_active": {
                    "type": "boolean"
                },
                "subscriber_endpoint": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BasicAuth": {
            "type": "basic"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api",
        Schemes:          []string{},
        Title:            "URL Database API",
        Description:      "A URL management system with attribute support and MCP integration.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated from mcp-tools.yaml. DO NOT EDIT.
// Generated by scripts/generate-tool-constants.py

package mcp

// MCP Tool Names - Single source of truth
const (
        // Server Information
        ServerName         = "url-db-mcp-server"
        ServerVersion      = "1.0.0"
        CompositeKeyFormat = "url-db:domain:id"

        // Tool Names

        // Domain management operations
        ListDomainsTool  = "list_domains"
        CreateDomainTool = "create_domain"

        // Node/URL CRUD operations
        ListNodesTool     = "list_nodes"
        CreateNodeTool    = "create_node"
        GetNodeTool       = "get_node"
        UpdateNodeTool    = "update_node"
        DeleteNodeTool    = "delete_node"
        FindNodeByUrlTool = "find_node_by_url"

        // Node attribute management
        GetNodeAttributesTool = "get_node_attributes"
        SetNodeAttributesTool = "set_node_attributes"

        // Domain schema management
        ListDomainAttributesTool  = "list_domain_attributes"
        CreateDomainAttributeTool = "create_domain_attribute"
        GetDomainAttributeTool    = "get_domain_attribute"
        UpdateDomainAttributeTool = "update_domain_attribute"
        DeleteDomainAttributeTool = "delete_domain_attribute"

        // Advanced query operations
        GetNodeWithAttributesTool   = "get_node_with_attributes"
        FilterNodesByAttributesTool = "filter_nodes_by_attributes"

        // Event subscription management
        CreateSubscriptionTool   = "create_subscription"
        ListSubscriptionsTool    = "list_subscriptions"
        GetNodeSubscriptionsTool = "get_node_subscriptions"
        DeleteSubscriptionTool   = "delete_subscription"

        // Node dependency management
        CreateDependencyTool     = "create_dependency"
        ListNodeDependenciesTool = "list_node_dependencies"
        ListNodeDependentsTool   = "list_node_dependents"
        DeleteDependencyTool     = "delete_dependency"

        // Event tracking and processing
        GetNodeEventsTool    = "get_node_events"
        GetPendingEventsTool = "get_pending_events"
        ProcessEventTool     = "process_event"
        GetEventStatsTool    = "get_event_stats"

        // Server metadata and information
        GetServerInfoTool = "get_server_info"
)

// GetAllToolNames returns all tool names
func GetAllToolNames() []string <span class="cov0" title="0">{
        return []string{
                ListDomainsTool,
                CreateDomainTool,
                ListNodesTool,
                CreateNodeTool,
                GetNodeTool,
                UpdateNodeTool,
                DeleteNodeTool,
                FindNodeByUrlTool,
                GetNodeAttributesTool,
                SetNodeAttributesTool,
                ListDomainAttributesTool,
                CreateDomainAttributeTool,
                GetDomainAttributeTool,
                UpdateDomainAttributeTool,
                DeleteDomainAttributeTool,
                GetNodeWithAttributesTool,
                FilterNodesByAttributesTool,
                CreateSubscriptionTool,
                ListSubscriptionsTool,
                GetNodeSubscriptionsTool,
                DeleteSubscriptionTool,
                CreateDependencyTool,
                ListNodeDependenciesTool,
                ListNodeDependentsTool,
                DeleteDependencyTool,
                GetNodeEventsTool,
                GetPendingEventsTool,
                ProcessEventTool,
                GetEventStatsTool,
                GetServerInfoTool,
        }
}</span>

// ToolCategories maps tool names to categories
var ToolCategories = map[string]string{
        ListDomainsTool:             "domain",
        CreateDomainTool:            "domain",
        ListNodesTool:               "node",
        CreateNodeTool:              "node",
        GetNodeTool:                 "node",
        UpdateNodeTool:              "node",
        DeleteNodeTool:              "node",
        FindNodeByUrlTool:           "node",
        GetNodeAttributesTool:       "attribute",
        SetNodeAttributesTool:       "attribute",
        ListDomainAttributesTool:    "schema",
        CreateDomainAttributeTool:   "schema",
        GetDomainAttributeTool:      "schema",
        UpdateDomainAttributeTool:   "schema",
        DeleteDomainAttributeTool:   "schema",
        GetNodeWithAttributesTool:   "query",
        FilterNodesByAttributesTool: "query",
        CreateSubscriptionTool:      "subscription",
        ListSubscriptionsTool:       "subscription",
        GetNodeSubscriptionsTool:    "subscription",
        DeleteSubscriptionTool:      "subscription",
        CreateDependencyTool:        "dependency",
        ListNodeDependenciesTool:    "dependency",
        ListNodeDependentsTool:      "dependency",
        DeleteDependencyTool:        "dependency",
        GetNodeEventsTool:           "event",
        GetPendingEventsTool:        "event",
        ProcessEventTool:            "event",
        GetEventStatsTool:           "event",
        GetServerInfoTool:           "meta",
}

// ToolDescriptions maps tool names to descriptions
var ToolDescriptions = map[string]string{
        ListDomainsTool:             "Get all domains",
        CreateDomainTool:            "Create new domain for organizing URLs",
        ListNodesTool:               "List URLs in domain",
        CreateNodeTool:              "Add URL to domain",
        GetNodeTool:                 "Get URL details",
        UpdateNodeTool:              "Update URL title or description",
        DeleteNodeTool:              "Remove URL",
        FindNodeByUrlTool:           "Search by exact URL",
        GetNodeAttributesTool:       "Get URL tags and attributes",
        SetNodeAttributesTool:       "Add or update URL tags",
        ListDomainAttributesTool:    "Get available tag types for domain",
        CreateDomainAttributeTool:   "Define new tag type for domain",
        GetDomainAttributeTool:      "Get tag type details",
        UpdateDomainAttributeTool:   "Update tag type description",
        DeleteDomainAttributeTool:   "Remove unused tag type",
        GetNodeWithAttributesTool:   "Get URL with all tags at once",
        FilterNodesByAttributesTool: "Search URLs by tag values",
        CreateSubscriptionTool:      "Subscribe to node events",
        ListSubscriptionsTool:       "List all subscriptions for a service",
        GetNodeSubscriptionsTool:    "Get all subscriptions for a specific node",
        DeleteSubscriptionTool:      "Cancel a subscription",
        CreateDependencyTool:        "Create dependency relationship between nodes",
        ListNodeDependenciesTool:    "Get all dependencies for a node",
        ListNodeDependentsTool:      "Get all nodes that depend on this node",
        DeleteDependencyTool:        "Remove dependency relationship",
        GetNodeEventsTool:           "Get event history for a node",
        GetPendingEventsTool:        "Get unprocessed events for processing",
        ProcessEventTool:            "Mark an event as processed",
        GetEventStatsTool:           "Get system event statistics",
        GetServerInfoTool:           "Get server info",
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package attributes

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

// AttributeHandler handles HTTP requests for attributes
type AttributeHandler struct {
        service AttributeService
}

// NewAttributeHandler creates a new attribute handler
func NewAttributeHandler(service AttributeService) *AttributeHandler <span class="cov0" title="0">{
        return &amp;AttributeHandler{service: service}
}</span>

// RegisterRoutes registers attribute routes
func (h *AttributeHandler) RegisterRoutes(router *gin.RouterGroup) <span class="cov0" title="0">{
        router.POST("/domains/:domain_id/attributes", h.CreateAttribute)
        router.GET("/domains/:domain_id/attributes", h.ListAttributes)
        router.GET("/attributes/:id", h.GetAttribute)
        router.PUT("/attributes/:id", h.UpdateAttribute)
        router.DELETE("/attributes/:id", h.DeleteAttribute)
}</span>

// CreateAttribute godoc
// @Summary      Create a new attribute
// @Description  Create a new attribute for a domain
// @Tags         attributes
// @Accept       json
// @Produce      json
// @Param        domain_id  path      int                           true  "Domain ID"
// @Param        attribute  body      models.CreateAttributeRequest true  "Attribute data"
// @Success      201        {object}  models.Attribute
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      409        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /domains/{domain_id}/attributes [post]
func (h *AttributeHandler) CreateAttribute(c *gin.Context) <span class="cov0" title="0">{
        domainIDStr := c.Param("domain_id")
        domainID, err := strconv.Atoi(domainIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateAttributeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.service.CreateAttribute(c.Request.Context(), domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, attribute)</span>
}

// GetAttribute godoc
// @Summary      Get an attribute
// @Description  Get attribute by ID
// @Tags         attributes
// @Produce      json
// @Param        id  path      int  true  "Attribute ID"
// @Success      200 {object}  models.Attribute
// @Failure      400 {object}  map[string]interface{}
// @Failure      404 {object}  map[string]interface{}
// @Failure      500 {object}  map[string]interface{}
// @Router       /attributes/{id} [get]
func (h *AttributeHandler) GetAttribute(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid attribute ID",
                })
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.service.GetAttribute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

// ListAttributes godoc
// @Summary      List attributes
// @Description  Get all attributes for a domain
// @Tags         attributes
// @Produce      json
// @Param        domain_id  path      int  true  "Domain ID"
// @Success      200        {object}  models.AttributeListResponse
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /domains/{domain_id}/attributes [get]
func (h *AttributeHandler) ListAttributes(c *gin.Context) <span class="cov0" title="0">{
        domainIDStr := c.Param("domain_id")
        domainID, err := strconv.Atoi(domainIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">response, err := h.service.ListAttributes(c.Request.Context(), domainID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// UpdateAttribute godoc
// @Summary      Update an attribute
// @Description  Update attribute description by ID
// @Tags         attributes
// @Accept       json
// @Produce      json
// @Param        id         path      int                           true  "Attribute ID"
// @Param        attribute  body      models.UpdateAttributeRequest true  "Updated attribute data"
// @Success      200        {object}  models.Attribute
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /attributes/{id} [put]
func (h *AttributeHandler) UpdateAttribute(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid attribute ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateAttributeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.service.UpdateAttribute(c.Request.Context(), id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

// DeleteAttribute godoc
// @Summary      Delete an attribute
// @Description  Delete attribute by ID (only if no associated values exist)
// @Tags         attributes
// @Param        id  path  int  true  "Attribute ID"
// @Success      204
// @Failure      400  {object}  map[string]interface{}
// @Failure      404  {object}  map[string]interface{}
// @Failure      409  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /attributes/{id} [delete]
func (h *AttributeHandler) DeleteAttribute(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid attribute ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.service.DeleteAttribute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// handleError handles service errors and converts them to appropriate HTTP responses
func (h *AttributeHandler) handleError(c *gin.Context, err error) <span class="cov0" title="0">{
        switch err </span>{
        case ErrAttributeNotFound:<span class="cov0" title="0">
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "Attribute not found",
                })</span>
        case ErrAttributeAlreadyExists:<span class="cov0" title="0">
                c.JSON(http.StatusConflict, gin.H{
                        "error":   "conflict",
                        "message": "Attribute already exists",
                })</span>
        case ErrAttributeTypeInvalid:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid attribute type",
                })</span>
        case ErrAttributeHasValues:<span class="cov0" title="0">
                c.JSON(http.StatusConflict, gin.H{
                        "error":   "conflict",
                        "message": "Cannot delete attribute with existing values",
                })</span>
        case ErrDomainNotFound:<span class="cov0" title="0">
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "Domain not found",
                })</span>
        case ErrAttributeNameRequired:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Attribute name is required",
                })</span>
        case ErrAttributeNameTooLong:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Attribute name too long",
                })</span>
        case ErrAttributeTypeRequired:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Attribute type is required",
                })</span>
        case ErrDescriptionTooLong:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Description too long",
                })</span>
        default:<span class="cov0" title="0">
                if strings.Contains(err.Error(), "validation error") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "validation_error",
                                "message": err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error":   "internal_error",
                                "message": "Internal server error",
                        })
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package attributes

import (
        "context"
        "database/sql"
        "fmt"

        "url-db/internal/models"
)

// AttributeRepository defines the interface for attribute data access
type AttributeRepository interface {
        Create(ctx context.Context, attribute *models.Attribute) error
        GetByID(ctx context.Context, id int) (*models.Attribute, error)
        GetByDomainID(ctx context.Context, domainID int) ([]*models.Attribute, error)
        GetByDomainIDAndName(ctx context.Context, domainID int, name string) (*models.Attribute, error)
        Update(ctx context.Context, attribute *models.Attribute) error
        Delete(ctx context.Context, id int) error
        HasValues(ctx context.Context, attributeID int) (bool, error)
}

// SQLiteAttributeRepository implements AttributeRepository for SQLite
type SQLiteAttributeRepository struct {
        db *sql.DB
}

// NewSQLiteAttributeRepository creates a new SQLite attribute repository
func NewSQLiteAttributeRepository(db *sql.DB) *SQLiteAttributeRepository <span class="cov8" title="1">{
        return &amp;SQLiteAttributeRepository{db: db}
}</span>

// Create creates a new attribute
func (r *SQLiteAttributeRepository) Create(ctx context.Context, attribute *models.Attribute) error <span class="cov8" title="1">{
        query := `
                INSERT INTO attributes (domain_id, name, type, description, created_at)
                VALUES (?, ?, ?, ?, ?)
        `

        result, err := r.db.ExecContext(ctx, query,
                attribute.DomainID,
                attribute.Name,
                attribute.Type,
                attribute.Description,
                attribute.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create attribute: %w", err)
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov8" title="1">attribute.ID = int(id)
        return nil</span>
}

// GetByID retrieves an attribute by ID
func (r *SQLiteAttributeRepository) GetByID(ctx context.Context, id int) (*models.Attribute, error) <span class="cov8" title="1">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE id = ?
        `

        attribute := &amp;models.Attribute{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;attribute.ID,
                &amp;attribute.DomainID,
                &amp;attribute.Name,
                &amp;attribute.Type,
                &amp;attribute.Description,
                &amp;attribute.CreatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrAttributeNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get attribute by id: %w", err)</span>
        }

        <span class="cov8" title="1">return attribute, nil</span>
}

// GetByDomainID retrieves all attributes for a domain
func (r *SQLiteAttributeRepository) GetByDomainID(ctx context.Context, domainID int) ([]*models.Attribute, error) <span class="cov8" title="1">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE domain_id = ?
                ORDER BY name
        `

        rows, err := r.db.QueryContext(ctx, query, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get attributes by domain id: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var attributes []*models.Attribute
        for rows.Next() </span><span class="cov8" title="1">{
                attribute := &amp;models.Attribute{}
                err := rows.Scan(
                        &amp;attribute.ID,
                        &amp;attribute.DomainID,
                        &amp;attribute.Name,
                        &amp;attribute.Type,
                        &amp;attribute.Description,
                        &amp;attribute.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan attribute: %w", err)
                }</span>
                <span class="cov8" title="1">attributes = append(attributes, attribute)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating over attributes: %w", err)
        }</span>

        <span class="cov8" title="1">return attributes, nil</span>
}

// GetByDomainIDAndName retrieves an attribute by domain ID and name
func (r *SQLiteAttributeRepository) GetByDomainIDAndName(ctx context.Context, domainID int, name string) (*models.Attribute, error) <span class="cov8" title="1">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE domain_id = ? AND name = ?
        `

        attribute := &amp;models.Attribute{}
        err := r.db.QueryRowContext(ctx, query, domainID, name).Scan(
                &amp;attribute.ID,
                &amp;attribute.DomainID,
                &amp;attribute.Name,
                &amp;attribute.Type,
                &amp;attribute.Description,
                &amp;attribute.CreatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrAttributeNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get attribute by domain id and name: %w", err)</span>
        }

        <span class="cov8" title="1">return attribute, nil</span>
}

// Update updates an attribute
func (r *SQLiteAttributeRepository) Update(ctx context.Context, attribute *models.Attribute) error <span class="cov8" title="1">{
        query := `
                UPDATE attributes
                SET description = ?
                WHERE id = ?
        `

        result, err := r.db.ExecContext(ctx, query, attribute.Description, attribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update attribute: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete deletes an attribute
func (r *SQLiteAttributeRepository) Delete(ctx context.Context, id int) error <span class="cov8" title="1">{
        query := `DELETE FROM attributes WHERE id = ?`

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete attribute: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// HasValues checks if an attribute has any values
func (r *SQLiteAttributeRepository) HasValues(ctx context.Context, attributeID int) (bool, error) <span class="cov8" title="1">{
        query := `SELECT COUNT(*) FROM node_attributes WHERE attribute_id = ?`

        var count int
        err := r.db.QueryRowContext(ctx, query, attributeID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check if attribute has values: %w", err)
        }</span>

        <span class="cov8" title="1">return count &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package attributes

import (
        "context"
        "fmt"
        "time"

        "url-db/internal/models"
)

// AttributeService defines the interface for attribute business logic
type AttributeService interface {
        CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error)
        GetAttribute(ctx context.Context, id int) (*models.Attribute, error)
        ListAttributes(ctx context.Context, domainID int) (*models.AttributeListResponse, error)
        UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error)
        DeleteAttribute(ctx context.Context, id int) error
}

// DomainService interface for domain validation
type DomainService interface {
        GetDomain(ctx context.Context, id int) (*models.Domain, error)
}

// attributeService implements AttributeService
type attributeService struct {
        repo          AttributeRepository
        domainService DomainService
}

// NewAttributeService creates a new attribute service
func NewAttributeService(repo AttributeRepository, domainService DomainService) AttributeService <span class="cov8" title="1">{
        return &amp;attributeService{
                repo:          repo,
                domainService: domainService,
        }
}</span>

// validateAttributeName validates attribute name
func (s *attributeService) validateAttributeName(name string) error <span class="cov8" title="1">{
        if len(name) == 0 </span><span class="cov8" title="1">{
                return ErrAttributeNameRequired
        }</span>
        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov8" title="1">{
                return ErrAttributeNameTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateAttributeType validates attribute type
func (s *attributeService) validateAttributeType(attrType AttributeType) error <span class="cov8" title="1">{
        if attrType == "" </span><span class="cov8" title="1">{
                return ErrAttributeTypeRequired
        }</span>
        <span class="cov8" title="1">if !IsValidAttributeType(attrType) </span><span class="cov8" title="1">{
                return ErrAttributeTypeInvalid
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateDescription validates description
func (s *attributeService) validateDescription(description string) error <span class="cov8" title="1">{
        if len(description) &gt; 1000 </span><span class="cov8" title="1">{
                return ErrDescriptionTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CreateAttribute creates a new attribute
func (s *attributeService) CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error) <span class="cov8" title="1">{
        // Validate input
        if err := s.validateAttributeName(req.Name); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.validateAttributeType(req.Type); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.validateDescription(req.Description); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        // Check if domain exists
        <span class="cov8" title="1">_, err := s.domainService.GetDomain(ctx, domainID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ErrDomainNotFound
        }</span>

        // Check if attribute name already exists in domain
        <span class="cov8" title="1">existing, err := s.repo.GetByDomainIDAndName(ctx, domainID, req.Name)
        if err != nil &amp;&amp; err != ErrAttributeNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check attribute existence: %w", err)
        }</span>
        <span class="cov8" title="1">if existing != nil </span><span class="cov8" title="1">{
                return nil, ErrAttributeAlreadyExists
        }</span>

        // Create attribute
        <span class="cov8" title="1">attribute := &amp;models.Attribute{
                DomainID:    domainID,
                Name:        req.Name,
                Type:        req.Type,
                Description: req.Description,
                CreatedAt:   time.Now(),
        }

        err = s.repo.Create(ctx, attribute)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create attribute: %w", err)
        }</span>

        <span class="cov8" title="1">return attribute, nil</span>
}

// GetAttribute retrieves an attribute by ID
func (s *attributeService) GetAttribute(ctx context.Context, id int) (*models.Attribute, error) <span class="cov8" title="1">{
        attribute, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return attribute, nil</span>
}

// ListAttributes lists all attributes for a domain
func (s *attributeService) ListAttributes(ctx context.Context, domainID int) (*models.AttributeListResponse, error) <span class="cov8" title="1">{
        // Check if domain exists
        _, err := s.domainService.GetDomain(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">attributes, err := s.repo.GetByDomainID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list attributes: %w", err)
        }</span>

        // Convert to response format
        <span class="cov8" title="1">attributeList := make([]models.Attribute, len(attributes))
        for i, attr := range attributes </span><span class="cov8" title="1">{
                attributeList[i] = *attr
        }</span>

        <span class="cov8" title="1">return &amp;models.AttributeListResponse{
                Attributes: attributeList,
        }, nil</span>
}

// UpdateAttribute updates an attribute
func (s *attributeService) UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error) <span class="cov8" title="1">{
        // Validate input
        if err := s.validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        // Get existing attribute
        <span class="cov8" title="1">attribute, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update only description (name and type are immutable)
        <span class="cov8" title="1">attribute.Description = req.Description

        err = s.repo.Update(ctx, attribute)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update attribute: %w", err)
        }</span>

        <span class="cov8" title="1">return attribute, nil</span>
}

// DeleteAttribute deletes an attribute
func (s *attributeService) DeleteAttribute(ctx context.Context, id int) error <span class="cov8" title="1">{
        // Check if attribute exists
        _, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if attribute has values
        <span class="cov8" title="1">hasValues, err := s.repo.HasValues(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check attribute values: %w", err)
        }</span>
        <span class="cov8" title="1">if hasValues </span><span class="cov8" title="1">{
                return ErrAttributeHasValues
        }</span>

        // Delete attribute
        <span class="cov8" title="1">err = s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete attribute: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package attributes

import "url-db/internal/models"

// AttributeType aliases for internal use
type AttributeType = models.AttributeType

const (
        AttributeTypeTag        = models.AttributeTypeTag
        AttributeTypeOrderedTag = models.AttributeTypeOrderedTag
        AttributeTypeNumber     = models.AttributeTypeNumber
        AttributeTypeString     = models.AttributeTypeString
        AttributeTypeMarkdown   = models.AttributeTypeMarkdown
        AttributeTypeImage      = models.AttributeTypeImage
)

// IsValidAttributeType checks if the given attribute type is valid
func IsValidAttributeType(t AttributeType) bool <span class="cov8" title="1">{
        switch t </span>{
        case AttributeTypeTag, AttributeTypeOrderedTag, AttributeTypeNumber,
                AttributeTypeString, AttributeTypeMarkdown, AttributeTypeImage:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// GetSupportedAttributeTypes returns a list of all supported attribute types
func GetSupportedAttributeTypes() []AttributeType <span class="cov0" title="0">{
        return []AttributeType{
                AttributeTypeTag,
                AttributeTypeOrderedTag,
                AttributeTypeNumber,
                AttributeTypeString,
                AttributeTypeMarkdown,
                AttributeTypeImage,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package attributes

import (
        "fmt"
        "net/url"
        "regexp"
        "strconv"
        "strings"
)

// AttributeValueValidator validates attribute values based on their type
type AttributeValueValidator interface {
        Validate(value string, orderIndex *int) error
}

// TagValidator validates tag attribute values
type TagValidator struct{}

func (v *TagValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 255 </span><span class="cov8" title="1">{
                return ErrValueTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// OrderedTagValidator validates ordered tag attribute values
type OrderedTagValidator struct{}

func (v *OrderedTagValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 255 </span><span class="cov8" title="1">{
                return ErrValueTooLong
        }</span>
        <span class="cov8" title="1">if orderIndex == nil </span><span class="cov8" title="1">{
                return ErrOrderIndexRequired
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NumberValidator validates number attribute values
type NumberValidator struct{}

func (v *NumberValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>

        // Try to parse as float64 to validate it's a number
        <span class="cov8" title="1">_, err := strconv.ParseFloat(value, 64)
        if err != nil </span><span class="cov8" title="1">{
                return ErrInvalidNumber
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// StringValidator validates string attribute values
type StringValidator struct{}

func (v *StringValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 2048 </span><span class="cov8" title="1">{
                return ErrValueTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// MarkdownValidator validates markdown attribute values
type MarkdownValidator struct{}

var (
        // Basic markdown patterns - we'll do simple validation
        markdownHeaderPattern = regexp.MustCompile(`^#{1,6}\s+.+$`)
        markdownLinkPattern   = regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)
        markdownCodePattern   = regexp.MustCompile("```[\\s\\S]*?```|`[^`]+`")
        markdownBoldPattern   = regexp.MustCompile(`\*\*[^*]+\*\*|__[^_]+__`)
        markdownItalicPattern = regexp.MustCompile(`\*[^*]+\*|_[^_]+_`)
)

func (v *MarkdownValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 10000 </span><span class="cov8" title="1">{ // Larger limit for markdown
                return ErrValueTooLong
        }</span>

        // Basic markdown syntax validation
        <span class="cov8" title="1">lines := strings.Split(value, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for malformed markdown links
                <span class="cov8" title="1">if strings.Contains(line, "](") </span><span class="cov8" title="1">{
                        matches := markdownLinkPattern.FindAllString(line, -1)
                        for _, match := range matches </span><span class="cov8" title="1">{
                                if !isValidMarkdownLink(match) </span><span class="cov0" title="0">{
                                        return ErrInvalidMarkdown
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func isValidMarkdownLink(link string) bool <span class="cov8" title="1">{
        // Extract URL from markdown link pattern [text](url)
        re := regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)
        matches := re.FindStringSubmatch(link)
        if len(matches) &lt; 3 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">urlStr := matches[2]

        // Allow relative URLs and anchors
        if strings.HasPrefix(urlStr, "#") || strings.HasPrefix(urlStr, "/") || strings.HasPrefix(urlStr, "./") || strings.HasPrefix(urlStr, "../") </span><span class="cov8" title="1">{
                return true
        }</span>

        // Validate absolute URLs
        <span class="cov8" title="1">_, err := url.Parse(urlStr)
        return err == nil</span>
}

// ImageValidator validates image URL attribute values
type ImageValidator struct{}

var (
        // Common image extensions
        imageExtensions = []string{".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".svg", ".ico"}
)

func (v *ImageValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 2048 </span><span class="cov8" title="1">{
                return ErrValueTooLong
        }</span>

        // Parse URL
        <span class="cov8" title="1">parsedURL, err := url.Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                return ErrInvalidURL
        }</span>

        // Must be absolute URL for images
        <span class="cov8" title="1">if !parsedURL.IsAbs() </span><span class="cov8" title="1">{
                return ErrInvalidURL
        }</span>

        // Check scheme
        <span class="cov8" title="1">if parsedURL.Scheme != "http" &amp;&amp; parsedURL.Scheme != "https" </span><span class="cov8" title="1">{
                return ErrInvalidURL
        }</span>

        // Check if it looks like an image (has image extension or is from known image hosting)
        <span class="cov8" title="1">if !isValidImageURL(parsedURL) </span><span class="cov0" title="0">{
                return ErrInvalidURL
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func isValidImageURL(parsedURL *url.URL) bool <span class="cov8" title="1">{
        path := strings.ToLower(parsedURL.Path)

        // Check file extension
        for _, ext := range imageExtensions </span><span class="cov8" title="1">{
                if strings.HasSuffix(path, ext) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Check for known image hosting services
        <span class="cov8" title="1">host := strings.ToLower(parsedURL.Host)
        imageHosts := []string{
                "imgur.com", "i.imgur.com",
                "images.unsplash.com", "unsplash.com",
                "pixabay.com", "images.pexels.com",
                "cdn.pixabay.com", "images.pixabay.com",
                "gravatar.com", "s.gravatar.com",
                "githubusercontent.com",
                "googleusercontent.com",
                "cloudinary.com",
                "amazonaws.com", // S3 buckets
                "cloudfront.net",
        }

        for _, imageHost := range imageHosts </span><span class="cov8" title="1">{
                if strings.Contains(host, imageHost) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ValidatorFactory creates validators for different attribute types
type ValidatorFactory struct{}

func NewValidatorFactory() *ValidatorFactory <span class="cov8" title="1">{
        return &amp;ValidatorFactory{}
}</span>

func (f *ValidatorFactory) GetValidator(attrType AttributeType) (AttributeValueValidator, error) <span class="cov8" title="1">{
        switch attrType </span>{
        case AttributeTypeTag:<span class="cov8" title="1">
                return &amp;TagValidator{}, nil</span>
        case AttributeTypeOrderedTag:<span class="cov8" title="1">
                return &amp;OrderedTagValidator{}, nil</span>
        case AttributeTypeNumber:<span class="cov8" title="1">
                return &amp;NumberValidator{}, nil</span>
        case AttributeTypeString:<span class="cov8" title="1">
                return &amp;StringValidator{}, nil</span>
        case AttributeTypeMarkdown:<span class="cov8" title="1">
                return &amp;MarkdownValidator{}, nil</span>
        case AttributeTypeImage:<span class="cov8" title="1">
                return &amp;ImageValidator{}, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported attribute type: %s", attrType)</span>
        }
}

// ValidateAttributeValue validates a value against the given attribute type
func ValidateAttributeValue(attrType AttributeType, value string, orderIndex *int) error <span class="cov8" title="1">{
        factory := NewValidatorFactory()
        validator, err := factory.GetValidator(attrType)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return validator.Validate(value, orderIndex)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package compositekey

import (
        "strconv"
        "strings"
)

// CompositeKey 는 합성키 구조를 나타냅니다.
type CompositeKey struct {
        ToolName   string `json:"tool_name"`
        DomainName string `json:"domain_name"`
        ID         int    `json:"id"`
}

// String 은 CompositeKey를 문자열로 변환합니다.
func (ck CompositeKey) String() string <span class="cov8" title="1">{
        return strings.Join([]string{ck.ToolName, ck.DomainName, strconv.Itoa(ck.ID)}, ":")
}</span>

// Create 는 주어진 구성 요소로 합성키를 생성합니다.
func Create(toolName, domainName string, id int) CompositeKey <span class="cov8" title="1">{
        return CompositeKey{
                ToolName:   toolName,
                DomainName: domainName,
                ID:         id,
        }
}</span>

// Parse 는 합성키 문자열을 파싱하여 CompositeKey 구조체로 변환합니다.
func Parse(compositeKey string) (CompositeKey, error) <span class="cov8" title="1">{
        parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return CompositeKey{}, NewInvalidFormatError("합성키는 정확히 3개의 구성 요소를 가져야 합니다")
        }</span>

        <span class="cov8" title="1">toolName := parts[0]
        domainName := parts[1]
        idStr := parts[2]

        // ID를 정수로 변환
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov8" title="1">{
                return CompositeKey{}, NewInvalidIDError("ID는 유효한 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov8" title="1">{
                return CompositeKey{}, NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return CompositeKey{
                ToolName:   toolName,
                DomainName: domainName,
                ID:         id,
        }, nil</span>
}

// IsValid 는 합성키의 유효성을 검사합니다.
func IsValid(compositeKey string) bool <span class="cov8" title="1">{
        _, err := Parse(compositeKey)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package compositekey

import "fmt"

// 에러 코드 정의
const (
        ErrInvalidFormat     = "COMPOSITE_KEY_INVALID_FORMAT"
        ErrInvalidToolName   = "COMPOSITE_KEY_INVALID_TOOL_NAME"
        ErrInvalidDomainName = "COMPOSITE_KEY_INVALID_DOMAIN_NAME"
        ErrInvalidID         = "COMPOSITE_KEY_INVALID_ID"
        ErrTooLong           = "COMPOSITE_KEY_TOO_LONG"
)

// CompositeKeyError 는 합성키 관련 에러를 나타냅니다.
type CompositeKeyError struct {
        Code    string
        Message string
}

func (e CompositeKeyError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s: %s", e.Code, e.Message)
}</span>

// 에러 생성 함수들
func NewInvalidFormatError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrInvalidFormat,
                Message: message,
        }
}</span>

func NewInvalidToolNameError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrInvalidToolName,
                Message: message,
        }
}</span>

func NewInvalidDomainNameError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrInvalidDomainName,
                Message: message,
        }
}</span>

func NewInvalidIDError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrInvalidID,
                Message: message,
        }
}</span>

func NewTooLongError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrTooLong,
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package compositekey

import (
        "regexp"
        "strings"
)

// 정규화 규칙에 따른 상수들
const (
        MaxToolNameLength   = 50
        MaxDomainNameLength = 50
        MaxIDLength         = 20
)

// 특수문자를 하이픈으로 변환하는 정규표현식
var (
        // 영문자, 숫자, 하이픈, 언더스코어가 아닌 문자를 매칭
        invalidCharsRegex = regexp.MustCompile(`[^a-zA-Z0-9\-_]`)
        // 연속된 하이픈이나 언더스코어를 매칭
        multipleDelimiterRegex = regexp.MustCompile(`[-_]+`)
)

// NormalizeToolName 은 도구명을 정규화합니다.
func NormalizeToolName(toolName string) (string, error) <span class="cov8" title="1">{
        normalized := normalizeString(toolName)

        if len(normalized) == 0 </span><span class="cov8" title="1">{
                return "", NewInvalidToolNameError("도구명이 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(normalized) &gt; MaxToolNameLength </span><span class="cov8" title="1">{
                return "", NewTooLongError("도구명이 너무 깁니다")
        }</span>

        <span class="cov8" title="1">return normalized, nil</span>
}

// NormalizeDomainName 은 도메인명을 정규화합니다.
func NormalizeDomainName(domainName string) (string, error) <span class="cov8" title="1">{
        normalized := normalizeString(domainName)

        if len(normalized) == 0 </span><span class="cov8" title="1">{
                return "", NewInvalidDomainNameError("도메인명이 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(normalized) &gt; MaxDomainNameLength </span><span class="cov8" title="1">{
                return "", NewTooLongError("도메인명이 너무 깁니다")
        }</span>

        <span class="cov8" title="1">return normalized, nil</span>
}

// normalizeString 은 문자열을 정규화합니다.
func normalizeString(input string) string <span class="cov8" title="1">{
        if input == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // 1. 앞뒤 공백 제거
        <span class="cov8" title="1">normalized := strings.TrimSpace(input)

        // 2. 소문자로 변환
        normalized = strings.ToLower(normalized)

        // 3. 특수문자를 하이픈으로 변환
        normalized = invalidCharsRegex.ReplaceAllString(normalized, "-")

        // 4. 연속된 구분자를 단일 하이픈으로 변환
        normalized = multipleDelimiterRegex.ReplaceAllString(normalized, "-")

        // 5. 앞뒤 하이픈 제거
        normalized = strings.Trim(normalized, "-")

        return normalized</span>
}

// CreateNormalized 는 정규화된 구성 요소로 합성키를 생성합니다.
func CreateNormalized(toolName, domainName string, id int) (CompositeKey, error) <span class="cov8" title="1">{
        normalizedToolName, err := NormalizeToolName(toolName)
        if err != nil </span><span class="cov8" title="1">{
                return CompositeKey{}, err
        }</span>

        <span class="cov8" title="1">normalizedDomainName, err := NormalizeDomainName(domainName)
        if err != nil </span><span class="cov8" title="1">{
                return CompositeKey{}, err
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov8" title="1">{
                return CompositeKey{}, NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return CompositeKey{
                ToolName:   normalizedToolName,
                DomainName: normalizedDomainName,
                ID:         id,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package compositekey

import "strings"

// Service 는 합성키 서비스를 나타냅니다.
type Service struct {
        defaultToolName string
}

// NewService 는 새로운 합성키 서비스를 생성합니다.
func NewService(defaultToolName string) *Service <span class="cov8" title="1">{
        return &amp;Service{
                defaultToolName: defaultToolName,
        }
}</span>

// Create 는 주어진 구성 요소로 합성키를 생성합니다.
func (s *Service) Create(domainName string, id int) (string, error) <span class="cov8" title="1">{
        compositeKey, err := CreateNormalized(s.defaultToolName, domainName, id)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return compositeKey.String(), nil</span>
}

// CreateWithTool 은 도구명을 포함하여 합성키를 생성합니다.
func (s *Service) CreateWithTool(toolName, domainName string, id int) (string, error) <span class="cov8" title="1">{
        compositeKey, err := CreateNormalized(toolName, domainName, id)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return compositeKey.String(), nil</span>
}

// Parse 는 합성키 문자열을 파싱하여 CompositeKey 구조체로 변환합니다.
func (s *Service) Parse(compositeKey string) (CompositeKey, error) <span class="cov8" title="1">{
        // 먼저 검증
        if err := ValidateCompositeKey(compositeKey); err != nil </span><span class="cov8" title="1">{
                return CompositeKey{}, err
        }</span>

        // 파싱
        <span class="cov8" title="1">return Parse(compositeKey)</span>
}

// Validate 는 합성키의 유효성을 검증합니다.
func (s *Service) Validate(compositeKey string) bool <span class="cov8" title="1">{
        return ValidateCompositeKey(compositeKey) == nil
}</span>

// ParseComponents 는 합성키를 구성 요소로 분해하여 반환합니다.
func (s *Service) ParseComponents(compositeKey string) (toolName, domainName string, id int, err error) <span class="cov8" title="1">{
        ck, err := s.Parse(compositeKey)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", 0, err
        }</span>

        <span class="cov8" title="1">return ck.ToolName, ck.DomainName, ck.ID, nil</span>
}

// GetToolName 은 합성키에서 도구명을 추출합니다.
func (s *Service) GetToolName(compositeKey string) (string, error) <span class="cov8" title="1">{
        parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return "", NewInvalidFormatError("합성키 형식이 올바르지 않습니다")
        }</span>

        <span class="cov8" title="1">return parts[0], nil</span>
}

// GetDomainName 은 합성키에서 도메인명을 추출합니다.
func (s *Service) GetDomainName(compositeKey string) (string, error) <span class="cov8" title="1">{
        parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return "", NewInvalidFormatError("합성키 형식이 올바르지 않습니다")
        }</span>

        <span class="cov8" title="1">return parts[1], nil</span>
}

// GetID 는 합성키에서 ID를 추출합니다.
func (s *Service) GetID(compositeKey string) (int, error) <span class="cov8" title="1">{
        ck, err := s.Parse(compositeKey)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return ck.ID, nil</span>
}

// IsValidFormat 은 합성키의 기본 형식만 검증합니다.
func (s *Service) IsValidFormat(compositeKey string) bool <span class="cov8" title="1">{
        return ValidateFormat(compositeKey) == nil
}</span>

// NormalizeComponents 는 구성 요소를 정규화합니다.
func (s *Service) NormalizeComponents(toolName, domainName string) (string, string, error) <span class="cov8" title="1">{
        normalizedToolName, err := NormalizeToolName(toolName)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">normalizedDomainName, err := NormalizeDomainName(domainName)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return normalizedToolName, normalizedDomainName, nil</span>
}

// ValidateComponents 는 구성 요소들을 개별적으로 검증합니다.
func (s *Service) ValidateComponents(toolName, domainName string, id int) error <span class="cov8" title="1">{
        if err := ValidateToolName(toolName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := ValidateDomainName(domainName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package compositekey

import (
        "regexp"
        "strconv"
        "strings"
)

// 검증에 사용되는 정규표현식
var (
        // 유효한 문자 (영문자, 숫자, 하이픈, 언더스코어)
        validCharsRegex = regexp.MustCompile(`^[a-zA-Z0-9\-_]+$`)
)

// ValidateFormat 은 합성키의 기본 형식을 검증합니다.
func ValidateFormat(compositeKey string) error <span class="cov8" title="1">{
        if compositeKey == "" </span><span class="cov8" title="1">{
                return NewInvalidFormatError("합성키가 비어있습니다")
        }</span>

        <span class="cov8" title="1">parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return NewInvalidFormatError("합성키는 정확히 3개의 구성 요소를 가져야 합니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateToolName 은 도구명을 검증합니다.
func ValidateToolName(toolName string) error <span class="cov8" title="1">{
        if toolName == "" </span><span class="cov8" title="1">{
                return NewInvalidToolNameError("도구명이 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(toolName) &gt; MaxToolNameLength </span><span class="cov8" title="1">{
                return NewTooLongError("도구명이 너무 깁니다")
        }</span>

        <span class="cov8" title="1">if !validCharsRegex.MatchString(toolName) </span><span class="cov8" title="1">{
                return NewInvalidToolNameError("도구명에 유효하지 않은 문자가 포함되어 있습니다")
        }</span>

        // 하이픈으로 시작하거나 끝나면 안됨
        <span class="cov8" title="1">if strings.HasPrefix(toolName, "-") || strings.HasSuffix(toolName, "-") </span><span class="cov8" title="1">{
                return NewInvalidToolNameError("도구명은 하이픈으로 시작하거나 끝날 수 없습니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateDomainName 은 도메인명을 검증합니다.
func ValidateDomainName(domainName string) error <span class="cov8" title="1">{
        if domainName == "" </span><span class="cov8" title="1">{
                return NewInvalidDomainNameError("도메인명이 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(domainName) &gt; MaxDomainNameLength </span><span class="cov8" title="1">{
                return NewTooLongError("도메인명이 너무 깁니다")
        }</span>

        <span class="cov8" title="1">if !validCharsRegex.MatchString(domainName) </span><span class="cov8" title="1">{
                return NewInvalidDomainNameError("도메인명에 유효하지 않은 문자가 포함되어 있습니다")
        }</span>

        // 하이픈으로 시작하거나 끝나면 안됨
        <span class="cov8" title="1">if strings.HasPrefix(domainName, "-") || strings.HasSuffix(domainName, "-") </span><span class="cov8" title="1">{
                return NewInvalidDomainNameError("도메인명은 하이픈으로 시작하거나 끝날 수 없습니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateID 는 ID를 검증합니다.
func ValidateID(idStr string) error <span class="cov8" title="1">{
        if idStr == "" </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID가 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(idStr) &gt; MaxIDLength </span><span class="cov8" title="1">{
                return NewTooLongError("ID가 너무 깁니다")
        }</span>

        <span class="cov8" title="1">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID는 유효한 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateCompositeKey 는 합성키 전체를 검증합니다.
func ValidateCompositeKey(compositeKey string) error <span class="cov8" title="1">{
        // 1. 기본 형식 검증
        if err := ValidateFormat(compositeKey); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 2. 구성 요소 분해
        <span class="cov8" title="1">parts := strings.Split(compositeKey, ":")
        toolName := parts[0]
        domainName := parts[1]
        idStr := parts[2]

        // 3. 각 구성 요소 검증
        if err := ValidateToolName(toolName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := ValidateDomainName(domainName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := ValidateID(idStr); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateCompositeKeyStruct 는 CompositeKey 구조체를 검증합니다.
func ValidateCompositeKeyStruct(ck CompositeKey) error <span class="cov8" title="1">{
        if err := ValidateToolName(ck.ToolName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := ValidateDomainName(ck.DomainName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if ck.ID &lt;= 0 </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "os"
        "strconv"
        "url-db/internal/constants"
)

type Config struct {
        Port        string
        DatabaseURL string
        ToolName    string
}

func Load() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Port:        getEnv("PORT", strconv.Itoa(constants.DefaultPort)),
                DatabaseURL: getEnv("DATABASE_URL", "file:./"+constants.DefaultDBPath),
                ToolName:    getEnv("TOOL_NAME", constants.DefaultServerName),
        }
}</span>

func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "time"
)

// NodeDependency represents a dependency relationship between nodes
type NodeDependency struct {
        ID               int64               `db:"id" json:"id"`
        DependentNodeID  int64               `db:"dependent_node_id" json:"dependent_node_id"`
        DependencyNodeID int64               `db:"dependency_node_id" json:"dependency_node_id"`
        DependencyType   string              `db:"dependency_type" json:"dependency_type"`
        CascadeDelete    bool                `db:"cascade_delete" json:"cascade_delete"`
        CascadeUpdate    bool                `db:"cascade_update" json:"cascade_update"`
        Metadata         *DependencyMetadata `db:"metadata" json:"metadata,omitempty"`
        CreatedAt        time.Time           `db:"created_at" json:"created_at"`
}

// NodeDependencyV2 represents an enhanced dependency relationship with advanced features
type NodeDependencyV2 struct {
        ID                int64                 `db:"id" json:"id"`
        DependentNodeID   int64                 `db:"dependent_node_id" json:"dependent_node_id"`
        DependencyNodeID  int64                 `db:"dependency_node_id" json:"dependency_node_id"`
        DependencyType    string                `db:"dependency_type" json:"dependency_type"`
        Category          string                `db:"category" json:"category"`
        Strength          int                   `db:"strength" json:"strength"` // 0-100
        Priority          int                   `db:"priority" json:"priority"` // 0-100
        CascadeDelete     bool                  `db:"cascade_delete" json:"cascade_delete"`
        CascadeUpdate     bool                  `db:"cascade_update" json:"cascade_update"`
        Metadata          *DependencyMetadataV2 `db:"metadata" json:"metadata,omitempty"`
        VersionConstraint *string               `db:"version_constraint" json:"version_constraint,omitempty"`
        IsRequired        bool                  `db:"is_required" json:"is_required"`
        IsActive          bool                  `db:"is_active" json:"is_active"`
        ValidFrom         time.Time             `db:"valid_from" json:"valid_from"`
        ValidUntil        *time.Time            `db:"valid_until" json:"valid_until,omitempty"`
        CreatedAt         time.Time             `db:"created_at" json:"created_at"`
        UpdatedAt         time.Time             `db:"updated_at" json:"updated_at"`
        CreatedBy         *string               `db:"created_by" json:"created_by,omitempty"`
}

// DependencyMetadata represents additional metadata for a dependency
type DependencyMetadata struct {
        Relationship string `json:"relationship,omitempty"`
        Description  string `json:"description,omitempty"`
}

// DependencyMetadataV2 represents enhanced metadata with type-specific fields
type DependencyMetadataV2 struct {
        Relationship       string                 `json:"relationship,omitempty"`
        Description        string                 `json:"description,omitempty"`
        HealthCheckURL     string                 `json:"health_check_url,omitempty"`
        SyncFrequency      string                 `json:"sync_frequency,omitempty"`
        RetryPolicy        map[string]interface{} `json:"retry_policy,omitempty"`
        StartupOrder       int                    `json:"startup_order,omitempty"`
        FallbackBehavior   string                 `json:"fallback_behavior,omitempty"`
        ConflictResolution string                 `json:"conflict_resolution,omitempty"`
        CustomFields       map[string]interface{} `json:"custom_fields,omitempty"`
}

// Scan implements sql.Scanner interface
func (m *DependencyMetadata) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), m)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, m)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Value implements driver.Valuer interface
func (m *DependencyMetadata) Value() (driver.Value, error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(m)
        return string(data), err</span>
}

// DependencyType constants
const (
        // Structural dependency types
        DependencyTypeHard      = "hard"
        DependencyTypeSoft      = "soft"
        DependencyTypeReference = "reference"

        // Behavioral dependency types
        DependencyTypeRuntime  = "runtime"
        DependencyTypeCompile  = "compile"
        DependencyTypeOptional = "optional"

        // Data dependency types
        DependencyTypeSync  = "sync"
        DependencyTypeAsync = "async"

        // Dependency categories
        CategoryStructural = "structural"
        CategoryBehavioral = "behavioral"
        CategoryData       = "data"

        // Impact levels
        ImpactLevelCritical = "critical"
        ImpactLevelHigh     = "high"
        ImpactLevelMedium   = "medium"
        ImpactLevelLow      = "low"
)

// CreateNodeDependencyRequest represents a request to create a dependency
type CreateNodeDependencyRequest struct {
        DependencyNodeID int64               `json:"dependency_node_id" validate:"required"`
        DependencyType   string              `json:"dependency_type" validate:"required,oneof=hard soft reference"`
        CascadeDelete    bool                `json:"cascade_delete"`
        CascadeUpdate    bool                `json:"cascade_update"`
        Metadata         *DependencyMetadata `json:"metadata,omitempty"`
}

// NodeEvent represents an event that occurred on a node
type NodeEvent struct {
        ID          int64      `db:"id" json:"id"`
        NodeID      int64      `db:"node_id" json:"node_id"`
        EventType   string     `db:"event_type" json:"event_type"`
        EventData   *EventData `db:"event_data" json:"event_data,omitempty"`
        OccurredAt  time.Time  `db:"occurred_at" json:"occurred_at"`
        ProcessedAt *time.Time `db:"processed_at" json:"processed_at,omitempty"`
}

// EventData represents the data associated with an event
type EventData struct {
        EventID   string                 `json:"event_id"`
        NodeID    int64                  `json:"node_id"`
        EventType string                 `json:"event_type"`
        Timestamp time.Time              `json:"timestamp"`
        Changes   *EventChanges          `json:"changes,omitempty"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// EventChanges represents before/after state in an event
type EventChanges struct {
        Before map[string]interface{} `json:"before,omitempty"`
        After  map[string]interface{} `json:"after,omitempty"`
}

// Scan implements sql.Scanner interface
func (e *EventData) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), e)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, e)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Value implements driver.Valuer interface
func (e *EventData) Value() (driver.Value, error) <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(e)
        return string(data), err</span>
}

// Event type constants
const (
        EventTypeCreated           = "created"
        EventTypeUpdated           = "updated"
        EventTypeDeleted           = "deleted"
        EventTypeAttributeChanged  = "attribute_changed"
        EventTypeConnectionChanged = "connection_changed"
)

// DependencyGraph represents a node's dependency relationships
type DependencyGraph struct {
        NodeID       int64                  `json:"node_id"`
        Dependencies []DependencyNode       `json:"dependencies"`
        Dependents   []DependencyNode       `json:"dependents"`
        Depth        int                    `json:"depth"`
        HasCircular  bool                   `json:"has_circular"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// DependencyNode represents a node in the dependency graph
type DependencyNode struct {
        NodeID            int64                  `json:"node_id"`
        CompositeID       string                 `json:"composite_id"`
        Title             string                 `json:"title"`
        DependencyType    string                 `json:"dependency_type"`
        Category          string                 `json:"category"`
        Strength          int                    `json:"strength"`
        Priority          int                    `json:"priority"`
        IsRequired        bool                   `json:"is_required"`
        VersionConstraint *string                `json:"version_constraint,omitempty"`
        Metadata          map[string]interface{} `json:"metadata,omitempty"`
        Children          []DependencyNode       `json:"children,omitempty"`
}

// ImpactAnalysisResult contains the results of dependency impact analysis
type ImpactAnalysisResult struct {
        SourceNodeID    int64          `json:"source_node_id"`
        SourceComposite string         `json:"source_composite_id"`
        ImpactType      string         `json:"impact_type"`
        AffectedNodes   []AffectedNode `json:"affected_nodes"`
        ImpactScore     int            `json:"impact_score"` // 0-100
        CascadeDepth    int            `json:"cascade_depth"`
        EstimatedTime   string         `json:"estimated_time"`
        Warnings        []string       `json:"warnings,omitempty"`
        Recommendations []string       `json:"recommendations,omitempty"`
}

// AffectedNode represents a node affected by a dependency change
type AffectedNode struct {
        NodeID       int64   `json:"node_id"`
        CompositeID  string  `json:"composite_id"`
        Title        string  `json:"title"`
        ImpactLevel  string  `json:"impact_level"` // 'critical', 'high', 'medium', 'low'
        Reason       string  `json:"reason"`
        ActionNeeded string  `json:"action_needed"`
        Path         []int64 `json:"path,omitempty"` // Path from source to this node
}

// CircularDependency represents a circular dependency path
type CircularDependency struct {
        Path        []int64  `json:"path"`
        NodeDetails []string `json:"node_details"`
        Strength    int      `json:"strength"` // Weakest link in the cycle
}

// DependencyValidationResult contains validation results
type DependencyValidationResult struct {
        IsValid  bool                 `json:"is_valid"`
        Errors   []string             `json:"errors,omitempty"`
        Warnings []string             `json:"warnings,omitempty"`
        Cycles   []CircularDependency `json:"cycles,omitempty"`
}

// DependencyTypeConfig represents configuration for a dependency type
type DependencyTypeConfig struct {
        TypeName           string                 `json:"type_name"`
        Category           string                 `json:"category"`
        CascadeDelete      bool                   `json:"cascade_delete"`
        CascadeUpdate      bool                   `json:"cascade_update"`
        ValidationRequired bool                   `json:"validation_required"`
        DefaultStrength    int                    `json:"default_strength"`
        DefaultPriority    int                    `json:"default_priority"`
        MetadataSchema     map[string]interface{} `json:"metadata_schema,omitempty"`
        Description        string                 `json:"description"`
}

// DependencyRule represents a validation rule for dependencies
type DependencyRule struct {
        ID         int64                  `db:"id" json:"id"`
        DomainID   *int64                 `db:"domain_id" json:"domain_id,omitempty"`
        RuleName   string                 `db:"rule_name" json:"rule_name"`
        RuleType   string                 `db:"rule_type" json:"rule_type"`
        RuleConfig map[string]interface{} `db:"rule_config" json:"rule_config"`
        IsActive   bool                   `db:"is_active" json:"is_active"`
        CreatedAt  time.Time              `db:"created_at" json:"created_at"`
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "time"
)

// NodeSubscription represents a subscription to node events
type NodeSubscription struct {
        ID                 int64            `db:"id" json:"id"`
        SubscriberService  string           `db:"subscriber_service" json:"subscriber_service"`
        SubscriberEndpoint *string          `db:"subscriber_endpoint" json:"subscriber_endpoint,omitempty"`
        SubscribedNodeID   int64            `db:"subscribed_node_id" json:"subscribed_node_id"`
        EventTypes         EventTypeList    `db:"event_types" json:"event_types"`
        FilterConditions   *FilterCondition `db:"filter_conditions" json:"filter_conditions,omitempty"`
        IsActive           bool             `db:"is_active" json:"is_active"`
        CreatedAt          time.Time        `db:"created_at" json:"created_at"`
        UpdatedAt          time.Time        `db:"updated_at" json:"updated_at"`
}

// EventTypeList represents a list of event types
type EventTypeList []string

// Scan implements sql.Scanner interface
func (e *EventTypeList) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *e = EventTypeList{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), e)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, e)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Value implements driver.Valuer interface
func (e EventTypeList) Value() (driver.Value, error) <span class="cov0" title="0">{
        if len(e) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(e)
        return string(data), err</span>
}

// FilterCondition represents subscription filter conditions
type FilterCondition struct {
        AttributeFilters []AttributeFilter `json:"attribute_filters,omitempty"`
        ChangeFilters    *ChangeFilter     `json:"change_filters,omitempty"`
}

// AttributeFilter represents a filter on node attributes
type AttributeFilter struct {
        AttributeName string      `json:"attribute_name"`
        Operator      string      `json:"operator"`
        Value         interface{} `json:"value"`
}

// ChangeFilter represents filters on what changes to track
type ChangeFilter struct {
        Fields       []string `json:"fields,omitempty"`
        IgnoreFields []string `json:"ignore_fields,omitempty"`
}

// Scan implements sql.Scanner interface
func (f *FilterCondition) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), f)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, f)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Value implements driver.Valuer interface
func (f *FilterCondition) Value() (driver.Value, error) <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(f)
        return string(data), err</span>
}

// CreateNodeSubscriptionRequest represents a request to create a subscription
type CreateNodeSubscriptionRequest struct {
        SubscriberService  string           `json:"subscriber_service" validate:"required"`
        SubscriberEndpoint *string          `json:"subscriber_endpoint,omitempty"`
        EventTypes         []string         `json:"event_types" validate:"required,min=1"`
        FilterConditions   *FilterCondition `json:"filter_conditions,omitempty"`
}

// UpdateNodeSubscriptionRequest represents a request to update a subscription
type UpdateNodeSubscriptionRequest struct {
        SubscriberEndpoint *string          `json:"subscriber_endpoint,omitempty"`
        EventTypes         []string         `json:"event_types,omitempty"`
        FilterConditions   *FilterCondition `json:"filter_conditions,omitempty"`
        IsActive           *bool            `json:"is_active,omitempty"`
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package attributes

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

// AttributeHandler handles HTTP requests for attributes
type AttributeHandler struct {
        service AttributeService
}

// NewAttributeHandler creates a new attribute handler
func NewAttributeHandler(service AttributeService) *AttributeHandler <span class="cov0" title="0">{
        return &amp;AttributeHandler{service: service}
}</span>

// RegisterRoutes registers attribute routes
func (h *AttributeHandler) RegisterRoutes(router *gin.RouterGroup) <span class="cov0" title="0">{
        router.POST("/domains/:domain_id/attributes", h.CreateAttribute)
        router.GET("/domains/:domain_id/attributes", h.ListAttributes)
        router.GET("/attributes/:id", h.GetAttribute)
        router.PUT("/attributes/:id", h.UpdateAttribute)
        router.DELETE("/attributes/:id", h.DeleteAttribute)
}</span>

// CreateAttribute godoc
// @Summary      Create a new attribute
// @Description  Create a new attribute for a domain
// @Tags         attributes
// @Accept       json
// @Produce      json
// @Param        domain_id  path      int                           true  "Domain ID"
// @Param        attribute  body      models.CreateAttributeRequest true  "Attribute data"
// @Success      201        {object}  models.Attribute
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      409        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /domains/{domain_id}/attributes [post]
func (h *AttributeHandler) CreateAttribute(c *gin.Context) <span class="cov0" title="0">{
        domainIDStr := c.Param("domain_id")
        domainID, err := strconv.Atoi(domainIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateAttributeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.service.CreateAttribute(c.Request.Context(), domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, attribute)</span>
}

// GetAttribute godoc
// @Summary      Get an attribute
// @Description  Get attribute by ID
// @Tags         attributes
// @Produce      json
// @Param        id  path      int  true  "Attribute ID"
// @Success      200 {object}  models.Attribute
// @Failure      400 {object}  map[string]interface{}
// @Failure      404 {object}  map[string]interface{}
// @Failure      500 {object}  map[string]interface{}
// @Router       /attributes/{id} [get]
func (h *AttributeHandler) GetAttribute(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid attribute ID",
                })
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.service.GetAttribute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

// ListAttributes godoc
// @Summary      List attributes
// @Description  Get all attributes for a domain
// @Tags         attributes
// @Produce      json
// @Param        domain_id  path      int  true  "Domain ID"
// @Success      200        {object}  models.AttributeListResponse
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /domains/{domain_id}/attributes [get]
func (h *AttributeHandler) ListAttributes(c *gin.Context) <span class="cov0" title="0">{
        domainIDStr := c.Param("domain_id")
        domainID, err := strconv.Atoi(domainIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">response, err := h.service.ListAttributes(c.Request.Context(), domainID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// UpdateAttribute godoc
// @Summary      Update an attribute
// @Description  Update attribute description by ID
// @Tags         attributes
// @Accept       json
// @Produce      json
// @Param        id         path      int                           true  "Attribute ID"
// @Param        attribute  body      models.UpdateAttributeRequest true  "Updated attribute data"
// @Success      200        {object}  models.Attribute
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /attributes/{id} [put]
func (h *AttributeHandler) UpdateAttribute(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid attribute ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateAttributeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.service.UpdateAttribute(c.Request.Context(), id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

// DeleteAttribute godoc
// @Summary      Delete an attribute
// @Description  Delete attribute by ID (only if no associated values exist)
// @Tags         attributes
// @Param        id  path  int  true  "Attribute ID"
// @Success      204
// @Failure      400  {object}  map[string]interface{}
// @Failure      404  {object}  map[string]interface{}
// @Failure      409  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /attributes/{id} [delete]
func (h *AttributeHandler) DeleteAttribute(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid attribute ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.service.DeleteAttribute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// handleError handles service errors and converts them to appropriate HTTP responses
func (h *AttributeHandler) handleError(c *gin.Context, err error) <span class="cov0" title="0">{
        switch err </span>{
        case ErrAttributeNotFound:<span class="cov0" title="0">
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "Attribute not found",
                })</span>
        case ErrAttributeAlreadyExists:<span class="cov0" title="0">
                c.JSON(http.StatusConflict, gin.H{
                        "error":   "conflict",
                        "message": "Attribute already exists",
                })</span>
        case ErrAttributeTypeInvalid:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid attribute type",
                })</span>
        case ErrAttributeHasValues:<span class="cov0" title="0">
                c.JSON(http.StatusConflict, gin.H{
                        "error":   "conflict",
                        "message": "Cannot delete attribute with existing values",
                })</span>
        case ErrDomainNotFound:<span class="cov0" title="0">
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "Domain not found",
                })</span>
        case ErrAttributeNameRequired:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Attribute name is required",
                })</span>
        case ErrAttributeNameTooLong:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Attribute name too long",
                })</span>
        case ErrAttributeTypeRequired:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Attribute type is required",
                })</span>
        case ErrDescriptionTooLong:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Description too long",
                })</span>
        default:<span class="cov0" title="0">
                if strings.Contains(err.Error(), "validation error") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "validation_error",
                                "message": err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error":   "internal_error",
                                "message": "Internal server error",
                        })
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package attributes

import (
        "context"
        "database/sql"
        "fmt"

        "url-db/internal/models"
)

// AttributeRepository defines the interface for attribute data access
type AttributeRepository interface {
        Create(ctx context.Context, attribute *models.Attribute) error
        GetByID(ctx context.Context, id int) (*models.Attribute, error)
        GetByDomainID(ctx context.Context, domainID int) ([]*models.Attribute, error)
        GetByDomainIDAndName(ctx context.Context, domainID int, name string) (*models.Attribute, error)
        Update(ctx context.Context, attribute *models.Attribute) error
        Delete(ctx context.Context, id int) error
        HasValues(ctx context.Context, attributeID int) (bool, error)
}

// SQLiteAttributeRepository implements AttributeRepository for SQLite
type SQLiteAttributeRepository struct {
        db *sql.DB
}

// NewSQLiteAttributeRepository creates a new SQLite attribute repository
func NewSQLiteAttributeRepository(db *sql.DB) *SQLiteAttributeRepository <span class="cov8" title="1">{
        return &amp;SQLiteAttributeRepository{db: db}
}</span>

// Create creates a new attribute
func (r *SQLiteAttributeRepository) Create(ctx context.Context, attribute *models.Attribute) error <span class="cov8" title="1">{
        query := `
                INSERT INTO attributes (domain_id, name, type, description, created_at)
                VALUES (?, ?, ?, ?, ?)
        `

        result, err := r.db.ExecContext(ctx, query,
                attribute.DomainID,
                attribute.Name,
                attribute.Type,
                attribute.Description,
                attribute.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create attribute: %w", err)
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov8" title="1">attribute.ID = int(id)
        return nil</span>
}

// GetByID retrieves an attribute by ID
func (r *SQLiteAttributeRepository) GetByID(ctx context.Context, id int) (*models.Attribute, error) <span class="cov8" title="1">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE id = ?
        `

        attribute := &amp;models.Attribute{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;attribute.ID,
                &amp;attribute.DomainID,
                &amp;attribute.Name,
                &amp;attribute.Type,
                &amp;attribute.Description,
                &amp;attribute.CreatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrAttributeNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get attribute by id: %w", err)</span>
        }

        <span class="cov8" title="1">return attribute, nil</span>
}

// GetByDomainID retrieves all attributes for a domain
func (r *SQLiteAttributeRepository) GetByDomainID(ctx context.Context, domainID int) ([]*models.Attribute, error) <span class="cov8" title="1">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE domain_id = ?
                ORDER BY name
        `

        rows, err := r.db.QueryContext(ctx, query, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get attributes by domain id: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var attributes []*models.Attribute
        for rows.Next() </span><span class="cov8" title="1">{
                attribute := &amp;models.Attribute{}
                err := rows.Scan(
                        &amp;attribute.ID,
                        &amp;attribute.DomainID,
                        &amp;attribute.Name,
                        &amp;attribute.Type,
                        &amp;attribute.Description,
                        &amp;attribute.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan attribute: %w", err)
                }</span>
                <span class="cov8" title="1">attributes = append(attributes, attribute)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating over attributes: %w", err)
        }</span>

        <span class="cov8" title="1">return attributes, nil</span>
}

// GetByDomainIDAndName retrieves an attribute by domain ID and name
func (r *SQLiteAttributeRepository) GetByDomainIDAndName(ctx context.Context, domainID int, name string) (*models.Attribute, error) <span class="cov8" title="1">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE domain_id = ? AND name = ?
        `

        attribute := &amp;models.Attribute{}
        err := r.db.QueryRowContext(ctx, query, domainID, name).Scan(
                &amp;attribute.ID,
                &amp;attribute.DomainID,
                &amp;attribute.Name,
                &amp;attribute.Type,
                &amp;attribute.Description,
                &amp;attribute.CreatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrAttributeNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get attribute by domain id and name: %w", err)</span>
        }

        <span class="cov8" title="1">return attribute, nil</span>
}

// Update updates an attribute
func (r *SQLiteAttributeRepository) Update(ctx context.Context, attribute *models.Attribute) error <span class="cov8" title="1">{
        query := `
                UPDATE attributes
                SET description = ?
                WHERE id = ?
        `

        result, err := r.db.ExecContext(ctx, query, attribute.Description, attribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update attribute: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete deletes an attribute
func (r *SQLiteAttributeRepository) Delete(ctx context.Context, id int) error <span class="cov8" title="1">{
        query := `DELETE FROM attributes WHERE id = ?`

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete attribute: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// HasValues checks if an attribute has any values
func (r *SQLiteAttributeRepository) HasValues(ctx context.Context, attributeID int) (bool, error) <span class="cov8" title="1">{
        query := `SELECT COUNT(*) FROM node_attributes WHERE attribute_id = ?`

        var count int
        err := r.db.QueryRowContext(ctx, query, attributeID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check if attribute has values: %w", err)
        }</span>

        <span class="cov8" title="1">return count &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package attributes

import (
        "context"
        "fmt"
        "time"

        "url-db/internal/models"
)

// AttributeService defines the interface for attribute business logic
type AttributeService interface {
        CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error)
        GetAttribute(ctx context.Context, id int) (*models.Attribute, error)
        ListAttributes(ctx context.Context, domainID int) (*models.AttributeListResponse, error)
        UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error)
        DeleteAttribute(ctx context.Context, id int) error
}

// DomainService interface for domain validation
type DomainService interface {
        GetDomain(ctx context.Context, id int) (*models.Domain, error)
}

// attributeService implements AttributeService
type attributeService struct {
        repo          AttributeRepository
        domainService DomainService
}

// NewAttributeService creates a new attribute service
func NewAttributeService(repo AttributeRepository, domainService DomainService) AttributeService <span class="cov8" title="1">{
        return &amp;attributeService{
                repo:          repo,
                domainService: domainService,
        }
}</span>

// validateAttributeName validates attribute name
func (s *attributeService) validateAttributeName(name string) error <span class="cov8" title="1">{
        if len(name) == 0 </span><span class="cov8" title="1">{
                return ErrAttributeNameRequired
        }</span>
        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov8" title="1">{
                return ErrAttributeNameTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateAttributeType validates attribute type
func (s *attributeService) validateAttributeType(attrType AttributeType) error <span class="cov8" title="1">{
        if attrType == "" </span><span class="cov8" title="1">{
                return ErrAttributeTypeRequired
        }</span>
        <span class="cov8" title="1">if !IsValidAttributeType(attrType) </span><span class="cov8" title="1">{
                return ErrAttributeTypeInvalid
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateDescription validates description
func (s *attributeService) validateDescription(description string) error <span class="cov8" title="1">{
        if len(description) &gt; 1000 </span><span class="cov8" title="1">{
                return ErrDescriptionTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CreateAttribute creates a new attribute
func (s *attributeService) CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error) <span class="cov8" title="1">{
        // Validate input
        if err := s.validateAttributeName(req.Name); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.validateAttributeType(req.Type); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.validateDescription(req.Description); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        // Check if domain exists
        <span class="cov8" title="1">_, err := s.domainService.GetDomain(ctx, domainID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ErrDomainNotFound
        }</span>

        // Check if attribute name already exists in domain
        <span class="cov8" title="1">existing, err := s.repo.GetByDomainIDAndName(ctx, domainID, req.Name)
        if err != nil &amp;&amp; err != ErrAttributeNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check attribute existence: %w", err)
        }</span>
        <span class="cov8" title="1">if existing != nil </span><span class="cov8" title="1">{
                return nil, ErrAttributeAlreadyExists
        }</span>

        // Create attribute
        <span class="cov8" title="1">attribute := &amp;models.Attribute{
                DomainID:    domainID,
                Name:        req.Name,
                Type:        req.Type,
                Description: req.Description,
                CreatedAt:   time.Now(),
        }

        err = s.repo.Create(ctx, attribute)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create attribute: %w", err)
        }</span>

        <span class="cov8" title="1">return attribute, nil</span>
}

// GetAttribute retrieves an attribute by ID
func (s *attributeService) GetAttribute(ctx context.Context, id int) (*models.Attribute, error) <span class="cov8" title="1">{
        attribute, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return attribute, nil</span>
}

// ListAttributes lists all attributes for a domain
func (s *attributeService) ListAttributes(ctx context.Context, domainID int) (*models.AttributeListResponse, error) <span class="cov8" title="1">{
        // Check if domain exists
        _, err := s.domainService.GetDomain(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">attributes, err := s.repo.GetByDomainID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list attributes: %w", err)
        }</span>

        // Convert to response format
        <span class="cov8" title="1">attributeList := make([]models.Attribute, len(attributes))
        for i, attr := range attributes </span><span class="cov8" title="1">{
                attributeList[i] = *attr
        }</span>

        <span class="cov8" title="1">return &amp;models.AttributeListResponse{
                Attributes: attributeList,
        }, nil</span>
}

// UpdateAttribute updates an attribute
func (s *attributeService) UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error) <span class="cov8" title="1">{
        // Validate input
        if err := s.validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        // Get existing attribute
        <span class="cov8" title="1">attribute, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update only description (name and type are immutable)
        <span class="cov8" title="1">attribute.Description = req.Description

        err = s.repo.Update(ctx, attribute)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update attribute: %w", err)
        }</span>

        <span class="cov8" title="1">return attribute, nil</span>
}

// DeleteAttribute deletes an attribute
func (s *attributeService) DeleteAttribute(ctx context.Context, id int) error <span class="cov8" title="1">{
        // Check if attribute exists
        _, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if attribute has values
        <span class="cov8" title="1">hasValues, err := s.repo.HasValues(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check attribute values: %w", err)
        }</span>
        <span class="cov8" title="1">if hasValues </span><span class="cov8" title="1">{
                return ErrAttributeHasValues
        }</span>

        // Delete attribute
        <span class="cov8" title="1">err = s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete attribute: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "time"

        "url-db/internal/models"
)

type AttributeRepository interface {
        Create(ctx context.Context, attribute *models.Attribute) error
        GetByID(ctx context.Context, id int) (*models.Attribute, error)
        GetByDomainAndName(ctx context.Context, domainID int, name string) (*models.Attribute, error)
        ListByDomain(ctx context.Context, domainID int) ([]*models.Attribute, error)
        Update(ctx context.Context, attribute *models.Attribute) error
        Delete(ctx context.Context, id int) error
        ExistsByDomainAndName(ctx context.Context, domainID int, name string) (bool, error)
}

type attributeService struct {
        attributeRepo AttributeRepository
        domainRepo    DomainRepository
        logger        *log.Logger
}

func NewAttributeService(attributeRepo AttributeRepository, domainRepo DomainRepository, logger *log.Logger) AttributeService <span class="cov0" title="0">{
        return &amp;attributeService{
                attributeRepo: attributeRepo,
                domainRepo:    domainRepo,
                logger:        logger,
        }
}</span>

func (s *attributeService) CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Name = normalizeString(req.Name)
        req.Type = models.AttributeType(normalizeString(string(req.Type)))
        req.Description = normalizeString(req.Description)

        if err := validateAttributeName(req.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateAttributeType(string(req.Type)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainRepo.GetByID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">exists, err := s.attributeRepo.ExistsByDomainAndName(ctx, domainID, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to check attribute existence: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, NewAttributeAlreadyExistsError(domainID, req.Name)
        }</span>

        <span class="cov0" title="0">attribute := &amp;models.Attribute{
                DomainID:    domainID,
                Name:        req.Name,
                Type:        req.Type,
                Description: req.Description,
                CreatedAt:   time.Now(),
        }

        if err := s.attributeRepo.Create(ctx, attribute); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to create attribute: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Created attribute: %s in domain %s (ID: %d)", attribute.Name, domain.Name, attribute.ID)
        return attribute, nil</span>
}

func (s *attributeService) GetAttribute(ctx context.Context, id int) (*models.Attribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return attribute, nil</span>
}

func (s *attributeService) ListAttributesByDomain(ctx context.Context, domainID int) (*models.AttributeListResponse, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainRepo.GetByID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">attributes, err := s.attributeRepo.ListByDomain(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to list attributes: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">attributeList := make([]models.Attribute, len(attributes))
        for i, attribute := range attributes </span><span class="cov0" title="0">{
                attributeList[i] = *attribute
        }</span>

        <span class="cov0" title="0">return &amp;models.AttributeListResponse{
                Attributes: attributeList,
                Domain:     domain,
        }, nil</span>
}

func (s *attributeService) UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Description = normalizeString(req.Description)

        if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">attribute.Description = req.Description

        if err := s.attributeRepo.Update(ctx, attribute); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to update attribute: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Updated attribute: %s (ID: %d)", attribute.Name, attribute.ID)
        return attribute, nil</span>
}

func (s *attributeService) DeleteAttribute(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err := s.attributeRepo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to delete attribute: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">s.logger.Printf("Deleted attribute with ID: %d", id)
        return nil</span>
}

func (s *attributeService) ValidateAttributeValue(ctx context.Context, attributeID int, value string) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(attributeID, "attributeID"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">value = normalizeString(value)

        attribute, err := s.attributeRepo.GetByID(ctx, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewAttributeNotFoundError(attributeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">if err := validateAttributeValue(string(attribute.Type), value); err != nil </span><span class="cov0" title="0">{
                return NewAttributeValueInvalidError(attributeID, value, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package services

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "url-db/internal/models"
)

type compositeKeyService struct {
        toolName string
}

func NewCompositeKeyService(toolName string) CompositeKeyService <span class="cov0" title="0">{
        return &amp;compositeKeyService{
                toolName: toolName,
        }
}</span>

func (s *compositeKeyService) Create(domainName string, id int) string <span class="cov0" title="0">{
        normalizedDomain := s.normalizeName(domainName)
        return fmt.Sprintf("%s:%s:%d", s.toolName, normalizedDomain, id)
}</span>

func (s *compositeKeyService) Parse(compositeKey string) (*models.CompositeKey, error) <span class="cov0" title="0">{
        if compositeKey == "" </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "composite key is empty")
        }</span>

        <span class="cov0" title="0">parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "invalid format, expected 'tool:domain:id'")
        }</span>

        <span class="cov0" title="0">toolName := parts[0]
        domainName := parts[1]
        idStr := parts[2]

        if toolName == "" </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "tool name is empty")
        }</span>

        <span class="cov0" title="0">if toolName != s.toolName </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, fmt.Sprintf("invalid tool name, expected '%s'", s.toolName))
        }</span>

        <span class="cov0" title="0">if domainName == "" </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "domain name is empty")
        }</span>

        <span class="cov0" title="0">if idStr == "" </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "ID is empty")
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "ID must be a valid integer")
        }</span>

        <span class="cov0" title="0">if id &lt;= 0 </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "ID must be positive")
        }</span>

        <span class="cov0" title="0">return &amp;models.CompositeKey{
                ToolName:   toolName,
                DomainName: domainName,
                ID:         id,
        }, nil</span>
}

func (s *compositeKeyService) Validate(compositeKey string) error <span class="cov0" title="0">{
        _, err := s.Parse(compositeKey)
        return err
}</span>

func (s *compositeKeyService) GetToolName() string <span class="cov0" title="0">{
        return s.toolName
}</span>

func (s *compositeKeyService) normalizeName(name string) string <span class="cov0" title="0">{
        normalized := strings.ToLower(name)

        reg := regexp.MustCompile(`[^a-z0-9\-_]`)
        normalized = reg.ReplaceAllString(normalized, "-")

        reg = regexp.MustCompile(`-+`)
        normalized = reg.ReplaceAllString(normalized, "-")

        normalized = strings.Trim(normalized, "-")

        if normalized == "" </span><span class="cov0" title="0">{
                normalized = "default"
        }</span>

        <span class="cov0" title="0">return normalized</span>
}

func (s *compositeKeyService) DenormalizeName(normalizedName string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(normalizedName, "-", " ")
}</span>

func (s *compositeKeyService) ExtractComponents(compositeKey string) (toolName, domainName string, id int, err error) <span class="cov0" title="0">{
        ck, err := s.Parse(compositeKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", 0, err
        }</span>

        <span class="cov0" title="0">return ck.ToolName, ck.DomainName, ck.ID, nil</span>
}

func (s *compositeKeyService) IsValid(compositeKey string) bool <span class="cov0" title="0">{
        return s.Validate(compositeKey) == nil
}</span>

func (s *compositeKeyService) GenerateFromNode(node *models.Node, domainName string) string <span class="cov0" title="0">{
        return s.Create(domainName, node.ID)
}</span>

func (s *compositeKeyService) GenerateFromDomain(domain *models.Domain) string <span class="cov0" title="0">{
        return s.Create(domain.Name, domain.ID)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package services

import (
        "fmt"

        "url-db/internal/models"
        "url-db/internal/repositories"
)

// DependencyService handles business logic for dependencies
type DependencyService struct {
        dependencyRepo *repositories.DependencyRepository
        nodeRepo       repositories.NodeRepository
        eventRepo      *repositories.EventRepository
}

// NewDependencyService creates a new dependency service
func NewDependencyService(
        dependencyRepo *repositories.DependencyRepository,
        nodeRepo repositories.NodeRepository,
        eventRepo *repositories.EventRepository,
) *DependencyService <span class="cov0" title="0">{
        return &amp;DependencyService{
                dependencyRepo: dependencyRepo,
                nodeRepo:       nodeRepo,
                eventRepo:      eventRepo,
        }
}</span>

// CreateDependency creates a new dependency
func (s *DependencyService) CreateDependency(dependentNodeID int64, req *models.CreateNodeDependencyRequest) (*models.NodeDependency, error) <span class="cov0" title="0">{
        // Verify both nodes exist
        dependentNode, err := s.nodeRepo.GetByID(int(dependentNodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependent node: %w", err)
        }</span>
        <span class="cov0" title="0">if dependentNode == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependent node not found")
        }</span>

        <span class="cov0" title="0">dependencyNode, err := s.nodeRepo.GetByID(int(req.DependencyNodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependency node: %w", err)
        }</span>
        <span class="cov0" title="0">if dependencyNode == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependency node not found")
        }</span>

        // Check for circular dependency
        <span class="cov0" title="0">hasCircular, err := s.dependencyRepo.CheckCircularDependency(dependentNodeID, req.DependencyNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check circular dependency: %w", err)
        }</span>
        <span class="cov0" title="0">if hasCircular </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("circular dependency detected")
        }</span>

        // Create dependency
        <span class="cov0" title="0">dependency := &amp;models.NodeDependency{
                DependentNodeID:  dependentNodeID,
                DependencyNodeID: req.DependencyNodeID,
                DependencyType:   req.DependencyType,
                CascadeDelete:    req.CascadeDelete,
                CascadeUpdate:    req.CascadeUpdate,
                Metadata:         req.Metadata,
        }

        err = s.dependencyRepo.Create(dependency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create dependency: %w", err)
        }</span>

        <span class="cov0" title="0">return dependency, nil</span>
}

// GetDependency retrieves a dependency by ID
func (s *DependencyService) GetDependency(id int64) (*models.NodeDependency, error) <span class="cov0" title="0">{
        dependency, err := s.dependencyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependency: %w", err)
        }</span>
        <span class="cov0" title="0">if dependency == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependency not found")
        }</span>

        <span class="cov0" title="0">return dependency, nil</span>
}

// DeleteDependency deletes a dependency
func (s *DependencyService) DeleteDependency(id int64) error <span class="cov0" title="0">{
        err := s.dependencyRepo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete dependency: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetNodeDependencies retrieves all dependencies for a node (as dependent)
func (s *DependencyService) GetNodeDependencies(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        <span class="cov0" title="0">return s.dependencyRepo.GetByDependentNode(nodeID)</span>
}

// GetNodeDependents retrieves all nodes that depend on a given node
func (s *DependencyService) GetNodeDependents(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        <span class="cov0" title="0">return s.dependencyRepo.GetByDependencyNode(nodeID)</span>
}

// HandleNodeDeletion handles cascading deletes when a node is deleted
func (s *DependencyService) HandleNodeDeletion(nodeID int64) error <span class="cov0" title="0">{
        // Get all dependents with cascade delete
        dependentIDs, err := s.dependencyRepo.GetDependentsWithCascadeDelete(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get cascade delete dependents: %w", err)
        }</span>

        // Delete each dependent node (this will trigger their own cascades)
        <span class="cov0" title="0">for _, depID := range dependentIDs </span><span class="cov0" title="0">{
                err = s.nodeRepo.Delete(int(depID))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete dependent node %d: %w", depID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// HandleNodeUpdate handles cascading updates when a node is updated
func (s *DependencyService) HandleNodeUpdate(nodeID int64, changes *models.EventChanges) error <span class="cov0" title="0">{
        // Get all dependents with cascade update
        dependentIDs, err := s.dependencyRepo.GetDependentsWithCascadeUpdate(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get cascade update dependents: %w", err)
        }</span>

        // Create update event for each dependent
        <span class="cov0" title="0">for _, depID := range dependentIDs </span><span class="cov0" title="0">{
                eventData := &amp;models.EventData{
                        NodeID:    depID,
                        EventType: "dependency_updated",
                        Metadata: map[string]interface{}{
                                "dependency_node_id": nodeID,
                                "changes":            changes,
                        },
                }

                event := &amp;models.NodeEvent{
                        NodeID:    depID,
                        EventType: "dependency_updated",
                        EventData: eventData,
                }

                err = s.eventRepo.Create(event)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create update event for dependent %d: %w", depID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "time"

        "url-db/internal/models"
)

type DomainRepository interface {
        Create(ctx context.Context, domain *models.Domain) error
        GetByID(ctx context.Context, id int) (*models.Domain, error)
        GetByName(ctx context.Context, name string) (*models.Domain, error)
        List(ctx context.Context, page, size int) ([]*models.Domain, int, error)
        Update(ctx context.Context, domain *models.Domain) error
        Delete(ctx context.Context, id int) error
        ExistsByName(ctx context.Context, name string) (bool, error)
}

type domainService struct {
        domainRepo DomainRepository
        logger     *log.Logger
}

func NewDomainService(domainRepo DomainRepository, logger *log.Logger) DomainService <span class="cov0" title="0">{
        return &amp;domainService{
                domainRepo: domainRepo,
                logger:     logger,
        }
}</span>

func (s *domainService) CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*models.Domain, error) <span class="cov0" title="0">{
        req.Name = normalizeString(req.Name)
        req.Description = normalizeString(req.Description)

        if err := validateDomainName(req.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">exists, err := s.domainRepo.ExistsByName(ctx, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to check domain existence: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, NewDomainAlreadyExistsError(req.Name)
        }</span>

        <span class="cov0" title="0">domain := &amp;models.Domain{
                Name:        req.Name,
                Description: req.Description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        if err := s.domainRepo.Create(ctx, domain); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to create domain: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Created domain: %s (ID: %d)", domain.Name, domain.ID)
        return domain, nil</span>
}

func (s *domainService) GetDomain(ctx context.Context, id int) (*models.Domain, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return domain, nil</span>
}

func (s *domainService) GetDomainByName(ctx context.Context, name string) (*models.Domain, error) <span class="cov0" title="0">{
        name = normalizeString(name)

        if err := validateDomainName(name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainRepo.GetByName(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(0)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain by name: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return domain, nil</span>
}

func (s *domainService) ListDomains(ctx context.Context, page, size int) (*models.DomainListResponse, error) <span class="cov0" title="0">{
        page, size, err := validatePaginationParams(page, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domains, totalCount, err := s.domainRepo.List(ctx, page, size)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to list domains: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">domainList := make([]models.Domain, len(domains))
        for i, domain := range domains </span><span class="cov0" title="0">{
                domainList[i] = *domain
        }</span>

        <span class="cov0" title="0">totalPages := (totalCount + size - 1) / size

        return &amp;models.DomainListResponse{
                Domains:    domainList,
                TotalCount: totalCount,
                Page:       page,
                Size:       size,
                TotalPages: totalPages,
        }, nil</span>
}

func (s *domainService) UpdateDomain(ctx context.Context, id int, req *models.UpdateDomainRequest) (*models.Domain, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Description = normalizeString(req.Description)

        if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">domain.Description = req.Description
        domain.UpdatedAt = time.Now()

        if err := s.domainRepo.Update(ctx, domain); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to update domain: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Updated domain: %s (ID: %d)", domain.Name, domain.ID)
        return domain, nil</span>
}

func (s *domainService) DeleteDomain(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err := s.domainRepo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewDomainNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to delete domain: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">s.logger.Printf("Deleted domain with ID: %d", id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package services

import "fmt"

type ServiceError struct {
        Code    string
        Message string
        Details interface{}
}

func (e *ServiceError) Error() string <span class="cov8" title="1">{
        if e.Message != "" </span><span class="cov8" title="1">{
                return e.Code + ": " + e.Message
        }</span>
        <span class="cov8" title="1">return e.Code</span>
}

func NewValidationError(field, message string) *ServiceError <span class="cov8" title="1">{
        return &amp;ServiceError{
                Code:    "VALIDATION_ERROR",
                Message: fmt.Sprintf("Validation failed for field '%s': %s", field, message),
                Details: map[string]string{"field": field, "message": message},
        }
}</span>

func NewDomainAlreadyExistsError(name string) *ServiceError <span class="cov8" title="1">{
        return &amp;ServiceError{
                Code:    "DOMAIN_ALREADY_EXISTS",
                Message: fmt.Sprintf("Domain '%s' already exists", name),
                Details: map[string]string{"domain": name},
        }
}</span>

func NewNodeAlreadyExistsError(url string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "NODE_ALREADY_EXISTS",
                Message: fmt.Sprintf("Node with URL '%s' already exists", url),
                Details: map[string]string{"url": url},
        }
}</span>

func NewAttributeAlreadyExistsError(domainID int, name string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "ATTRIBUTE_ALREADY_EXISTS",
                Message: fmt.Sprintf("Attribute '%s' already exists in domain %d", name, domainID),
                Details: map[string]interface{}{"domain_id": domainID, "name": name},
        }
}</span>

func NewInvalidCompositeKeyError(key, reason string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "INVALID_COMPOSITE_KEY",
                Message: fmt.Sprintf("Invalid composite key '%s': %s", key, reason),
                Details: map[string]string{"key": key, "reason": reason},
        }
}</span>

func NewDomainNotFoundError(id int) *ServiceError <span class="cov8" title="1">{
        return &amp;ServiceError{
                Code:    "DOMAIN_NOT_FOUND",
                Message: fmt.Sprintf("Domain with id %d not found", id),
                Details: map[string]int{"id": id},
        }
}</span>

func NewNodeNotFoundError(id int) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "NODE_NOT_FOUND",
                Message: fmt.Sprintf("Node with id %d not found", id),
                Details: map[string]int{"id": id},
        }
}</span>

func NewAttributeNotFoundError(id int) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "ATTRIBUTE_NOT_FOUND",
                Message: fmt.Sprintf("Attribute with id %d not found", id),
                Details: map[string]int{"id": id},
        }
}</span>

func NewNodeAttributeNotFoundError(id int) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "NODE_ATTRIBUTE_NOT_FOUND",
                Message: fmt.Sprintf("Node attribute with id %d not found", id),
                Details: map[string]int{"id": id},
        }
}</span>

func NewAttributeValueInvalidError(attributeID int, value, reason string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "ATTRIBUTE_VALUE_INVALID",
                Message: fmt.Sprintf("Invalid value '%s' for attribute %d: %s", value, attributeID, reason),
                Details: map[string]interface{}{"attribute_id": attributeID, "value": value, "reason": reason},
        }
}</span>

func NewBusinessLogicError(message string) *ServiceError <span class="cov8" title="1">{
        return &amp;ServiceError{
                Code:    "BUSINESS_LOGIC_ERROR",
                Message: message,
                Details: nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package services

import (
        "fmt"
        "time"

        "url-db/internal/models"
        "url-db/internal/repositories"
)

// EventService handles business logic for events
type EventService struct {
        eventRepo *repositories.EventRepository
        nodeRepo  repositories.NodeRepository
}

// NewEventService creates a new event service
func NewEventService(
        eventRepo *repositories.EventRepository,
        nodeRepo repositories.NodeRepository,
) *EventService <span class="cov0" title="0">{
        return &amp;EventService{
                eventRepo: eventRepo,
                nodeRepo:  nodeRepo,
        }
}</span>

// GetNodeEvents retrieves events for a specific node
func (s *EventService) GetNodeEvents(nodeID int64, limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        <span class="cov0" title="0">if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">return s.eventRepo.GetByNode(nodeID, limit)</span>
}

// GetPendingEvents retrieves unprocessed events
func (s *EventService) GetPendingEvents(limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        if limit &lt;= 0 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">return s.eventRepo.GetPendingEvents(limit)</span>
}

// ProcessEvent marks an event as processed
func (s *EventService) ProcessEvent(eventID int64) error <span class="cov0" title="0">{
        // Verify event exists
        event, err := s.eventRepo.GetByID(eventID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get event: %w", err)
        }</span>
        <span class="cov0" title="0">if event == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event not found")
        }</span>

        <span class="cov0" title="0">if event.ProcessedAt != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event already processed")
        }</span>

        <span class="cov0" title="0">return s.eventRepo.MarkAsProcessed(eventID)</span>
}

// GetEventsByTypeAndDateRange retrieves events by type within a date range
func (s *EventService) GetEventsByTypeAndDateRange(eventType string, start, end time.Time) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        // Validate date range
        if end.Before(start) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("end date must be after start date")
        }</span>

        <span class="cov0" title="0">return s.eventRepo.GetByTypeAndDateRange(eventType, start, end)</span>
}

// CleanupOldEvents deletes processed events older than the specified duration
func (s *EventService) CleanupOldEvents(olderThan time.Duration) (int64, error) <span class="cov0" title="0">{
        if olderThan &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("minimum retention period is 24 hours")
        }</span>

        <span class="cov0" title="0">return s.eventRepo.DeleteOldEvents(olderThan)</span>
}

// GetEventStats retrieves statistics about events
func (s *EventService) GetEventStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        return s.eventRepo.GetEventStats()
}</span>

// CreateNodeEvent creates a new event for a node
func (s *EventService) CreateNodeEvent(nodeID int64, eventType string, changes *models.EventChanges) error <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("node not found")
        }</span>

        // Create event data
        <span class="cov0" title="0">eventData := &amp;models.EventData{
                NodeID:    nodeID,
                EventType: eventType,
                Timestamp: time.Now(),
                Changes:   changes,
                Metadata: map[string]interface{}{
                        "domain_id": node.DomainID,
                },
        }

        // Create event
        event := &amp;models.NodeEvent{
                NodeID:    nodeID,
                EventType: eventType,
                EventData: eventData,
        }

        return s.eventRepo.Create(event)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package services

import (
        "context"
        "fmt"
        "log"

        "url-db/internal/models"
)

type mcpService struct {
        nodeService          NodeService
        domainService        DomainService
        attributeService     AttributeService
        nodeAttributeService NodeAttributeService
        compositeKeyService  CompositeKeyService
        toolName             string
        version              string
        logger               *log.Logger
}

func NewMCPService(
        nodeService NodeService,
        domainService DomainService,
        attributeService AttributeService,
        nodeAttributeService NodeAttributeService,
        compositeKeyService CompositeKeyService,
        toolName, version string,
        logger *log.Logger,
) MCPService <span class="cov0" title="0">{
        return &amp;mcpService{
                nodeService:          nodeService,
                domainService:        domainService,
                attributeService:     attributeService,
                nodeAttributeService: nodeAttributeService,
                compositeKeyService:  compositeKeyService,
                toolName:             toolName,
                version:              version,
                logger:               logger,
        }
}</span>

func (s *mcpService) CreateNode(ctx context.Context, req *models.CreateMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        req.DomainName = normalizeString(req.DomainName)
        req.URL = normalizeString(req.URL)
        req.Title = normalizeString(req.Title)
        req.Description = normalizeString(req.Description)

        if err := validateDomainName(req.DomainName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, req.DomainName)
        if err != nil </span><span class="cov0" title="0">{
                if serviceErr, ok := err.(*ServiceError); ok &amp;&amp; serviceErr.Code == "DOMAIN_NOT_FOUND" </span><span class="cov0" title="0">{
                        createDomainReq := &amp;models.CreateDomainRequest{
                                Name:        req.DomainName,
                                Description: fmt.Sprintf("Auto-created domain for %s", req.DomainName),
                        }
                        domain, err = s.domainService.CreateDomain(ctx, createDomainReq)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">createNodeReq := &amp;models.CreateNodeRequest{
                URL:         req.URL,
                Title:       req.Title,
                Description: req.Description,
        }

        node, err := s.nodeService.CreateNode(ctx, domain.ID, createNodeReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.convertToMCPNode(node, domain), nil</span>
}

func (s *mcpService) GetNode(ctx context.Context, compositeID string) (*models.MCPNode, error) <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">node, err := s.nodeService.GetNode(ctx, ck.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomain(ctx, node.DomainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.convertToMCPNode(node, domain), nil</span>
}

func (s *mcpService) ListNodes(ctx context.Context, domainName string, page, size int, search string) (*models.MCPNodeListResponse, error) <span class="cov0" title="0">{
        domainName = normalizeString(domainName)

        if err := validateDomainName(domainName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeListResp, err := s.nodeService.ListNodesByDomain(ctx, domain.ID, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mcpNodes := make([]models.MCPNode, len(nodeListResp.Nodes))
        for i, node := range nodeListResp.Nodes </span><span class="cov0" title="0">{
                mcpNodes[i] = *s.convertToMCPNode(&amp;node, domain)
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPNodeListResponse{
                Nodes:      mcpNodes,
                TotalCount: nodeListResp.TotalCount,
                Page:       nodeListResp.Page,
                Size:       nodeListResp.Size,
                TotalPages: nodeListResp.TotalPages,
        }, nil</span>
}

func (s *mcpService) UpdateNode(ctx context.Context, compositeID string, req *models.UpdateMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updateReq := &amp;models.UpdateNodeRequest{
                Title:       req.Title,
                Description: req.Description,
        }

        node, err := s.nodeService.UpdateNode(ctx, ck.ID, updateReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomain(ctx, node.DomainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.convertToMCPNode(node, domain), nil</span>
}

func (s *mcpService) DeleteNode(ctx context.Context, compositeID string) error <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.nodeService.DeleteNode(ctx, ck.ID)</span>
}

func (s *mcpService) FindNodeByURL(ctx context.Context, req *models.FindMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        req.DomainName = normalizeString(req.DomainName)

        if err := validateDomainName(req.DomainName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, req.DomainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">findReq := &amp;models.FindNodeByURLRequest{
                URL: req.URL,
        }

        node, err := s.nodeService.FindNodeByURL(ctx, domain.ID, findReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.convertToMCPNode(node, domain), nil</span>
}

func (s *mcpService) BatchGetNodes(ctx context.Context, req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error) <span class="cov0" title="0">{
        results := make([]models.MCPNode, 0, len(req.CompositeIDs))
        errors := make([]string, 0)

        for _, compositeID := range req.CompositeIDs </span><span class="cov0" title="0">{
                node, err := s.GetNode(ctx, compositeID)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Failed to get node %s: %v", compositeID, err))
                        continue</span>
                }
                <span class="cov0" title="0">results = append(results, *node)</span>
        }

        <span class="cov0" title="0">return &amp;models.BatchMCPNodeResponse{
                Nodes:  results,
                Errors: errors,
        }, nil</span>
}

func (s *mcpService) ListDomains(ctx context.Context) (*models.MCPDomainListResponse, error) <span class="cov0" title="0">{
        domainsResp, err := s.domainService.ListDomains(ctx, 1, 100)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mcpDomains := make([]models.MCPDomain, len(domainsResp.Domains))
        for i, domain := range domainsResp.Domains </span><span class="cov0" title="0">{
                mcpDomains[i] = models.MCPDomain{
                        Name:        domain.Name,
                        Description: domain.Description,
                        CreatedAt:   domain.CreatedAt,
                        UpdatedAt:   domain.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomainListResponse{
                Domains: mcpDomains,
        }, nil</span>
}

func (s *mcpService) CreateDomain(ctx context.Context, req *models.CreateMCPDomainRequest) (*models.MCPDomain, error) <span class="cov0" title="0">{
        createReq := &amp;models.CreateDomainRequest{
                Name:        req.Name,
                Description: req.Description,
        }

        domain, err := s.domainService.CreateDomain(ctx, createReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomain{
                Name:        domain.Name,
                Description: domain.Description,
                CreatedAt:   domain.CreatedAt,
                UpdatedAt:   domain.UpdatedAt,
        }, nil</span>
}

func (s *mcpService) GetNodeAttributes(ctx context.Context, compositeID string) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeAttrsResp, err := s.nodeAttributeService.ListNodeAttributesByNode(ctx, ck.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">attributes := make([]models.MCPAttribute, len(nodeAttrsResp.NodeAttributes))
        for i, nodeAttr := range nodeAttrsResp.NodeAttributes </span><span class="cov0" title="0">{
                attributes[i] = models.MCPAttribute{
                        Name:  fmt.Sprintf("attr_%d", nodeAttr.AttributeID),
                        Type:  string(nodeAttr.Type),
                        Value: nodeAttr.Value,
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPNodeAttributeResponse{
                CompositeID: compositeID,
                Attributes:  attributes,
        }, nil</span>
}

func (s *mcpService) SetNodeAttributes(ctx context.Context, compositeID string, req *models.SetMCPNodeAttributesRequest) error <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // SetNodeAttributes functionality is not yet implemented
        // This would require:
        // 1. Finding or creating attribute definitions in the domain
        // 2. Creating node_attribute entries with the found attribute IDs
        // 3. Handling validation and type checking
        <span class="cov0" title="0">s.logger.Printf("SetNodeAttributes called for node %d with %d attributes (not implemented)",
                ck.ID, len(req.Attributes))

        return fmt.Errorf("SetNodeAttributes is not yet implemented")</span>
}

func (s *mcpService) GetServerInfo(ctx context.Context) (*models.MCPServerInfo, error) <span class="cov0" title="0">{
        return &amp;models.MCPServerInfo{
                Name:        s.toolName,
                Version:     s.version,
                Description: "URL Database Management System",
        }, nil
}</span>

func (s *mcpService) convertToMCPNode(node *models.Node, domain *models.Domain) *models.MCPNode <span class="cov0" title="0">{
        compositeID := s.compositeKeyService.Create(domain.Name, node.ID)

        return &amp;models.MCPNode{
                CompositeID: compositeID,
                URL:         node.Content,
                DomainName:  domain.Name,
                Title:       node.Title,
                Description: node.Description,
                CreatedAt:   node.CreatedAt,
                UpdatedAt:   node.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "time"

        "url-db/internal/models"
)

type NodeRepository interface {
        Create(ctx context.Context, node *models.Node) error
        GetByID(ctx context.Context, id int) (*models.Node, error)
        GetByDomainAndContent(ctx context.Context, domainID int, content string) (*models.Node, error)
        ListByDomain(ctx context.Context, domainID int, page, size int, search string) ([]*models.Node, int, error)
        Update(ctx context.Context, node *models.Node) error
        Delete(ctx context.Context, id int) error
        ExistsByDomainAndContent(ctx context.Context, domainID int, content string) (bool, error)
}

type nodeService struct {
        nodeRepo   NodeRepository
        domainRepo DomainRepository
        logger     *log.Logger
}

func NewNodeService(nodeRepo NodeRepository, domainRepo DomainRepository, logger *log.Logger) NodeService <span class="cov0" title="0">{
        return &amp;nodeService{
                nodeRepo:   nodeRepo,
                domainRepo: domainRepo,
                logger:     logger,
        }
}</span>

func (s *nodeService) CreateNode(ctx context.Context, domainID int, req *models.CreateNodeRequest) (*models.Node, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.URL = normalizeString(req.URL)
        req.Title = normalizeString(req.Title)
        req.Description = normalizeString(req.Description)

        if err := validateURL(req.URL); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateTitle(req.Title); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainRepo.GetByID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">exists, err := s.nodeRepo.ExistsByDomainAndContent(ctx, domainID, req.URL)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to check node existence: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, NewNodeAlreadyExistsError(req.URL)
        }</span>

        <span class="cov0" title="0">title := req.Title
        if title == "" </span><span class="cov0" title="0">{
                title = generateTitleFromURL(req.URL)
        }</span>

        <span class="cov0" title="0">node := &amp;models.Node{
                Content:     req.URL,
                DomainID:    domainID,
                Title:       title,
                Description: req.Description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        if err := s.nodeRepo.Create(ctx, node); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to create node: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Created node: %s in domain %s (ID: %d)", node.Content, domain.Name, node.ID)
        return node, nil</span>
}

func (s *nodeService) GetNode(ctx context.Context, id int) (*models.Node, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">node, err := s.nodeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return node, nil</span>
}

func (s *nodeService) GetNodeByDomainAndURL(ctx context.Context, domainID int, url string) (*models.Node, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url = normalizeString(url)
        if err := validateURL(url); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">node, err := s.nodeRepo.GetByDomainAndContent(ctx, domainID, url)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeNotFoundError(0)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node by domain and URL: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return node, nil</span>
}

func (s *nodeService) ListNodesByDomain(ctx context.Context, domainID int, page, size int, search string) (*models.NodeListResponse, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">page, size, err := validatePaginationParams(page, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">search = normalizeString(search)

        _, err = s.domainRepo.GetByID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">nodes, totalCount, err := s.nodeRepo.ListByDomain(ctx, domainID, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to list nodes: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeList := make([]models.Node, len(nodes))
        for i, node := range nodes </span><span class="cov0" title="0">{
                nodeList[i] = *node
        }</span>

        <span class="cov0" title="0">totalPages := (totalCount + size - 1) / size

        return &amp;models.NodeListResponse{
                Nodes:      nodeList,
                TotalCount: totalCount,
                Page:       page,
                Size:       size,
                TotalPages: totalPages,
        }, nil</span>
}

func (s *nodeService) UpdateNode(ctx context.Context, id int, req *models.UpdateNodeRequest) (*models.Node, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Title = normalizeString(req.Title)
        req.Description = normalizeString(req.Description)

        if err := validateTitle(req.Title); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">node, err := s.nodeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">node.Title = req.Title
        node.Description = req.Description
        node.UpdatedAt = time.Now()

        if err := s.nodeRepo.Update(ctx, node); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to update node: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Updated node: %s (ID: %d)", node.Content, node.ID)
        return node, nil</span>
}

func (s *nodeService) DeleteNode(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err := s.nodeRepo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewNodeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to delete node: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">s.logger.Printf("Deleted node with ID: %d", id)
        return nil</span>
}

func (s *nodeService) FindNodeByURL(ctx context.Context, domainID int, req *models.FindNodeByURLRequest) (*models.Node, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.URL = normalizeString(req.URL)
        if err := validateURL(req.URL); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GetNodeByDomainAndURL(ctx, domainID, req.URL)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "time"

        "url-db/internal/models"
)

type NodeAttributeRepository interface {
        Create(ctx context.Context, nodeAttribute *models.NodeAttribute) error
        GetByID(ctx context.Context, id int) (*models.NodeAttribute, error)
        GetByNodeAndAttribute(ctx context.Context, nodeID, attributeID int) (*models.NodeAttribute, error)
        ListByNode(ctx context.Context, nodeID int) ([]*models.NodeAttribute, error)
        Update(ctx context.Context, nodeAttribute *models.NodeAttribute) error
        Delete(ctx context.Context, id int) error
        ExistsByNodeAndAttribute(ctx context.Context, nodeID, attributeID int) (bool, error)
}

type nodeAttributeService struct {
        nodeAttributeRepo NodeAttributeRepository
        nodeRepo          NodeRepository
        attributeRepo     AttributeRepository
        logger            *log.Logger
}

func NewNodeAttributeService(nodeAttributeRepo NodeAttributeRepository, nodeRepo NodeRepository, attributeRepo AttributeRepository, logger *log.Logger) NodeAttributeService <span class="cov0" title="0">{
        return &amp;nodeAttributeService{
                nodeAttributeRepo: nodeAttributeRepo,
                nodeRepo:          nodeRepo,
                attributeRepo:     attributeRepo,
                logger:            logger,
        }
}</span>

func (s *nodeAttributeService) CreateNodeAttribute(ctx context.Context, nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(nodeID, "nodeID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validatePositiveInteger(req.AttributeID, "attributeID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Value = normalizeString(req.Value)

        node, err := s.nodeRepo.GetByID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeNotFoundError(nodeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, req.AttributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewAttributeNotFoundError(req.AttributeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">if node.DomainID != attribute.DomainID </span><span class="cov0" title="0">{
                return nil, NewBusinessLogicError("node and attribute must belong to the same domain")
        }</span>

        <span class="cov0" title="0">if err := validateAttributeValue(string(attribute.Type), req.Value); err != nil </span><span class="cov0" title="0">{
                return nil, NewAttributeValueInvalidError(req.AttributeID, req.Value, err.Error())
        }</span>

        <span class="cov0" title="0">exists, err := s.nodeAttributeRepo.ExistsByNodeAndAttribute(ctx, nodeID, req.AttributeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to check node attribute existence: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, NewBusinessLogicError("node attribute already exists")
        }</span>

        <span class="cov0" title="0">nodeAttribute := &amp;models.NodeAttribute{
                NodeID:      nodeID,
                AttributeID: req.AttributeID,
                Value:       req.Value,
                OrderIndex:  req.OrderIndex,
                CreatedAt:   time.Now(),
        }

        if err := s.nodeAttributeRepo.Create(ctx, nodeAttribute); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to create node attribute: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Created node attribute: node %d, attribute %d (ID: %d)", nodeID, req.AttributeID, nodeAttribute.ID)
        return nodeAttribute, nil</span>
}

func (s *nodeAttributeService) GetNodeAttribute(ctx context.Context, id int) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeAttribute, err := s.nodeAttributeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return nodeAttribute, nil</span>
}

func (s *nodeAttributeService) ListNodeAttributesByNode(ctx context.Context, nodeID int) (*models.NodeAttributeListResponse, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(nodeID, "nodeID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err := s.nodeRepo.GetByID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeNotFoundError(nodeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">nodeAttributes, err := s.nodeAttributeRepo.ListByNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to list node attributes: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeAttributeList := make([]models.NodeAttributeWithInfo, len(nodeAttributes))
        for i, nodeAttribute := range nodeAttributes </span><span class="cov0" title="0">{
                // Convert NodeAttribute to NodeAttributeWithInfo
                // This is a placeholder - in reality you'd need to fetch attribute details
                nodeAttributeList[i] = models.NodeAttributeWithInfo{
                        ID:          nodeAttribute.ID,
                        NodeID:      nodeAttribute.NodeID,
                        AttributeID: nodeAttribute.AttributeID,
                        Name:        "unknown", // Would need to fetch from attribute table
                        Type:        "string",  // Would need to fetch from attribute table
                        Value:       nodeAttribute.Value,
                        OrderIndex:  nodeAttribute.OrderIndex,
                        CreatedAt:   nodeAttribute.CreatedAt,
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.NodeAttributeListResponse{
                NodeAttributes: nodeAttributeList,
                Attributes:     nodeAttributeList, // For backward compatibility
        }, nil</span>
}

func (s *nodeAttributeService) UpdateNodeAttribute(ctx context.Context, id int, req *models.UpdateNodeAttributeRequest) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Value = normalizeString(req.Value)

        nodeAttribute, err := s.nodeAttributeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, nodeAttribute.AttributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewAttributeNotFoundError(nodeAttribute.AttributeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">if err := validateAttributeValue(string(attribute.Type), req.Value); err != nil </span><span class="cov0" title="0">{
                return nil, NewAttributeValueInvalidError(nodeAttribute.AttributeID, req.Value, err.Error())
        }</span>

        <span class="cov0" title="0">nodeAttribute.Value = req.Value
        nodeAttribute.OrderIndex = req.OrderIndex

        if err := s.nodeAttributeRepo.Update(ctx, nodeAttribute); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to update node attribute: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Updated node attribute: node %d, attribute %d (ID: %d)", nodeAttribute.NodeID, nodeAttribute.AttributeID, nodeAttribute.ID)
        return nodeAttribute, nil</span>
}

func (s *nodeAttributeService) DeleteNodeAttribute(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err := s.nodeAttributeRepo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewNodeAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to delete node attribute: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">s.logger.Printf("Deleted node attribute with ID: %d", id)
        return nil</span>
}

func (s *nodeAttributeService) ValidateNodeAttributeValue(ctx context.Context, nodeID, attributeID int, value string) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(nodeID, "nodeID"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validatePositiveInteger(attributeID, "attributeID"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">value = normalizeString(value)

        node, err := s.nodeRepo.GetByID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewNodeNotFoundError(nodeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewAttributeNotFoundError(attributeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">if node.DomainID != attribute.DomainID </span><span class="cov0" title="0">{
                return NewBusinessLogicError("node and attribute must belong to the same domain")
        }</span>

        <span class="cov0" title="0">if err := validateAttributeValue(string(attribute.Type), value); err != nil </span><span class="cov0" title="0">{
                return NewAttributeValueInvalidError(attributeID, value, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "context"
        "fmt"
)

// NodeCountService provides methods to count nodes by domain
type NodeCountService interface {
        GetNodeCountByDomain(ctx context.Context, domainID int) (int, error)
}

// NodeCountRepository interface for data access
type NodeCountRepository interface {
        CountNodesByDomain(ctx context.Context, domainID int) (int, error)
}

// nodeCountService implements NodeCountService
type nodeCountService struct {
        nodeRepo NodeCountRepository
}

// NewNodeCountService creates a new node count service
func NewNodeCountService(nodeRepo NodeCountRepository) NodeCountService <span class="cov0" title="0">{
        return &amp;nodeCountService{
                nodeRepo: nodeRepo,
        }
}</span>

// GetNodeCountByDomain returns the count of nodes for a specific domain
func (s *nodeCountService) GetNodeCountByDomain(ctx context.Context, domainID int) (int, error) <span class="cov0" title="0">{
        if domainID &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("domain ID must be positive")
        }</span>

        <span class="cov0" title="0">count, err := s.nodeRepo.CountNodesByDomain(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count nodes by domain: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "fmt"

        "url-db/internal/models"
        "url-db/internal/repositories"
)

// SubscriptionService handles business logic for subscriptions
type SubscriptionService struct {
        subscriptionRepo *repositories.SubscriptionRepository
        nodeRepo         repositories.NodeRepository
        eventRepo        *repositories.EventRepository
}

// NewSubscriptionService creates a new subscription service
func NewSubscriptionService(
        subscriptionRepo *repositories.SubscriptionRepository,
        nodeRepo repositories.NodeRepository,
        eventRepo *repositories.EventRepository,
) *SubscriptionService <span class="cov0" title="0">{
        return &amp;SubscriptionService{
                subscriptionRepo: subscriptionRepo,
                nodeRepo:         nodeRepo,
                eventRepo:        eventRepo,
        }
}</span>

// CreateSubscription creates a new subscription
func (s *SubscriptionService) CreateSubscription(nodeID int64, req *models.CreateNodeSubscriptionRequest) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        // Create subscription
        <span class="cov0" title="0">subscription := &amp;models.NodeSubscription{
                SubscriberService:  req.SubscriberService,
                SubscriberEndpoint: req.SubscriberEndpoint,
                SubscribedNodeID:   nodeID,
                EventTypes:         models.EventTypeList(req.EventTypes),
                FilterConditions:   req.FilterConditions,
                IsActive:           true,
        }

        err = s.subscriptionRepo.Create(subscription)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return subscription, nil</span>
}

// GetSubscription retrieves a subscription by ID
func (s *SubscriptionService) GetSubscription(id int64) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        subscription, err := s.subscriptionRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subscription: %w", err)
        }</span>
        <span class="cov0" title="0">if subscription == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("subscription not found")
        }</span>

        <span class="cov0" title="0">return subscription, nil</span>
}

// UpdateSubscription updates a subscription
func (s *SubscriptionService) UpdateSubscription(id int64, req *models.UpdateNodeSubscriptionRequest) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Verify subscription exists
        subscription, err := s.subscriptionRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subscription: %w", err)
        }</span>
        <span class="cov0" title="0">if subscription == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("subscription not found")
        }</span>

        // Build updates
        <span class="cov0" title="0">updates := make(map[string]interface{})

        if req.SubscriberEndpoint != nil </span><span class="cov0" title="0">{
                updates["subscriber_endpoint"] = req.SubscriberEndpoint
        }</span>

        <span class="cov0" title="0">if len(req.EventTypes) &gt; 0 </span><span class="cov0" title="0">{
                updates["event_types"] = models.EventTypeList(req.EventTypes)
        }</span>

        <span class="cov0" title="0">if req.FilterConditions != nil </span><span class="cov0" title="0">{
                updates["filter_conditions"] = req.FilterConditions
        }</span>

        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                updates["is_active"] = *req.IsActive
        }</span>

        // Update subscription
        <span class="cov0" title="0">err = s.subscriptionRepo.Update(id, updates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update subscription: %w", err)
        }</span>

        // Get updated subscription
        <span class="cov0" title="0">return s.subscriptionRepo.GetByID(id)</span>
}

// DeleteSubscription deletes a subscription
func (s *SubscriptionService) DeleteSubscription(id int64) error <span class="cov0" title="0">{
        err := s.subscriptionRepo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetNodeSubscriptions retrieves all subscriptions for a node
func (s *SubscriptionService) GetNodeSubscriptions(nodeID int64) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        <span class="cov0" title="0">return s.subscriptionRepo.GetByNode(nodeID)</span>
}

// GetServiceSubscriptions retrieves all subscriptions for a service
func (s *SubscriptionService) GetServiceSubscriptions(service string) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        return s.subscriptionRepo.GetByService(service)
}</span>

// GetAllSubscriptions retrieves all subscriptions with pagination
func (s *SubscriptionService) GetAllSubscriptions(page, pageSize int) ([]*models.NodeSubscription, int, error) <span class="cov0" title="0">{
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize
        return s.subscriptionRepo.GetAll(offset, pageSize)</span>
}

// TriggerNodeEvent creates an event and notifies relevant subscribers
func (s *SubscriptionService) TriggerNodeEvent(nodeID int64, eventType string, eventData *models.EventData) error <span class="cov0" title="0">{
        // Create event
        event := &amp;models.NodeEvent{
                NodeID:    nodeID,
                EventType: eventType,
                EventData: eventData,
        }

        err := s.eventRepo.Create(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create event: %w", err)
        }</span>

        // Get active subscriptions for this node
        <span class="cov0" title="0">subscriptions, err := s.subscriptionRepo.GetByNode(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get subscriptions: %w", err)
        }</span>

        // Filter subscriptions by event type
        <span class="cov0" title="0">for _, sub := range subscriptions </span><span class="cov0" title="0">{
                shouldNotify := false
                for _, et := range sub.EventTypes </span><span class="cov0" title="0">{
                        if et == eventType </span><span class="cov0" title="0">{
                                shouldNotify = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if shouldNotify </span><span class="cov0" title="0">{
                        // Webhook notification would be implemented here in production
                        // For now, we just acknowledge that notification should be sent
                        _ = sub.SubscriberService // Acknowledge subscription service
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "os"
        "testing"
        "time"

        "url-db/internal/models"
)

type MockDomainRepository struct {
        domains     map[int]*models.Domain
        nextID      int
        nameToID    map[string]int
        shouldError bool
}

func NewMockDomainRepository() *MockDomainRepository <span class="cov0" title="0">{
        return &amp;MockDomainRepository{
                domains:  make(map[int]*models.Domain),
                nextID:   1,
                nameToID: make(map[string]int),
        }
}</span>

func (m *MockDomainRepository) SetShouldError(shouldError bool) <span class="cov0" title="0">{
        m.shouldError = shouldError
}</span>

func (m *MockDomainRepository) Create(ctx context.Context, domain *models.Domain) error <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">domain.ID = m.nextID
        m.nextID++
        domain.CreatedAt = time.Now()
        domain.UpdatedAt = time.Now()

        m.domains[domain.ID] = domain
        m.nameToID[domain.Name] = domain.ID

        return nil</span>
}

func (m *MockDomainRepository) GetByID(ctx context.Context, id int) (*models.Domain, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">domain, exists := m.domains[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return domain, nil</span>
}

func (m *MockDomainRepository) GetByName(ctx context.Context, name string) (*models.Domain, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">id, exists := m.nameToID[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return m.domains[id], nil</span>
}

func (m *MockDomainRepository) List(ctx context.Context, page, size int) ([]*models.Domain, int, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, 0, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">var domains []*models.Domain
        for _, domain := range m.domains </span><span class="cov0" title="0">{
                domains = append(domains, domain)
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * size
        totalCount := len(domains)

        if offset &gt;= totalCount </span><span class="cov0" title="0">{
                return []*models.Domain{}, totalCount, nil
        }</span>

        <span class="cov0" title="0">end := offset + size
        if end &gt; totalCount </span><span class="cov0" title="0">{
                end = totalCount
        }</span>

        <span class="cov0" title="0">return domains[offset:end], totalCount, nil</span>
}

func (m *MockDomainRepository) Update(ctx context.Context, domain *models.Domain) error <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">_, exists := m.domains[domain.ID]
        if !exists </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">domain.UpdatedAt = time.Now()
        m.domains[domain.ID] = domain

        return nil</span>
}

func (m *MockDomainRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">domain, exists := m.domains[id]
        if !exists </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">delete(m.domains, id)
        delete(m.nameToID, domain.Name)

        return nil</span>
}

func (m *MockDomainRepository) ExistsByName(ctx context.Context, name string) (bool, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return false, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">_, exists := m.nameToID[name]
        return exists, nil</span>
}

type MockNodeRepository struct {
        nodes       map[int]*models.Node
        nextID      int
        shouldError bool
}

func NewMockNodeRepository() *MockNodeRepository <span class="cov0" title="0">{
        return &amp;MockNodeRepository{
                nodes:  make(map[int]*models.Node),
                nextID: 1,
        }
}</span>

func (m *MockNodeRepository) SetShouldError(shouldError bool) <span class="cov0" title="0">{
        m.shouldError = shouldError
}</span>

func (m *MockNodeRepository) Create(ctx context.Context, node *models.Node) error <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">node.ID = m.nextID
        m.nextID++
        node.CreatedAt = time.Now()
        node.UpdatedAt = time.Now()

        m.nodes[node.ID] = node

        return nil</span>
}

func (m *MockNodeRepository) GetByID(ctx context.Context, id int) (*models.Node, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">node, exists := m.nodes[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return node, nil</span>
}

func (m *MockNodeRepository) GetByDomainAndContent(ctx context.Context, domainID int, content string) (*models.Node, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">for _, node := range m.nodes </span><span class="cov0" title="0">{
                if node.DomainID == domainID &amp;&amp; node.Content == content </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, sql.ErrNoRows</span>
}

func (m *MockNodeRepository) ListByDomain(ctx context.Context, domainID int, page, size int, search string) ([]*models.Node, int, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, 0, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">var nodes []*models.Node
        for _, node := range m.nodes </span><span class="cov0" title="0">{
                if node.DomainID == domainID </span><span class="cov0" title="0">{
                        nodes = append(nodes, node)
                }</span>
        }

        <span class="cov0" title="0">offset := (page - 1) * size
        totalCount := len(nodes)

        if offset &gt;= totalCount </span><span class="cov0" title="0">{
                return []*models.Node{}, totalCount, nil
        }</span>

        <span class="cov0" title="0">end := offset + size
        if end &gt; totalCount </span><span class="cov0" title="0">{
                end = totalCount
        }</span>

        <span class="cov0" title="0">return nodes[offset:end], totalCount, nil</span>
}

func (m *MockNodeRepository) Update(ctx context.Context, node *models.Node) error <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">_, exists := m.nodes[node.ID]
        if !exists </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">node.UpdatedAt = time.Now()
        m.nodes[node.ID] = node

        return nil</span>
}

func (m *MockNodeRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">_, exists := m.nodes[id]
        if !exists </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">delete(m.nodes, id)

        return nil</span>
}

func (m *MockNodeRepository) ExistsByDomainAndContent(ctx context.Context, domainID int, content string) (bool, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return false, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">for _, node := range m.nodes </span><span class="cov0" title="0">{
                if node.DomainID == domainID &amp;&amp; node.Content == content </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

func CreateTestDomainService(t *testing.T) (DomainService, *MockDomainRepository) <span class="cov0" title="0">{
        mockRepo := NewMockDomainRepository()
        logger := log.New(os.Stdout, "[TEST] ", log.LstdFlags)
        service := NewDomainService(mockRepo, logger)

        return service, mockRepo
}</span>

func CreateTestNodeService(t *testing.T) (NodeService, *MockNodeRepository, *MockDomainRepository) <span class="cov0" title="0">{
        mockNodeRepo := NewMockNodeRepository()
        mockDomainRepo := NewMockDomainRepository()
        logger := log.New(os.Stdout, "[TEST] ", log.LstdFlags)
        service := NewNodeService(mockNodeRepo, mockDomainRepo, logger)

        return service, mockNodeRepo, mockDomainRepo
}</span>

func CreateTestCompositeKeyService(t *testing.T) CompositeKeyService <span class="cov0" title="0">{
        return NewCompositeKeyService("test-tool")
}</span>

func CreateTestDomain(name, description string) *models.Domain <span class="cov0" title="0">{
        return &amp;models.Domain{
                Name:        name,
                Description: description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }
}</span>

func CreateTestNode(domainID int, url, title, description string) *models.Node <span class="cov0" title="0">{
        return &amp;models.Node{
                DomainID:    domainID,
                Content:     url,
                Title:       title,
                Description: description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }
}</span>

func CreateTestAttribute(domainID int, name, attributeType, description string) *models.Attribute <span class="cov0" title="0">{
        return &amp;models.Attribute{
                DomainID:    domainID,
                Name:        name,
                Type:        models.AttributeType(attributeType),
                Description: description,
                CreatedAt:   time.Now(),
        }
}</span>

func CreateTestContext() context.Context <span class="cov0" title="0">{
        return context.Background()
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "regexp"
        "strconv"
        "strings"
)

var (
        domainNameRegex = regexp.MustCompile(`^[a-zA-Z0-9-]+$`)
        urlRegex        = regexp.MustCompile(`^https?://[^\s/$.?#].[^\s]*$`)
        emailRegex      = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
)

func validateDomainName(name string) error <span class="cov0" title="0">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("name", "domain name is required")
        }</span>
        <span class="cov0" title="0">if len(name) &gt; 255 </span><span class="cov0" title="0">{
                return NewValidationError("name", "domain name cannot exceed 255 characters")
        }</span>
        <span class="cov0" title="0">if !domainNameRegex.MatchString(name) </span><span class="cov0" title="0">{
                return NewValidationError("name", "domain name can only contain alphanumeric characters and hyphens")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateDescription(description string) error <span class="cov0" title="0">{
        if len(description) &gt; 1000 </span><span class="cov0" title="0">{
                return NewValidationError("description", "description cannot exceed 1000 characters")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateURL(url string) error <span class="cov8" title="1">{
        if len(url) == 0 </span><span class="cov8" title="1">{
                return NewValidationError("url", "URL is required")
        }</span>
        <span class="cov8" title="1">if len(url) &gt; 2000 </span><span class="cov8" title="1">{
                return NewValidationError("url", "URL cannot exceed 2000 characters")
        }</span>
        <span class="cov8" title="1">if !urlRegex.MatchString(url) </span><span class="cov8" title="1">{
                return NewValidationError("url", "invalid URL format")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateTitle(title string) error <span class="cov8" title="1">{
        if len(title) &gt; 500 </span><span class="cov8" title="1">{
                return NewValidationError("title", "title cannot exceed 500 characters")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateAttributeName(name string) error <span class="cov8" title="1">{
        if len(name) == 0 </span><span class="cov8" title="1">{
                return NewValidationError("name", "attribute name is required")
        }</span>
        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov0" title="0">{
                return NewValidationError("name", "attribute name cannot exceed 255 characters")
        }</span>
        <span class="cov8" title="1">if !regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).MatchString(name) </span><span class="cov8" title="1">{
                return NewValidationError("name", "attribute name can only contain alphanumeric characters, underscores, and hyphens")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateAttributeType(attributeType string) error <span class="cov8" title="1">{
        validTypes := []string{"tag", "ordered_tag", "number", "string", "markdown", "image"}
        for _, validType := range validTypes </span><span class="cov8" title="1">{
                if attributeType == validType </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return NewValidationError("type", "invalid attribute type")</span>
}

func validateAttributeValue(attributeType, value string) error <span class="cov0" title="0">{
        if len(value) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("value", "attribute value is required")
        }</span>

        <span class="cov0" title="0">switch attributeType </span>{
        case "tag", "ordered_tag":<span class="cov0" title="0">
                if len(value) &gt; 100 </span><span class="cov0" title="0">{
                        return NewValidationError("value", "tag value cannot exceed 100 characters")
                }</span>
                <span class="cov0" title="0">if !regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).MatchString(value) </span><span class="cov0" title="0">{
                        return NewValidationError("value", "tag value can only contain alphanumeric characters, underscores, and hyphens")
                }</span>
        case "number":<span class="cov0" title="0">
                if _, err := strconv.ParseFloat(value, 64); err != nil </span><span class="cov0" title="0">{
                        return NewValidationError("value", "number value must be a valid number")
                }</span>
        case "string":<span class="cov0" title="0">
                if len(value) &gt; 1000 </span><span class="cov0" title="0">{
                        return NewValidationError("value", "string value cannot exceed 1000 characters")
                }</span>
        case "markdown":<span class="cov0" title="0">
                if len(value) &gt; 10000 </span><span class="cov0" title="0">{
                        return NewValidationError("value", "markdown value cannot exceed 10000 characters")
                }</span>
        case "image":<span class="cov0" title="0">
                if len(value) &gt; 500 </span><span class="cov0" title="0">{
                        return NewValidationError("value", "image URL cannot exceed 500 characters")
                }</span>
                <span class="cov0" title="0">if !urlRegex.MatchString(value) </span><span class="cov0" title="0">{
                        return NewValidationError("value", "image value must be a valid URL")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func validatePositiveInteger(value int, fieldName string) error <span class="cov8" title="1">{
        if value &lt;= 0 </span><span class="cov8" title="1">{
                return NewValidationError(fieldName, fieldName+" must be a positive integer")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validatePaginationParams(page, size int) (int, int, error) <span class="cov8" title="1">{
        if page &lt; 1 </span><span class="cov8" title="1">{
                page = 1
        }</span>
        <span class="cov8" title="1">if size &lt; 1 </span><span class="cov8" title="1">{
                size = 20
        }</span>
        <span class="cov8" title="1">if size &gt; 100 </span><span class="cov8" title="1">{
                size = 100
        }</span>
        <span class="cov8" title="1">return page, size, nil</span>
}

func normalizeString(s string) string <span class="cov8" title="1">{
        return strings.TrimSpace(s)
}</span>

func generateTitleFromURL(url string) string <span class="cov8" title="1">{
        parts := strings.Split(url, "/")
        if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                domain := parts[2]
                if len(parts) &gt; 3 </span><span class="cov8" title="1">{
                        path := parts[len(parts)-1]
                        if path != "" </span><span class="cov8" title="1">{
                                return strings.Title(strings.ReplaceAll(path, "-", " "))
                        }</span>
                }
                <span class="cov8" title="1">return strings.Title(domain)</span>
        }
        <span class="cov8" title="1">return "Untitled"</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package attributes

import "url-db/internal/models"

// AttributeType aliases for internal use
type AttributeType = models.AttributeType

const (
        AttributeTypeTag        = models.AttributeTypeTag
        AttributeTypeOrderedTag = models.AttributeTypeOrderedTag
        AttributeTypeNumber     = models.AttributeTypeNumber
        AttributeTypeString     = models.AttributeTypeString
        AttributeTypeMarkdown   = models.AttributeTypeMarkdown
        AttributeTypeImage      = models.AttributeTypeImage
)

// IsValidAttributeType checks if the given attribute type is valid
func IsValidAttributeType(t AttributeType) bool <span class="cov8" title="1">{
        switch t </span>{
        case AttributeTypeTag, AttributeTypeOrderedTag, AttributeTypeNumber,
                AttributeTypeString, AttributeTypeMarkdown, AttributeTypeImage:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// GetSupportedAttributeTypes returns a list of all supported attribute types
func GetSupportedAttributeTypes() []AttributeType <span class="cov0" title="0">{
        return []AttributeType{
                AttributeTypeTag,
                AttributeTypeOrderedTag,
                AttributeTypeNumber,
                AttributeTypeString,
                AttributeTypeMarkdown,
                AttributeTypeImage,
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package attributes

import (
        "fmt"
        "net/url"
        "regexp"
        "strconv"
        "strings"
)

// AttributeValueValidator validates attribute values based on their type
type AttributeValueValidator interface {
        Validate(value string, orderIndex *int) error
}

// TagValidator validates tag attribute values
type TagValidator struct{}

func (v *TagValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 255 </span><span class="cov8" title="1">{
                return ErrValueTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// OrderedTagValidator validates ordered tag attribute values
type OrderedTagValidator struct{}

func (v *OrderedTagValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 255 </span><span class="cov8" title="1">{
                return ErrValueTooLong
        }</span>
        <span class="cov8" title="1">if orderIndex == nil </span><span class="cov8" title="1">{
                return ErrOrderIndexRequired
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NumberValidator validates number attribute values
type NumberValidator struct{}

func (v *NumberValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>

        // Try to parse as float64 to validate it's a number
        <span class="cov8" title="1">_, err := strconv.ParseFloat(value, 64)
        if err != nil </span><span class="cov8" title="1">{
                return ErrInvalidNumber
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// StringValidator validates string attribute values
type StringValidator struct{}

func (v *StringValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 2048 </span><span class="cov8" title="1">{
                return ErrValueTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// MarkdownValidator validates markdown attribute values
type MarkdownValidator struct{}

var (
        // Basic markdown patterns - we'll do simple validation
        markdownHeaderPattern = regexp.MustCompile(`^#{1,6}\s+.+$`)
        markdownLinkPattern   = regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)
        markdownCodePattern   = regexp.MustCompile("```[\\s\\S]*?```|`[^`]+`")
        markdownBoldPattern   = regexp.MustCompile(`\*\*[^*]+\*\*|__[^_]+__`)
        markdownItalicPattern = regexp.MustCompile(`\*[^*]+\*|_[^_]+_`)
)

func (v *MarkdownValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 10000 </span><span class="cov8" title="1">{ // Larger limit for markdown
                return ErrValueTooLong
        }</span>

        // Basic markdown syntax validation
        <span class="cov8" title="1">lines := strings.Split(value, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for malformed markdown links
                <span class="cov8" title="1">if strings.Contains(line, "](") </span><span class="cov8" title="1">{
                        matches := markdownLinkPattern.FindAllString(line, -1)
                        for _, match := range matches </span><span class="cov8" title="1">{
                                if !isValidMarkdownLink(match) </span><span class="cov0" title="0">{
                                        return ErrInvalidMarkdown
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func isValidMarkdownLink(link string) bool <span class="cov8" title="1">{
        // Extract URL from markdown link pattern [text](url)
        re := regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)
        matches := re.FindStringSubmatch(link)
        if len(matches) &lt; 3 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">urlStr := matches[2]

        // Allow relative URLs and anchors
        if strings.HasPrefix(urlStr, "#") || strings.HasPrefix(urlStr, "/") || strings.HasPrefix(urlStr, "./") || strings.HasPrefix(urlStr, "../") </span><span class="cov8" title="1">{
                return true
        }</span>

        // Validate absolute URLs
        <span class="cov8" title="1">_, err := url.Parse(urlStr)
        return err == nil</span>
}

// ImageValidator validates image URL attribute values
type ImageValidator struct{}

var (
        // Common image extensions
        imageExtensions = []string{".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".svg", ".ico"}
)

func (v *ImageValidator) Validate(value string, orderIndex *int) error <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return ErrValueRequired
        }</span>
        <span class="cov8" title="1">if len(value) &gt; 2048 </span><span class="cov8" title="1">{
                return ErrValueTooLong
        }</span>

        // Parse URL
        <span class="cov8" title="1">parsedURL, err := url.Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                return ErrInvalidURL
        }</span>

        // Must be absolute URL for images
        <span class="cov8" title="1">if !parsedURL.IsAbs() </span><span class="cov8" title="1">{
                return ErrInvalidURL
        }</span>

        // Check scheme
        <span class="cov8" title="1">if parsedURL.Scheme != "http" &amp;&amp; parsedURL.Scheme != "https" </span><span class="cov8" title="1">{
                return ErrInvalidURL
        }</span>

        // Check if it looks like an image (has image extension or is from known image hosting)
        <span class="cov8" title="1">if !isValidImageURL(parsedURL) </span><span class="cov0" title="0">{
                return ErrInvalidURL
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func isValidImageURL(parsedURL *url.URL) bool <span class="cov8" title="1">{
        path := strings.ToLower(parsedURL.Path)

        // Check file extension
        for _, ext := range imageExtensions </span><span class="cov8" title="1">{
                if strings.HasSuffix(path, ext) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Check for known image hosting services
        <span class="cov8" title="1">host := strings.ToLower(parsedURL.Host)
        imageHosts := []string{
                "imgur.com", "i.imgur.com",
                "images.unsplash.com", "unsplash.com",
                "pixabay.com", "images.pexels.com",
                "cdn.pixabay.com", "images.pixabay.com",
                "gravatar.com", "s.gravatar.com",
                "githubusercontent.com",
                "googleusercontent.com",
                "cloudinary.com",
                "amazonaws.com", // S3 buckets
                "cloudfront.net",
        }

        for _, imageHost := range imageHosts </span><span class="cov8" title="1">{
                if strings.Contains(host, imageHost) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ValidatorFactory creates validators for different attribute types
type ValidatorFactory struct{}

func NewValidatorFactory() *ValidatorFactory <span class="cov8" title="1">{
        return &amp;ValidatorFactory{}
}</span>

func (f *ValidatorFactory) GetValidator(attrType AttributeType) (AttributeValueValidator, error) <span class="cov8" title="1">{
        switch attrType </span>{
        case AttributeTypeTag:<span class="cov8" title="1">
                return &amp;TagValidator{}, nil</span>
        case AttributeTypeOrderedTag:<span class="cov8" title="1">
                return &amp;OrderedTagValidator{}, nil</span>
        case AttributeTypeNumber:<span class="cov8" title="1">
                return &amp;NumberValidator{}, nil</span>
        case AttributeTypeString:<span class="cov8" title="1">
                return &amp;StringValidator{}, nil</span>
        case AttributeTypeMarkdown:<span class="cov8" title="1">
                return &amp;MarkdownValidator{}, nil</span>
        case AttributeTypeImage:<span class="cov8" title="1">
                return &amp;ImageValidator{}, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported attribute type: %s", attrType)</span>
        }
}

// ValidateAttributeValue validates a value against the given attribute type
func ValidateAttributeValue(attrType AttributeType, value string, orderIndex *int) error <span class="cov8" title="1">{
        factory := NewValidatorFactory()
        validator, err := factory.GetValidator(attrType)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return validator.Validate(value, orderIndex)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package database

import "time"

type Config struct {
        URL             string
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
        WALMode         bool
        ForeignKeys     bool
        JournalMode     string
        Synchronous     string
}

func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                URL:             "file:./app.db",
                MaxOpenConns:    10,
                MaxIdleConns:    5,
                ConnMaxLifetime: time.Hour,
                WALMode:         true,
                ForeignKeys:     true,
                JournalMode:     "WAL",
                Synchronous:     "NORMAL",
        }
}</span>

func TestConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                URL:             ":memory:",
                MaxOpenConns:    1,
                MaxIdleConns:    1,
                ConnMaxLifetime: time.Hour,
                WALMode:         false,
                ForeignKeys:     true,
                JournalMode:     "DELETE",
                Synchronous:     "OFF",
        }
}</span>

func ProductionConfig(dbPath string) *Config <span class="cov8" title="1">{
        return &amp;Config{
                URL:             "file:" + dbPath,
                MaxOpenConns:    100,
                MaxIdleConns:    50,
                ConnMaxLifetime: time.Hour,
                WALMode:         true,
                ForeignKeys:     true,
                JournalMode:     "WAL",
                Synchronous:     "FULL",
        }
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"

        _ "github.com/mattn/go-sqlite3"
)

// Schema file path relative to project root
const schemaFilePath = "schema.sql"

type Database struct {
        db     *sql.DB
        config *Config
}

func New(config *Config) (*Database, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultConfig()
        }</span>

        <span class="cov8" title="1">db, err := sql.Open("sqlite3", config.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov8" title="1">if err := configureDatabase(db, config); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to configure database: %w", err)
        }</span>

        <span class="cov8" title="1">database := &amp;Database{
                db:     db,
                config: config,
        }

        if err := database.createSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to create schema: %w", err)
        }</span>

        <span class="cov8" title="1">return database, nil</span>
}

func configureDatabase(db *sql.DB, config *Config) error <span class="cov8" title="1">{
        db.SetMaxOpenConns(config.MaxOpenConns)
        db.SetMaxIdleConns(config.MaxIdleConns)
        db.SetConnMaxLifetime(config.ConnMaxLifetime)

        pragmas := []string{
                fmt.Sprintf("PRAGMA journal_mode = %s", config.JournalMode),
                fmt.Sprintf("PRAGMA synchronous = %s", config.Synchronous),
        }

        if config.ForeignKeys </span><span class="cov8" title="1">{
                pragmas = append(pragmas, "PRAGMA foreign_keys = ON")
        }</span>

        <span class="cov8" title="1">if config.WALMode </span><span class="cov8" title="1">{
                pragmas = append(pragmas, "PRAGMA journal_mode = WAL")
        }</span>

        <span class="cov8" title="1">for _, pragma := range pragmas </span><span class="cov8" title="1">{
                if _, err := db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute pragma %s: %w", pragma, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (d *Database) createSchema() error <span class="cov8" title="1">{
        // Load schema from external file
        schema, err := d.loadSchemaFromFile()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to inline schema if file not found
                fmt.Fprintf(os.Stderr, "Warning: Could not load schema.sql file, using inline schema: %v\n", err)
                schema = d.getInlineSchema()
        }</span>

        <span class="cov8" title="1">if _, err := d.db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute schema: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadSchemaFromFile loads schema from external schema.sql file
func (d *Database) loadSchemaFromFile() (string, error) <span class="cov8" title="1">{
        // Find project root by looking for go.mod
        projectRoot, err := findProjectRoot()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not find project root: %w", err)
        }</span>

        <span class="cov8" title="1">schemaPath := filepath.Join(projectRoot, schemaFilePath)
        schemaBytes, err := os.ReadFile(schemaPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not read schema file %s: %w", schemaPath, err)
        }</span>

        <span class="cov8" title="1">return string(schemaBytes), nil</span>
}

// findProjectRoot finds the project root by looking for go.mod file
func findProjectRoot() (string, error) <span class="cov8" title="1">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Walk up the directory tree looking for go.mod
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov8" title="1">{
                        return dir, nil
                }</span>

                <span class="cov8" title="1">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        break</span> // reached root directory
                }
                <span class="cov8" title="1">dir = parent</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("go.mod not found")</span>
}

// getInlineSchema returns the inline schema as fallback
func (d *Database) getInlineSchema() string <span class="cov0" title="0">{
        return `
        -- 도메인 폴더 테이블
        CREATE TABLE IF NOT EXISTS domains (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- 노드 테이블 (URL 등의 컨텐츠 저장)
        CREATE TABLE IF NOT EXISTS nodes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                content TEXT NOT NULL,
                domain_id INTEGER NOT NULL,
                title TEXT,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE,
                UNIQUE(content, domain_id)
        );

        -- 속성 정의 테이블
        CREATE TABLE IF NOT EXISTS attributes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                domain_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                type TEXT NOT NULL CHECK (type IN ('tag', 'ordered_tag', 'number', 'string', 'markdown', 'image')),
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE,
                UNIQUE(domain_id, name)
        );

        -- 노드 속성 값 테이블
        CREATE TABLE IF NOT EXISTS node_attributes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                node_id INTEGER NOT NULL,
                attribute_id INTEGER NOT NULL,
                value TEXT NOT NULL,
                order_index INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (attribute_id) REFERENCES attributes(id) ON DELETE CASCADE
        );

        -- 노드 간 연결관계 테이블
        CREATE TABLE IF NOT EXISTS node_connections (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source_node_id INTEGER NOT NULL,
                target_node_id INTEGER NOT NULL,
                relationship_type TEXT NOT NULL,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (source_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (target_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                UNIQUE(source_node_id, target_node_id, relationship_type)
        );

        -- 노드 구독 테이블 (이벤트 구독 관리)
        CREATE TABLE IF NOT EXISTS node_subscriptions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                subscriber_service TEXT NOT NULL,
                subscriber_endpoint TEXT,
                subscribed_node_id INTEGER NOT NULL,
                event_types TEXT NOT NULL, -- JSON array of event types
                filter_conditions TEXT,    -- JSON object for filter conditions
                is_active BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (subscribed_node_id) REFERENCES nodes(id) ON DELETE CASCADE
        );

        -- 의존성 타입 레지스트리
        CREATE TABLE IF NOT EXISTS dependency_types (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                type_name TEXT NOT NULL UNIQUE,
                category TEXT NOT NULL, -- 'structural', 'behavioral', 'data'
                cascade_delete BOOLEAN DEFAULT FALSE,
                cascade_update BOOLEAN DEFAULT FALSE,
                validation_required BOOLEAN DEFAULT TRUE,
                metadata_schema TEXT, -- JSON schema for type-specific metadata
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- 노드 의존성 테이블 (기존 호환성용)
        CREATE TABLE IF NOT EXISTS node_dependencies (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                dependent_node_id INTEGER NOT NULL,
                dependency_node_id INTEGER NOT NULL,
                dependency_type TEXT NOT NULL,
                cascade_delete BOOLEAN DEFAULT FALSE,
                cascade_update BOOLEAN DEFAULT FALSE,
                metadata TEXT, -- JSON metadata
                description TEXT,
                is_required BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (dependent_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (dependency_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                UNIQUE(dependent_node_id, dependency_node_id, dependency_type)
        );

        -- 고도화된 노드 의존성 테이블 V2
        CREATE TABLE IF NOT EXISTS node_dependencies_v2 (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                dependent_node_id INTEGER NOT NULL,
                dependency_node_id INTEGER NOT NULL,
                dependency_type_id INTEGER NOT NULL,
                strength INTEGER DEFAULT 50, -- 0-100, dependency strength
                priority INTEGER DEFAULT 50, -- 0-100, resolution priority
                metadata TEXT, -- JSON: type-specific metadata
                version_constraint TEXT, -- Semantic versioning constraint
                is_required BOOLEAN DEFAULT TRUE,
                is_active BOOLEAN DEFAULT TRUE,
                valid_from DATETIME DEFAULT CURRENT_TIMESTAMP,
                valid_until DATETIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                created_by TEXT,
                FOREIGN KEY (dependent_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (dependency_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (dependency_type_id) REFERENCES dependency_types(id),
                UNIQUE(dependent_node_id, dependency_node_id, dependency_type_id, valid_from)
        );

        -- 의존성 히스토리 추적
        CREATE TABLE IF NOT EXISTS dependency_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                dependency_id INTEGER NOT NULL,
                action TEXT NOT NULL, -- 'created', 'updated', 'deleted', 'activated', 'deactivated'
                previous_state TEXT, -- JSON: previous dependency state
                new_state TEXT, -- JSON: new dependency state
                change_reason TEXT,
                changed_by TEXT,
                changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (dependency_id) REFERENCES node_dependencies_v2(id)
        );

        -- 의존성 그래프 캐시
        CREATE TABLE IF NOT EXISTS dependency_graph_cache (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                node_id INTEGER NOT NULL,
                graph_data TEXT NOT NULL, -- JSON: pre-computed dependency graph
                depth INTEGER DEFAULT 0, -- Max depth in dependency tree
                total_dependencies INTEGER DEFAULT 0,
                total_dependents INTEGER DEFAULT 0,
                has_circular BOOLEAN DEFAULT FALSE,
                computed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                expires_at DATETIME,
                FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE
        );

        -- 의존성 검증 규칙
        CREATE TABLE IF NOT EXISTS dependency_rules (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                domain_id INTEGER,
                rule_name TEXT NOT NULL,
                rule_type TEXT NOT NULL, -- 'circular_prevention', 'max_depth', 'type_compatibility'
                rule_config TEXT NOT NULL, -- JSON: rule configuration
                is_active BOOLEAN DEFAULT TRUE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE
        );

        -- 의존성 영향 분석 결과
        CREATE TABLE IF NOT EXISTS dependency_impact_analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source_node_id INTEGER NOT NULL,
                impact_type TEXT NOT NULL, -- 'delete', 'update', 'version_change'
                affected_nodes TEXT NOT NULL, -- JSON: array of affected node IDs with impact details
                impact_score INTEGER, -- 0-100, overall impact severity
                analysis_metadata TEXT, -- JSON: detailed analysis results
                analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (source_node_id) REFERENCES nodes(id) ON DELETE CASCADE
        );

        -- 인덱스 생성
        CREATE INDEX IF NOT EXISTS idx_nodes_domain ON nodes(domain_id);
        CREATE INDEX IF NOT EXISTS idx_nodes_content ON nodes(content);
        CREATE INDEX IF NOT EXISTS idx_attributes_domain ON attributes(domain_id);
        CREATE INDEX IF NOT EXISTS idx_node_attributes_node ON node_attributes(node_id);
        CREATE INDEX IF NOT EXISTS idx_node_attributes_attribute ON node_attributes(attribute_id);
        CREATE INDEX IF NOT EXISTS idx_node_connections_source ON node_connections(source_node_id);
        CREATE INDEX IF NOT EXISTS idx_node_connections_target ON node_connections(target_node_id);
        CREATE INDEX IF NOT EXISTS idx_node_subscriptions_node ON node_subscriptions(subscribed_node_id);
        CREATE INDEX IF NOT EXISTS idx_node_subscriptions_service ON node_subscriptions(subscriber_service);
        -- 기존 의존성 인덱스
        CREATE INDEX IF NOT EXISTS idx_node_dependencies_dependent ON node_dependencies(dependent_node_id);
        CREATE INDEX IF NOT EXISTS idx_node_dependencies_dependency ON node_dependencies(dependency_node_id);
        
        -- 고도화된 의존성 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_v2_dependent ON node_dependencies_v2(dependent_node_id);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_dependency ON node_dependencies_v2(dependency_node_id);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_type ON node_dependencies_v2(dependency_type_id);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_active ON node_dependencies_v2(is_active);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_valid_from ON node_dependencies_v2(valid_from);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_valid_until ON node_dependencies_v2(valid_until);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_strength ON node_dependencies_v2(strength);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_priority ON node_dependencies_v2(priority);
        
        -- 의존성 히스토리 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_history_dep ON dependency_history(dependency_id);
        CREATE INDEX IF NOT EXISTS idx_deps_history_action ON dependency_history(action);
        CREATE INDEX IF NOT EXISTS idx_deps_history_changed_at ON dependency_history(changed_at);
        
        -- 의존성 그래프 캐시 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_cache_node ON dependency_graph_cache(node_id);
        CREATE INDEX IF NOT EXISTS idx_deps_cache_expires ON dependency_graph_cache(expires_at);
        CREATE INDEX IF NOT EXISTS idx_deps_cache_computed ON dependency_graph_cache(computed_at);
        
        -- 의존성 영향 분석 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_impact_source ON dependency_impact_analysis(source_node_id);
        CREATE INDEX IF NOT EXISTS idx_deps_impact_type ON dependency_impact_analysis(impact_type);
        CREATE INDEX IF NOT EXISTS idx_deps_impact_analyzed ON dependency_impact_analysis(analyzed_at);
        
        -- 의존성 타입 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_types_name ON dependency_types(type_name);
        CREATE INDEX IF NOT EXISTS idx_deps_types_category ON dependency_types(category);
        
        -- 의존성 규칙 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_rules_domain ON dependency_rules(domain_id);
        CREATE INDEX IF NOT EXISTS idx_deps_rules_type ON dependency_rules(rule_type);
        CREATE INDEX IF NOT EXISTS idx_deps_rules_active ON dependency_rules(is_active);

        -- 트리거: updated_at 자동 업데이트
        CREATE TRIGGER IF NOT EXISTS domains_updated_at 
                AFTER UPDATE ON domains 
                FOR EACH ROW 
                BEGIN 
                        UPDATE domains SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
                END;

        CREATE TRIGGER IF NOT EXISTS nodes_updated_at 
                AFTER UPDATE ON nodes 
                FOR EACH ROW 
                BEGIN 
                        UPDATE nodes SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
                END;

        CREATE TRIGGER IF NOT EXISTS node_subscriptions_updated_at 
                AFTER UPDATE ON node_subscriptions 
                FOR EACH ROW 
                BEGIN 
                        UPDATE node_subscriptions SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
                END;

        -- 노드 이벤트 로그 테이블
        CREATE TABLE IF NOT EXISTS node_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                node_id INTEGER NOT NULL,
                event_type TEXT NOT NULL,             -- 'created', 'updated', 'deleted', 'attribute_changed'
                event_data TEXT,                      -- JSON: 이벤트 상세 데이터
                occurred_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                processed_at DATETIME,                -- 처리 완료 시간
                FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE
        );

        -- 이벤트 테이블 인덱스
        CREATE INDEX IF NOT EXISTS idx_events_node ON node_events(node_id);
        CREATE INDEX IF NOT EXISTS idx_events_type ON node_events(event_type);
        CREATE INDEX IF NOT EXISTS idx_events_occurred ON node_events(occurred_at);
        CREATE INDEX IF NOT EXISTS idx_events_unprocessed ON node_events(processed_at) WHERE processed_at IS NULL;

        -- 기본 의존성 타입 데이터 초기화
        INSERT OR IGNORE INTO dependency_types (type_name, category, cascade_delete, cascade_update, validation_required, description) VALUES
                ('hard', 'structural', true, true, true, 'Strong coupling dependency with cascading operations'),
                ('soft', 'structural', false, false, true, 'Loose coupling dependency without cascading'),
                ('reference', 'structural', false, false, false, 'Informational reference link only'),
                ('runtime', 'behavioral', false, true, true, 'Required at runtime execution'),
                ('compile', 'behavioral', false, false, true, 'Required at build/compile time'),
                ('optional', 'behavioral', false, false, false, 'Optional enhancement dependency'),
                ('sync', 'data', false, true, true, 'Synchronous data dependency'),
                ('async', 'data', false, false, false, 'Asynchronous data dependency');
        `
}</span>

func (d *Database) DB() *sql.DB <span class="cov8" title="1">{
        return d.db
}</span>

func (d *Database) Close() error <span class="cov8" title="1">{
        if d.db != nil </span><span class="cov8" title="1">{
                return d.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *Database) Ping() error <span class="cov8" title="1">{
        return d.db.Ping()
}</span>

func (d *Database) WithTransaction(fn func(*sql.Tx) error) error <span class="cov8" title="1">{
        tx, err := d.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        panic(r)</span>
                }
        }()

        <span class="cov8" title="1">if err := fn(tx); err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

// InitDB initializes the database with the given URL
func InitDB(url string) (*Database, error) <span class="cov0" title="0">{
        config := DefaultConfig()
        config.URL = url
        return New(config)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package domains

import "errors"

var (
        ErrDomainNotFound        = errors.New("domain not found")
        ErrDomainAlreadyExists   = errors.New("domain already exists")
        ErrDomainNameInvalid     = errors.New("domain name is invalid")
        ErrDomainHasDependencies = errors.New("domain has dependencies and cannot be deleted")
        ErrValidation            = errors.New("validation error")
)

const (
        ErrorCodeDomainNotFound        = "DOMAIN_NOT_FOUND"
        ErrorCodeDomainAlreadyExists   = "DOMAIN_ALREADY_EXISTS"
        ErrorCodeDomainNameInvalid     = "DOMAIN_NAME_INVALID"
        ErrorCodeDomainHasDependencies = "DOMAIN_HAS_DEPENDENCIES"
        ErrorCodeValidation            = "VALIDATION_ERROR"
)

type DomainError struct {
        Code    string
        Message string
        Err     error
}

func (e *DomainError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func (e *DomainError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

func NewDomainError(code, message string, err error) *DomainError <span class="cov0" title="0">{
        return &amp;DomainError{
                Code:    code,
                Message: message,
                Err:     err,
        }
}</span>

func NewValidationError(message string) *DomainError <span class="cov0" title="0">{
        return &amp;DomainError{
                Code:    ErrorCodeValidation,
                Message: message,
                Err:     ErrValidation,
        }
}</span>

func NewDomainNotFoundError(id int) *DomainError <span class="cov0" title="0">{
        return &amp;DomainError{
                Code:    ErrorCodeDomainNotFound,
                Message: "Domain not found",
                Err:     ErrDomainNotFound,
        }
}</span>

func NewDomainAlreadyExistsError(name string) *DomainError <span class="cov0" title="0">{
        return &amp;DomainError{
                Code:    ErrorCodeDomainAlreadyExists,
                Message: "Domain already exists",
                Err:     ErrDomainAlreadyExists,
        }
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package domains

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type DomainHandler struct {
        service DomainService
}

func NewDomainHandler(service DomainService) *DomainHandler <span class="cov0" title="0">{
        return &amp;DomainHandler{service: service}
}</span>

func (h *DomainHandler) RegisterRoutes(router *gin.RouterGroup) <span class="cov0" title="0">{
        router.POST("/domains", h.CreateDomain)
        router.GET("/domains", h.ListDomains)
        router.GET("/domains/:id", h.GetDomain)
        router.PUT("/domains/:id", h.UpdateDomain)
        router.DELETE("/domains/:id", h.DeleteDomain)
}</span>

// CreateDomain godoc
// @Summary      Create a new domain
// @Description  Create a new domain with name and description
// @Tags         domains
// @Accept       json
// @Produce      json
// @Param        domain  body      models.CreateDomainRequest  true  "Domain data"
// @Success      201     {object}  models.Domain
// @Failure      400     {object}  map[string]interface{}
// @Failure      409     {object}  map[string]interface{}
// @Failure      500     {object}  map[string]interface{}
// @Router       /domains [post]
func (h *DomainHandler) CreateDomain(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateDomainRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.service.CreateDomain(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if strings.HasPrefix(err.Error(), "validation_error:") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "validation_error",
                                "message": strings.TrimPrefix(err.Error(), "validation_error: "),
                        })
                        return
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(err.Error(), "conflict:") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{
                                "error":   "conflict",
                                "message": strings.TrimPrefix(err.Error(), "conflict: "),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "internal_error",
                        "message": "Failed to create domain",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, domain)</span>
}

// GetDomain godoc
// @Summary      Get a domain
// @Description  Get domain by ID
// @Tags         domains
// @Produce      json
// @Param        id   path      int  true  "Domain ID"
// @Success      200  {object}  models.Domain
// @Failure      400  {object}  map[string]interface{}
// @Failure      404  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /domains/{id} [get]
func (h *DomainHandler) GetDomain(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.service.GetDomain(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if strings.HasPrefix(err.Error(), "not_found:") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": strings.TrimPrefix(err.Error(), "not_found: "),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "internal_error",
                        "message": "Failed to get domain",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, domain)</span>
}

// ListDomains godoc
// @Summary      List domains
// @Description  Get all domains with pagination
// @Tags         domains
// @Produce      json
// @Param        page  query     int  false  "Page number"  default(1)
// @Param        size  query     int  false  "Page size"    default(20)
// @Success      200   {object}  models.DomainListResponse
// @Failure      500   {object}  map[string]interface{}
// @Router       /domains [get]
func (h *DomainHandler) ListDomains(c *gin.Context) <span class="cov0" title="0">{
        page := 1
        size := 20

        if pageStr := c.Query("page"); pageStr != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(pageStr); err == nil &amp;&amp; p &gt; 0 </span><span class="cov0" title="0">{
                        page = p
                }</span>
        }

        <span class="cov0" title="0">if sizeStr := c.Query("size"); sizeStr != "" </span><span class="cov0" title="0">{
                if s, err := strconv.Atoi(sizeStr); err == nil &amp;&amp; s &gt; 0 &amp;&amp; s &lt;= 100 </span><span class="cov0" title="0">{
                        size = s
                }</span>
        }

        <span class="cov0" title="0">response, err := h.service.ListDomains(c.Request.Context(), page, size)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "internal_error",
                        "message": "Failed to list domains",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// UpdateDomain godoc
// @Summary      Update a domain
// @Description  Update domain description by ID
// @Tags         domains
// @Accept       json
// @Produce      json
// @Param        id      path      int                        true  "Domain ID"
// @Param        domain  body      models.UpdateDomainRequest true  "Updated domain data"
// @Success      200     {object}  models.Domain
// @Failure      400     {object}  map[string]interface{}
// @Failure      404     {object}  map[string]interface{}
// @Failure      500     {object}  map[string]interface{}
// @Router       /domains/{id} [put]
func (h *DomainHandler) UpdateDomain(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateDomainRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.service.UpdateDomain(c.Request.Context(), id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if strings.HasPrefix(err.Error(), "validation_error:") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "validation_error",
                                "message": strings.TrimPrefix(err.Error(), "validation_error: "),
                        })
                        return
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(err.Error(), "not_found:") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": strings.TrimPrefix(err.Error(), "not_found: "),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "internal_error",
                        "message": "Failed to update domain",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, domain)</span>
}

// DeleteDomain godoc
// @Summary      Delete a domain
// @Description  Delete domain by ID
// @Tags         domains
// @Param        id  path  int  true  "Domain ID"
// @Success      204
// @Failure      400  {object}  map[string]interface{}
// @Failure      404  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /domains/{id} [delete]
func (h *DomainHandler) DeleteDomain(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.service.DeleteDomain(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if strings.HasPrefix(err.Error(), "not_found:") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": strings.TrimPrefix(err.Error(), "not_found: "),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "internal_error",
                        "message": "Failed to delete domain",
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package domains

import (
        "context"
        "database/sql"

        "url-db/internal/models"
)

type DomainRepository interface {
        Create(ctx context.Context, domain *models.Domain) error
        GetByID(ctx context.Context, id int) (*models.Domain, error)
        GetByName(ctx context.Context, name string) (*models.Domain, error)
        List(ctx context.Context, page, size int) ([]*models.Domain, int, error)
        Update(ctx context.Context, domain *models.Domain) error
        Delete(ctx context.Context, id int) error
        ExistsByName(ctx context.Context, name string) (bool, error)
}

type domainRepository struct {
        db *sql.DB
}

func NewDomainRepository(db *sql.DB) DomainRepository <span class="cov0" title="0">{
        return &amp;domainRepository{db: db}
}</span>

func (r *domainRepository) Create(ctx context.Context, domain *models.Domain) error <span class="cov0" title="0">{
        query := `
                INSERT INTO domains (name, description, created_at, updated_at)
                VALUES (?, ?, datetime('now'), datetime('now'))
                RETURNING id, created_at, updated_at
        `

        row := r.db.QueryRowContext(ctx, query, domain.Name, domain.Description)
        return row.Scan(&amp;domain.ID, &amp;domain.CreatedAt, &amp;domain.UpdatedAt)
}</span>

func (r *domainRepository) GetByID(ctx context.Context, id int) (*models.Domain, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM domains
                WHERE id = ?
        `

        domain := &amp;models.Domain{}
        row := r.db.QueryRowContext(ctx, query, id)
        err := row.Scan(&amp;domain.ID, &amp;domain.Name, &amp;domain.Description, &amp;domain.CreatedAt, &amp;domain.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return domain, nil</span>
}

func (r *domainRepository) GetByName(ctx context.Context, name string) (*models.Domain, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM domains
                WHERE name = ?
        `

        domain := &amp;models.Domain{}
        row := r.db.QueryRowContext(ctx, query, name)
        err := row.Scan(&amp;domain.ID, &amp;domain.Name, &amp;domain.Description, &amp;domain.CreatedAt, &amp;domain.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return domain, nil</span>
}

func (r *domainRepository) List(ctx context.Context, page, size int) ([]*models.Domain, int, error) <span class="cov0" title="0">{
        offset := (page - 1) * size

        // Get total count
        countQuery := `SELECT COUNT(*) FROM domains`
        var totalCount int
        err := r.db.QueryRowContext(ctx, countQuery).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get domains with pagination
        <span class="cov0" title="0">query := `
                SELECT id, name, description, created_at, updated_at
                FROM domains
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.QueryContext(ctx, query, size, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var domains []*models.Domain
        for rows.Next() </span><span class="cov0" title="0">{
                domain := &amp;models.Domain{}
                err := rows.Scan(&amp;domain.ID, &amp;domain.Name, &amp;domain.Description, &amp;domain.CreatedAt, &amp;domain.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">domains = append(domains, domain)</span>
        }

        <span class="cov0" title="0">return domains, totalCount, nil</span>
}

func (r *domainRepository) Update(ctx context.Context, domain *models.Domain) error <span class="cov0" title="0">{
        query := `
                UPDATE domains 
                SET description = ?, updated_at = datetime('now')
                WHERE id = ?
                RETURNING updated_at
        `

        row := r.db.QueryRowContext(ctx, query, domain.Description, domain.ID)
        return row.Scan(&amp;domain.UpdatedAt)
}</span>

func (r *domainRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM domains WHERE id = ?`
        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *domainRepository) ExistsByName(ctx context.Context, name string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM domains WHERE name = ?)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, name).Scan(&amp;exists)
        return exists, err
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package domains

import (
        "context"
        "database/sql"
        "fmt"
        "regexp"
        "time"

        "url-db/internal/models"
)

type DomainService interface {
        CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*models.Domain, error)
        GetDomain(ctx context.Context, id int) (*models.Domain, error)
        ListDomains(ctx context.Context, page, size int) (*models.DomainListResponse, error)
        UpdateDomain(ctx context.Context, id int, req *models.UpdateDomainRequest) (*models.Domain, error)
        DeleteDomain(ctx context.Context, id int) error
}

type domainService struct {
        repo DomainRepository
}

func NewDomainService(repo DomainRepository) DomainService <span class="cov0" title="0">{
        return &amp;domainService{repo: repo}
}</span>

var domainNameRegex = regexp.MustCompile(`^[a-zA-Z0-9-]+$`)

func (s *domainService) validateDomainName(name string) error <span class="cov0" title="0">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("domain name is required")
        }</span>
        <span class="cov0" title="0">if len(name) &gt; 255 </span><span class="cov0" title="0">{
                return fmt.Errorf("domain name cannot exceed 255 characters")
        }</span>
        <span class="cov0" title="0">if !domainNameRegex.MatchString(name) </span><span class="cov0" title="0">{
                return fmt.Errorf("domain name can only contain alphanumeric characters and hyphens")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *domainService) validateDescription(description string) error <span class="cov0" title="0">{
        if len(description) &gt; 1000 </span><span class="cov0" title="0">{
                return fmt.Errorf("description cannot exceed 1000 characters")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *domainService) CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*models.Domain, error) <span class="cov0" title="0">{
        if err := s.validateDomainName(req.Name); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation_error: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation_error: %w", err)
        }</span>

        // Check if domain already exists
        <span class="cov0" title="0">exists, err := s.repo.ExistsByName(ctx, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check domain existence: %w", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("conflict: domain with name '%s' already exists", req.Name)
        }</span>

        <span class="cov0" title="0">domain := &amp;models.Domain{
                Name:        req.Name,
                Description: req.Description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        err = s.repo.Create(ctx, domain)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create domain: %w", err)
        }</span>

        <span class="cov0" title="0">return domain, nil</span>
}

func (s *domainService) GetDomain(ctx context.Context, id int) (*models.Domain, error) <span class="cov0" title="0">{
        domain, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("not_found: domain with id %d not found", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get domain: %w", err)</span>
        }

        <span class="cov0" title="0">return domain, nil</span>
}

func (s *domainService) ListDomains(ctx context.Context, page, size int) (*models.DomainListResponse, error) <span class="cov0" title="0">{
        // Validate pagination parameters
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if size &lt; 1 </span><span class="cov0" title="0">{
                size = 20
        }</span>
        <span class="cov0" title="0">if size &gt; 100 </span><span class="cov0" title="0">{
                size = 100
        }</span>

        <span class="cov0" title="0">domains, totalCount, err := s.repo.List(ctx, page, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list domains: %w", err)
        }</span>

        // Convert to response format
        <span class="cov0" title="0">domainList := make([]models.Domain, len(domains))
        for i, domain := range domains </span><span class="cov0" title="0">{
                domainList[i] = *domain
        }</span>

        <span class="cov0" title="0">totalPages := (totalCount + size - 1) / size

        return &amp;models.DomainListResponse{
                Domains:    domainList,
                TotalCount: totalCount,
                Page:       page,
                Size:       size,
                TotalPages: totalPages,
        }, nil</span>
}

func (s *domainService) UpdateDomain(ctx context.Context, id int, req *models.UpdateDomainRequest) (*models.Domain, error) <span class="cov0" title="0">{
        if err := s.validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation_error: %w", err)
        }</span>

        // Check if domain exists
        <span class="cov0" title="0">domain, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("not_found: domain with id %d not found", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get domain: %w", err)</span>
        }

        // Update only description
        <span class="cov0" title="0">domain.Description = req.Description
        domain.UpdatedAt = time.Now()

        err = s.repo.Update(ctx, domain)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update domain: %w", err)
        }</span>

        <span class="cov0" title="0">return domain, nil</span>
}

func (s *domainService) DeleteDomain(ctx context.Context, id int) error <span class="cov0" title="0">{
        err := s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("not_found: domain with id %d not found", id)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete domain: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type AttributeService interface {
        CreateAttribute(domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error)
        GetAttributesByDomainID(domainID int) ([]models.Attribute, error)
        GetAttributeByID(id int) (*models.Attribute, error)
        UpdateAttribute(id int, req *models.UpdateAttributeRequest) (*models.Attribute, error)
        DeleteAttribute(id int) error
}

type AttributeHandler struct {
        *BaseHandler
        attributeService AttributeService
}

func NewAttributeHandler(attributeService AttributeService) *AttributeHandler <span class="cov8" title="1">{
        return &amp;AttributeHandler{
                BaseHandler:      NewBaseHandler(),
                attributeService: attributeService,
        }
}</span>

func (h *AttributeHandler) CreateAttribute(c *gin.Context) <span class="cov8" title="1">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">var req models.CreateAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">attribute, err := h.attributeService.CreateAttribute(domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, attribute)</span>
}

func (h *AttributeHandler) GetAttributesByDomain(c *gin.Context) <span class="cov8" title="1">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">attributes, err := h.attributeService.GetAttributesByDomainID(domainID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "attributes": attributes,
        })</span>
}

func (h *AttributeHandler) GetAttribute(c *gin.Context) <span class="cov8" title="1">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">attribute, err := h.attributeService.GetAttributeByID(id)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, attribute)</span>
}

func (h *AttributeHandler) UpdateAttribute(c *gin.Context) <span class="cov8" title="1">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">var req models.UpdateAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">attribute, err := h.attributeService.UpdateAttribute(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, attribute)</span>
}

func (h *AttributeHandler) DeleteAttribute(c *gin.Context) <span class="cov8" title="1">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">err = h.attributeService.DeleteAttribute(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.Status(http.StatusNoContent)</span>
}

func (h *AttributeHandler) RegisterRoutes(r *gin.Engine) <span class="cov8" title="1">{
        api := r.Group("/api")
        </span><span class="cov8" title="1">{
                // Individual attribute operations
                attributes := api.Group("/attributes")
                </span><span class="cov8" title="1">{
                        attributes.GET("/:id", h.GetAttribute)
                        attributes.PUT("/:id", h.UpdateAttribute)
                        attributes.DELETE("/:id", h.DeleteAttribute)
                }</span>

                // Domain-specific attribute operations
                <span class="cov8" title="1">domains := api.Group("/domains")
                </span><span class="cov8" title="1">{
                        domainAttributes := domains.Group("/:domain_id/attributes")
                        </span><span class="cov8" title="1">{
                                domainAttributes.POST("", h.CreateAttribute)
                                domainAttributes.GET("", h.GetAttributesByDomain)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package handlers

import (
        "strconv"

        "github.com/gin-gonic/gin"
)

type BaseHandler struct{}

func NewBaseHandler() *BaseHandler <span class="cov8" title="1">{
        return &amp;BaseHandler{}
}</span>

func (h *BaseHandler) HandleError(c *gin.Context, err error) <span class="cov8" title="1">{
        HandleError(c, err)
}</span>

func (h *BaseHandler) ParseIntParam(c *gin.Context, param string) (int, error) <span class="cov8" title="1">{
        str := c.Param(param)
        if str == "" </span><span class="cov8" title="1">{
                return 0, NewValidationError("Missing parameter: "+param, nil)
        }</span>

        <span class="cov8" title="1">value, err := strconv.Atoi(str)
        if err != nil </span><span class="cov8" title="1">{
                return 0, NewValidationError("Invalid parameter: "+param, nil)
        }</span>

        <span class="cov8" title="1">return value, nil</span>
}

func (h *BaseHandler) ParseIntQuery(c *gin.Context, query string, defaultValue int) int <span class="cov8" title="1">{
        str := c.Query(query)
        if str == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>

        <span class="cov8" title="1">value, err := strconv.Atoi(str)
        if err != nil </span><span class="cov8" title="1">{
                return defaultValue
        }</span>

        <span class="cov8" title="1">return value</span>
}

func (h *BaseHandler) GetStringQuery(c *gin.Context, query string) string <span class="cov8" title="1">{
        return c.Query(query)
}</span>

func (h *BaseHandler) BindJSON(c *gin.Context, obj interface{}) error <span class="cov8" title="1">{
        if err := c.ShouldBindJSON(obj); err != nil </span><span class="cov8" title="1">{
                return NewValidationError("Invalid JSON format", err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
        "url-db/internal/services"
)

// DependencyHandler handles HTTP requests for dependencies
type DependencyHandler struct {
        dependencyService *services.DependencyService
}

// NewDependencyHandler creates a new dependency handler
func NewDependencyHandler(dependencyService *services.DependencyService) *DependencyHandler <span class="cov0" title="0">{
        return &amp;DependencyHandler{
                dependencyService: dependencyService,
        }
}</span>

// CreateDependency creates a new dependency
// @Summary Create dependency
// @Description Create a new dependency relationship between nodes
// @Tags dependencies
// @Accept json
// @Produce json
// @Param nodeId path int true "Dependent Node ID"
// @Param request body models.CreateNodeDependencyRequest true "Dependency details"
// @Success 201 {object} models.NodeDependency
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse "Circular dependency detected"
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/dependencies [post]
func (h *DependencyHandler) CreateDependency(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateNodeDependencyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid request body",
                })
                return
        }</span>

        <span class="cov0" title="0">dependency, err := h.dependencyService.CreateDependency(nodeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "dependent node not found" || err.Error() == "dependency node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "circular dependency detected" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, ErrorResponse{
                                Error:   "conflict",
                                Message: "Circular dependency detected",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to create dependency",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, dependency)</span>
}

// GetDependency retrieves a dependency
// @Summary Get dependency
// @Description Get a dependency by ID
// @Tags dependencies
// @Produce json
// @Param id path int true "Dependency ID"
// @Success 200 {object} models.NodeDependency
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/dependencies/{id} [get]
func (h *DependencyHandler) GetDependency(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid dependency ID",
                })
                return
        }</span>

        <span class="cov0" title="0">dependency, err := h.dependencyService.GetDependency(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "dependency not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Dependency not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get dependency",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, dependency)</span>
}

// DeleteDependency deletes a dependency
// @Summary Delete dependency
// @Description Delete a dependency relationship
// @Tags dependencies
// @Param id path int true "Dependency ID"
// @Success 204
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/dependencies/{id} [delete]
func (h *DependencyHandler) DeleteDependency(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid dependency ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.dependencyService.DeleteDependency(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "dependency not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Dependency not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to delete dependency",
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetNodeDependencies retrieves all dependencies for a node
// @Summary Get node dependencies
// @Description Get all dependencies where the node is dependent
// @Tags dependencies
// @Produce json
// @Param nodeId path int true "Node ID"
// @Success 200 {array} models.NodeDependency
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/dependencies [get]
func (h *DependencyHandler) GetNodeDependencies(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">dependencies, err := h.dependencyService.GetNodeDependencies(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get dependencies",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, dependencies)</span>
}

// GetNodeDependents retrieves all nodes that depend on this node
// @Summary Get node dependents
// @Description Get all nodes that depend on this node
// @Tags dependencies
// @Produce json
// @Param nodeId path int true "Node ID"
// @Success 200 {array} models.NodeDependency
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/dependents [get]
func (h *DependencyHandler) GetNodeDependents(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">dependents, err := h.dependencyService.GetNodeDependents(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get dependents",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, dependents)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type DomainService interface {
        CreateDomain(req *models.CreateDomainRequest) (*models.Domain, error)
        GetDomains(page, size int) (*models.DomainListResponse, error)
        GetDomainByID(id int) (*models.Domain, error)
        UpdateDomain(id int, req *models.UpdateDomainRequest) (*models.Domain, error)
        DeleteDomain(id int) error
}

type DomainHandler struct {
        *BaseHandler
        domainService DomainService
}

func NewDomainHandler(domainService DomainService) *DomainHandler <span class="cov8" title="1">{
        return &amp;DomainHandler{
                BaseHandler:   NewBaseHandler(),
                domainService: domainService,
        }
}</span>

func (h *DomainHandler) CreateDomain(c *gin.Context) <span class="cov8" title="1">{
        var req models.CreateDomainRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">domain, err := h.domainService.CreateDomain(&amp;req)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, domain)</span>
}

func (h *DomainHandler) GetDomains(c *gin.Context) <span class="cov8" title="1">{
        page := h.ParseIntQuery(c, "page", 1)
        size := h.ParseIntQuery(c, "size", 20)

        if size &gt; 100 </span><span class="cov8" title="1">{
                size = 100
        }</span>

        <span class="cov8" title="1">response, err := h.domainService.GetDomains(page, size)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, response)</span>
}

func (h *DomainHandler) GetDomain(c *gin.Context) <span class="cov8" title="1">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">domain, err := h.domainService.GetDomainByID(id)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, domain)</span>
}

func (h *DomainHandler) UpdateDomain(c *gin.Context) <span class="cov8" title="1">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">var req models.UpdateDomainRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">domain, err := h.domainService.UpdateDomain(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, domain)</span>
}

func (h *DomainHandler) DeleteDomain(c *gin.Context) <span class="cov8" title="1">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">err = h.domainService.DeleteDomain(id)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.Status(http.StatusNoContent)</span>
}

func (h *DomainHandler) RegisterRoutes(r *gin.Engine) <span class="cov8" title="1">{
        api := r.Group("/api")
        </span><span class="cov8" title="1">{
                domains := api.Group("/domains")
                </span><span class="cov8" title="1">{
                        domains.POST("", h.CreateDomain)
                        domains.GET("", h.GetDomains)
                        domains.GET("/:id", h.GetDomain)
                        domains.PUT("/:id", h.UpdateDomain)
                        domains.DELETE("/:id", h.DeleteDomain)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type ErrorResponse struct {
        Error   string      `json:"error"`
        Message string      `json:"message"`
        Details interface{} `json:"details,omitempty"`
}

type ValidationError struct {
        Message string
        Details interface{}
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

type NotFoundError struct {
        Message string
}

func (e *NotFoundError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

type ConflictError struct {
        Message string
}

func (e *ConflictError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

type InternalError struct {
        Message string
}

func (e *InternalError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

func HandleError(c *gin.Context, err error) <span class="cov8" title="1">{
        switch e := err.(type) </span>{
        case *ValidationError:<span class="cov8" title="1">
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: e.Message,
                        Details: e.Details,
                })</span>
        case *NotFoundError:<span class="cov8" title="1">
                c.JSON(http.StatusNotFound, ErrorResponse{
                        Error:   "not_found",
                        Message: e.Message,
                })</span>
        case *ConflictError:<span class="cov8" title="1">
                c.JSON(http.StatusConflict, ErrorResponse{
                        Error:   "conflict",
                        Message: e.Message,
                })</span>
        case *InternalError:<span class="cov8" title="1">
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: e.Message,
                })</span>
        default:<span class="cov8" title="1">
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "An unexpected error occurred",
                })</span>
        }
}

func NewValidationError(message string, details interface{}) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Message: message,
                Details: details,
        }
}</span>

func NewNotFoundError(message string) *NotFoundError <span class="cov8" title="1">{
        return &amp;NotFoundError{
                Message: message,
        }
}</span>

func NewConflictError(message string) *ConflictError <span class="cov8" title="1">{
        return &amp;ConflictError{
                Message: message,
        }
}</span>

func NewInternalError(message string) *InternalError <span class="cov8" title="1">{
        return &amp;InternalError{
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package handlers

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "url-db/internal/services"
)

// EventHandler handles HTTP requests for events
type EventHandler struct {
        eventService *services.EventService
}

// NewEventHandler creates a new event handler
func NewEventHandler(eventService *services.EventService) *EventHandler <span class="cov0" title="0">{
        return &amp;EventHandler{
                eventService: eventService,
        }
}</span>

// GetNodeEvents retrieves events for a node
// @Summary Get node events
// @Description Get events for a specific node
// @Tags events
// @Produce json
// @Param nodeId path int true "Node ID"
// @Param limit query int false "Maximum number of events to return" default(50)
// @Success 200 {array} models.NodeEvent
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/events [get]
func (h *EventHandler) GetNodeEvents(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        events, err := h.eventService.GetNodeEvents(nodeID, limit)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get events",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, events)</span>
}

// GetPendingEvents retrieves unprocessed events
// @Summary Get pending events
// @Description Get unprocessed events for processing
// @Tags events
// @Produce json
// @Param limit query int false "Maximum number of events to return" default(100)
// @Success 200 {array} models.NodeEvent
// @Failure 500 {object} ErrorResponse
// @Router /api/events/pending [get]
func (h *EventHandler) GetPendingEvents(c *gin.Context) <span class="cov0" title="0">{
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))

        events, err := h.eventService.GetPendingEvents(limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get pending events",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, events)</span>
}

// ProcessEvent marks an event as processed
// @Summary Process event
// @Description Mark an event as processed
// @Tags events
// @Param eventId path int true "Event ID"
// @Success 204
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/events/{eventId}/process [post]
func (h *EventHandler) ProcessEvent(c *gin.Context) <span class="cov0" title="0">{
        eventID, err := strconv.ParseInt(c.Param("eventId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid event ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.eventService.ProcessEvent(eventID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "event not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Event not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "event already processed" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, ErrorResponse{
                                Error:   "validation_error",
                                Message: "Event already processed",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to process event",
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetEventsByType retrieves events by type and date range
// @Summary Get events by type
// @Description Get events by type within a date range
// @Tags events
// @Produce json
// @Param type query string true "Event type"
// @Param start query string true "Start date (RFC3339)"
// @Param end query string true "End date (RFC3339)"
// @Success 200 {array} models.NodeEvent
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/events [get]
func (h *EventHandler) GetEventsByType(c *gin.Context) <span class="cov0" title="0">{
        eventType := c.Query("type")
        if eventType == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Event type is required",
                })
                return
        }</span>

        <span class="cov0" title="0">startStr := c.Query("start")
        endStr := c.Query("end")

        start, err := time.Parse(time.RFC3339, startStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid start date format",
                })
                return
        }</span>

        <span class="cov0" title="0">end, err := time.Parse(time.RFC3339, endStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid end date format",
                })
                return
        }</span>

        <span class="cov0" title="0">events, err := h.eventService.GetEventsByTypeAndDateRange(eventType, start, end)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "end date must be after start date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, ErrorResponse{
                                Error:   "validation_error",
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get events",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, events)</span>
}

// GetEventStats retrieves event statistics
// @Summary Get event statistics
// @Description Get statistics about events in the system
// @Tags events
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} ErrorResponse
// @Router /api/events/stats [get]
func (h *EventHandler) GetEventStats(c *gin.Context) <span class="cov0" title="0">{
        stats, err := h.eventService.GetEventStats()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get event statistics",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

// CleanupEvents deletes old processed events
// @Summary Cleanup old events
// @Description Delete processed events older than specified days
// @Tags events
// @Param days query int true "Number of days to retain events" minimum(1)
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/events/cleanup [post]
func (h *EventHandler) CleanupEvents(c *gin.Context) <span class="cov0" title="0">{
        days, err := strconv.Atoi(c.Query("days"))
        if err != nil || days &lt; 1 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid days parameter",
                })
                return
        }</span>

        <span class="cov0" title="0">retention := time.Duration(days) * 24 * time.Hour
        deleted, err := h.eventService.CleanupOldEvents(retention)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "minimum retention period is 24 hours" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, ErrorResponse{
                                Error:   "validation_error",
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to cleanup events",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "deleted_events": deleted,
                "message":        "Events cleaned up successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

type HealthService interface {
        CheckDatabaseConnection() error
        GetSystemInfo() (*HealthInfo, error)
}

type HealthInfo struct {
        Status    string            `json:"status"`
        Version   string            `json:"version"`
        Timestamp time.Time         `json:"timestamp"`
        Database  DatabaseHealth    `json:"database"`
        System    SystemHealth      `json:"system"`
        Checks    map[string]string `json:"checks"`
}

type DatabaseHealth struct {
        Status     string `json:"status"`
        Connection string `json:"connection"`
        Response   string `json:"response"`
}

type SystemHealth struct {
        Uptime    time.Duration `json:"uptime"`
        GoVersion string        `json:"go_version"`
        Platform  string        `json:"platform"`
}

type HealthHandler struct {
        *BaseHandler
        healthService HealthService
        startTime     time.Time
}

func NewHealthHandler(healthService HealthService) *HealthHandler <span class="cov8" title="1">{
        return &amp;HealthHandler{
                BaseHandler:   NewBaseHandler(),
                healthService: healthService,
                startTime:     time.Now(),
        }
}</span>

func (h *HealthHandler) GetHealth(c *gin.Context) <span class="cov8" title="1">{
        checks := make(map[string]string)
        overallStatus := "healthy"

        // Check database connection
        dbStatus := "healthy"
        if err := h.healthService.CheckDatabaseConnection(); err != nil </span><span class="cov8" title="1">{
                dbStatus = "unhealthy"
                overallStatus = "unhealthy"
                checks["database"] = err.Error()
        }</span> else<span class="cov8" title="1"> {
                checks["database"] = "ok"
        }</span>

        <span class="cov8" title="1">health := &amp;HealthInfo{
                Status:    overallStatus,
                Version:   "1.0.0",
                Timestamp: time.Now(),
                Database: DatabaseHealth{
                        Status:     dbStatus,
                        Connection: "sqlite",
                        Response:   "ok",
                },
                System: SystemHealth{
                        Uptime:    time.Since(h.startTime),
                        GoVersion: "go1.21",
                        Platform:  "linux/amd64",
                },
                Checks: checks,
        }

        statusCode := http.StatusOK
        if overallStatus == "unhealthy" </span><span class="cov8" title="1">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov8" title="1">c.JSON(statusCode, health)</span>
}

func (h *HealthHandler) GetLiveness(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "status":    "alive",
                "timestamp": time.Now(),
        })
}</span>

func (h *HealthHandler) GetReadiness(c *gin.Context) <span class="cov8" title="1">{
        // Check if the service is ready to serve traffic
        if err := h.healthService.CheckDatabaseConnection(); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusServiceUnavailable, gin.H{
                        "status":    "not ready",
                        "reason":    "database connection failed",
                        "error":     err.Error(),
                        "timestamp": time.Now(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "status":    "ready",
                "timestamp": time.Now(),
        })</span>
}

func (h *HealthHandler) GetVersion(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "version":    "1.0.0",
                "build_time": "2024-01-01T00:00:00Z",
                "commit":     "abc123",
                "go_version": "go1.21",
        })
}</span>

func (h *HealthHandler) RegisterRoutes(r *gin.Engine) <span class="cov8" title="1">{
        // Health check endpoints
        health := r.Group("/health")
        </span><span class="cov8" title="1">{
                health.GET("", h.GetHealth)
                health.GET("/live", h.GetLiveness)
                health.GET("/ready", h.GetReadiness)
        }</span>

        // Version endpoint
        <span class="cov8" title="1">r.GET("/version", h.GetVersion)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package handlers

import (
        "net/http"

        "url-db/internal/models"

        "github.com/gin-gonic/gin"
)

type MCPService interface {
        CreateMCPNode(req *models.CreateMCPNodeRequest) (*models.MCPNode, error)
        GetMCPNodeByCompositeID(compositeID string) (*models.MCPNode, error)
        GetMCPNodes(domainName string, page, size int, search string) (*models.MCPNodeListResponse, error)
        UpdateMCPNode(compositeID string, req *models.UpdateMCPNodeRequest) (*models.MCPNode, error)
        DeleteMCPNode(compositeID string) error
        FindMCPNodeByURL(req *models.FindMCPNodeRequest) (*models.MCPNode, error)
        BatchGetMCPNodes(req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error)
        GetMCPDomains() ([]models.MCPDomain, error)
        CreateMCPDomain(req *models.CreateMCPDomainRequest) (*models.MCPDomain, error)
        GetMCPNodeAttributes(compositeID string) (*models.MCPNodeAttributesResponse, error)
        SetMCPNodeAttributes(compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributesResponse, error)
        GetMCPServerInfo() (*models.MCPServerInfo, error)
        // Domain attribute management methods
        ListDomainAttributes(domainName string) (*models.MCPDomainAttributeListResponse, error)
        CreateDomainAttribute(domainName string, req *models.CreateAttributeRequest) (*models.MCPDomainAttribute, error)
        GetDomainAttribute(compositeID string) (*models.MCPDomainAttribute, error)
        UpdateDomainAttribute(compositeID string, req *models.UpdateAttributeRequest) (*models.MCPDomainAttribute, error)
        DeleteDomainAttribute(compositeID string) error
}

type MCPHandler struct {
        *BaseHandler
        mcpService MCPService
}

func NewMCPHandler(mcpService MCPService) *MCPHandler <span class="cov0" title="0">{
        return &amp;MCPHandler{
                BaseHandler: NewBaseHandler(),
                mcpService:  mcpService,
        }
}</span>

// CreateMCPNode godoc
// @Summary      Create a new MCP node
// @Description  Create a new URL node using MCP composite key format
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        node  body      models.CreateMCPNodeRequest  true  "MCP node data"
// @Success      201   {object}  models.MCPNode
// @Failure      400   {object}  map[string]interface{}
// @Failure      404   {object}  map[string]interface{}
// @Failure      409   {object}  map[string]interface{}
// @Failure      500   {object}  map[string]interface{}
// @Router       /mcp/nodes [post]
func (h *MCPHandler) CreateMCPNode(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateMCPNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.CreateMCPNode(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, node)</span>
}

// GetMCPNode godoc
// @Summary      Get an MCP node
// @Description  Get MCP node by composite ID
// @Tags         mcp
// @Produce      json
// @Param        composite_id  path      string  true  "Composite ID (domain::url)"
// @Success      200           {object}  models.MCPNode
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id} [get]
func (h *MCPHandler) GetMCPNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.GetMCPNodeByCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

// GetMCPNodes godoc
// @Summary      List MCP nodes
// @Description  Get all MCP nodes with pagination, domain filtering, and search
// @Tags         mcp
// @Produce      json
// @Param        domain_name  query  string  false  "Filter by domain name"
// @Param        page         query  int     false  "Page number" default(1)
// @Param        size         query  int     false  "Page size (max 100)" default(20)
// @Param        search       query  string  false  "Search term for URL content"
// @Success      200          {object}  models.MCPNodeListResponse
// @Failure      500          {object}  map[string]interface{}
// @Router       /mcp/nodes [get]
func (h *MCPHandler) GetMCPNodes(c *gin.Context) <span class="cov0" title="0">{
        domainName := h.GetStringQuery(c, "domain_name")
        page := h.ParseIntQuery(c, "page", 1)
        size := h.ParseIntQuery(c, "size", 20)
        search := h.GetStringQuery(c, "search")

        if size &gt; 100 </span><span class="cov0" title="0">{
                size = 100
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.GetMCPNodes(domainName, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// UpdateMCPNode godoc
// @Summary      Update an MCP node
// @Description  Update MCP node title and description by composite ID
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        composite_id  path      string                       true  "Composite ID (domain::url)"
// @Param        node          body      models.UpdateMCPNodeRequest  true  "Updated MCP node data"
// @Success      200           {object}  models.MCPNode
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id} [put]
func (h *MCPHandler) UpdateMCPNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateMCPNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.UpdateMCPNode(compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

// DeleteMCPNode godoc
// @Summary      Delete an MCP node
// @Description  Delete MCP node by composite ID
// @Tags         mcp
// @Param        composite_id  path  string  true  "Composite ID (domain::url)"
// @Success      204
// @Failure      400  {object}  map[string]interface{}
// @Failure      404  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id} [delete]
func (h *MCPHandler) DeleteMCPNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">err := h.mcpService.DeleteMCPNode(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// FindMCPNodeByURL godoc
// @Summary      Find MCP node by URL
// @Description  Find an MCP node by its URL within a domain
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        request  body      models.FindMCPNodeRequest  true  "Domain and URL to search for"
// @Success      200      {object}  models.MCPNode
// @Failure      400      {object}  map[string]interface{}
// @Failure      404      {object}  map[string]interface{}
// @Failure      500      {object}  map[string]interface{}
// @Router       /mcp/nodes/find [post]
func (h *MCPHandler) FindMCPNodeByURL(c *gin.Context) <span class="cov0" title="0">{
        var req models.FindMCPNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.FindMCPNodeByURL(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

// BatchGetMCPNodes godoc
// @Summary      Batch get MCP nodes
// @Description  Get multiple MCP nodes by their composite IDs in a single request
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        request  body      models.BatchMCPNodeRequest  true  "List of composite IDs"
// @Success      200      {object}  models.BatchMCPNodeResponse
// @Failure      400      {object}  map[string]interface{}
// @Failure      500      {object}  map[string]interface{}
// @Router       /mcp/nodes/batch [post]
func (h *MCPHandler) BatchGetMCPNodes(c *gin.Context) <span class="cov0" title="0">{
        var req models.BatchMCPNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.BatchGetMCPNodes(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetMCPDomains godoc
// @Summary      List MCP domains
// @Description  Get all domains with their node counts in MCP format
// @Tags         mcp
// @Produce      json
// @Success      200  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /mcp/domains [get]
func (h *MCPHandler) GetMCPDomains(c *gin.Context) <span class="cov0" title="0">{
        domains, err := h.mcpService.GetMCPDomains()
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "domains": domains,
        })</span>
}

// CreateMCPDomain godoc
// @Summary      Create a new MCP domain
// @Description  Create a new domain using MCP format
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        domain  body      models.CreateMCPDomainRequest  true  "MCP domain data"
// @Success      201     {object}  models.MCPDomain
// @Failure      400     {object}  map[string]interface{}
// @Failure      409     {object}  map[string]interface{}
// @Failure      500     {object}  map[string]interface{}
// @Router       /mcp/domains [post]
func (h *MCPHandler) CreateMCPDomain(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateMCPDomainRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.mcpService.CreateMCPDomain(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, domain)</span>
}

// GetMCPNodeAttributes godoc
// @Summary      Get MCP node attributes
// @Description  Get all attribute values for an MCP node by composite ID
// @Tags         mcp
// @Produce      json
// @Param        composite_id  path      string  true  "Composite ID (domain::url)"
// @Success      200           {object}  models.MCPNodeAttributesResponse
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id}/attributes [get]
func (h *MCPHandler) GetMCPNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.GetMCPNodeAttributes(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// SetMCPNodeAttributes godoc
// @Summary      Set MCP node attributes
// @Description  Set or update attribute values for an MCP node by composite ID
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        composite_id  path      string                              true  "Composite ID (domain::url)"
// @Param        attributes    body      models.SetMCPNodeAttributesRequest  true  "Attribute data to set"
// @Success      200           {object}  models.MCPNodeAttributesResponse
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id}/attributes [put]
func (h *MCPHandler) SetMCPNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">var req models.SetMCPNodeAttributesRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.SetMCPNodeAttributes(compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetMCPServerInfo godoc
// @Summary      Get MCP server information
// @Description  Get server capabilities and configuration information
// @Tags         mcp
// @Produce      json
// @Success      200  {object}  models.MCPServerInfo
// @Failure      500  {object}  map[string]interface{}
// @Router       /mcp/server/info [get]
func (h *MCPHandler) GetMCPServerInfo(c *gin.Context) <span class="cov0" title="0">{
        info, err := h.mcpService.GetMCPServerInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, info)</span>
}

// ListDomainAttributes godoc
// @Summary      List domain attributes
// @Description  Get all attribute definitions for a domain
// @Tags         mcp
// @Produce      json
// @Param        domain_name  path      string  true  "Domain name"
// @Success      200          {object}  models.MCPDomainAttributeListResponse
// @Failure      400          {object}  map[string]interface{}
// @Failure      404          {object}  map[string]interface{}
// @Failure      500          {object}  map[string]interface{}
// @Router       /mcp/domains/{domain_name}/attributes [get]
func (h *MCPHandler) ListDomainAttributes(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing domain_name parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.ListDomainAttributes(domainName)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// CreateDomainAttribute godoc
// @Summary      Create domain attribute
// @Description  Create a new attribute definition for a domain
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        domain_name  path      string                        true  "Domain name"
// @Param        attribute    body      models.CreateAttributeRequest  true  "Attribute data"
// @Success      201          {object}  models.MCPDomainAttribute
// @Failure      400          {object}  map[string]interface{}
// @Failure      404          {object}  map[string]interface{}
// @Failure      409          {object}  map[string]interface{}
// @Failure      500          {object}  map[string]interface{}
// @Router       /mcp/domains/{domain_name}/attributes [post]
func (h *MCPHandler) CreateDomainAttribute(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing domain_name parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.mcpService.CreateDomainAttribute(domainName, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, attribute)</span>
}

// GetDomainAttribute godoc
// @Summary      Get domain attribute
// @Description  Get a specific attribute definition by composite ID
// @Tags         mcp
// @Produce      json
// @Param        composite_id  path      string  true  "Composite ID (domain:attribute_id)"
// @Success      200           {object}  models.MCPDomainAttribute
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/attributes/{composite_id} [get]
func (h *MCPHandler) GetDomainAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.mcpService.GetDomainAttribute(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

// UpdateDomainAttribute godoc
// @Summary      Update domain attribute
// @Description  Update an attribute definition by composite ID
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        composite_id  path      string                        true  "Composite ID (domain:attribute_id)"
// @Param        attribute     body      models.UpdateAttributeRequest  true  "Attribute update data"
// @Success      200           {object}  models.MCPDomainAttribute
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/attributes/{composite_id} [put]
func (h *MCPHandler) UpdateDomainAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.mcpService.UpdateDomainAttribute(compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

// DeleteDomainAttribute godoc
// @Summary      Delete domain attribute
// @Description  Delete an attribute definition by composite ID
// @Tags         mcp
// @Produce      json
// @Param        composite_id  path      string  true  "Composite ID (domain:attribute_id)"
// @Success      200           {object}  map[string]interface{}
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/attributes/{composite_id} [delete]
func (h *MCPHandler) DeleteDomainAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">err := h.mcpService.DeleteDomainAttribute(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Attribute deleted successfully"})</span>
}

func (h *MCPHandler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                mcp := api.Group("/mcp")
                </span><span class="cov0" title="0">{
                        // Node operations
                        nodes := mcp.Group("/nodes")
                        </span><span class="cov0" title="0">{
                                nodes.POST("", h.CreateMCPNode)
                                nodes.GET("", h.GetMCPNodes)
                                nodes.GET("/:composite_id", h.GetMCPNode)
                                nodes.PUT("/:composite_id", h.UpdateMCPNode)
                                nodes.DELETE("/:composite_id", h.DeleteMCPNode)
                                nodes.POST("/find", h.FindMCPNodeByURL)
                                nodes.POST("/batch", h.BatchGetMCPNodes)

                                // Node attributes
                                nodes.GET("/:composite_id/attributes", h.GetMCPNodeAttributes)
                                nodes.PUT("/:composite_id/attributes", h.SetMCPNodeAttributes)
                        }</span>

                        // Domain operations
                        <span class="cov0" title="0">domains := mcp.Group("/domains")
                        </span><span class="cov0" title="0">{
                                domains.GET("", h.GetMCPDomains)
                                domains.POST("", h.CreateMCPDomain)
                                domains.GET("/:domain_name/attributes", h.ListDomainAttributes)
                                domains.POST("/:domain_name/attributes", h.CreateDomainAttribute)
                        }</span>

                        // Domain attributes (by composite ID)
                        <span class="cov0" title="0">attributes := mcp.Group("/attributes")
                        </span><span class="cov0" title="0">{
                                attributes.GET("/:composite_id", h.GetDomainAttribute)
                                attributes.PUT("/:composite_id", h.UpdateDomainAttribute)
                                attributes.DELETE("/:composite_id", h.DeleteDomainAttribute)
                        }</span>

                        // Server info
                        <span class="cov0" title="0">server := mcp.Group("/server")
                        </span><span class="cov0" title="0">{
                                server.GET("/info", h.GetMCPServerInfo)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package handlers

import (
        "fmt"
        "log"
        "os"
        "time"

        "github.com/gin-gonic/gin"
)

func LoggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
                        param.ClientIP,
                        param.TimeStamp.Format(time.RFC3339),
                        param.Method,
                        param.Path,
                        param.Request.Proto,
                        param.StatusCode,
                        param.Latency,
                        param.Request.UserAgent(),
                        param.ErrorMessage,
                )
        }</span>)
}

func CORSMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Accept, Authorization, X-Requested-With")
                c.Header("Access-Control-Expose-Headers", "Content-Length, Content-Type")
                c.Header("Access-Control-Allow-Credentials", "true")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func RecoveryMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.RecoveryWithWriter(os.Stdout, func(c *gin.Context, recovered interface{}) </span><span class="cov0" title="0">{
                if err, ok := recovered.(error); ok </span><span class="cov0" title="0">{
                        log.Printf("Panic recovered: %s", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Panic recovered: %v", recovered)
                }</span>

                <span class="cov0" title="0">c.JSON(500, gin.H{
                        "error":   "internal_error",
                        "message": "An unexpected error occurred",
                })</span>
        })
}

func SecurityHeadersMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
                c.Header("Content-Security-Policy", "default-src 'self'")

                c.Next()
        }</span>
}

func RequestSizeMiddleware(maxSize int64) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.ContentLength &gt; maxSize </span><span class="cov0" title="0">{
                        c.JSON(413, gin.H{
                                "error":   "request_too_large",
                                "message": "Request body too large",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Request-Timeout", timeout.String())
                c.Next()
        }</span>
}

func JSONOnlyMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.Method == "POST" || c.Request.Method == "PUT" || c.Request.Method == "PATCH" </span><span class="cov0" title="0">{
                        contentType := c.GetHeader("Content-Type")
                        if contentType != "application/json" &amp;&amp; contentType != "application/json; charset=utf-8" </span><span class="cov0" title="0">{
                                c.JSON(415, gin.H{
                                        "error":   "unsupported_media_type",
                                        "message": "Content-Type must be application/json",
                                })
                                c.Abort()
                                return
                        }</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

func RequestIDMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = fmt.Sprintf("%d", time.Now().UnixNano())
                }</span>

                <span class="cov0" title="0">c.Header("X-Request-ID", requestID)
                c.Set("request_id", requestID)

                c.Next()</span>
        }
}

func APIVersionMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-API-Version", "v1")
                c.Next()
        }</span>
}

func SetupMiddleware(r *gin.Engine) <span class="cov0" title="0">{
        // Recovery middleware should be first
        r.Use(RecoveryMiddleware())

        // Request ID for tracing
        r.Use(RequestIDMiddleware())

        // Logging middleware
        r.Use(LoggingMiddleware())

        // CORS middleware
        r.Use(CORSMiddleware())

        // Security headers
        r.Use(SecurityHeadersMiddleware())

        // Request size limit (10MB)
        r.Use(RequestSizeMiddleware(10 * 1024 * 1024))

        // JSON content type enforcement for API routes
        apiGroup := r.Group("/api")
        apiGroup.Use(JSONOnlyMiddleware())

        // API version header
        r.Use(APIVersionMiddleware())

        // Timeout middleware (30 seconds)
        r.Use(TimeoutMiddleware(30 * time.Second))
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type NodeAttributeService interface {
        CreateNodeAttribute(nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttribute, error)
        GetNodeAttributesByNodeID(nodeID int) ([]models.NodeAttributeWithInfo, error)
        GetNodeAttributeByID(id int) (*models.NodeAttributeWithInfo, error)
        UpdateNodeAttribute(id int, req *models.UpdateNodeAttributeRequest) (*models.NodeAttribute, error)
        DeleteNodeAttribute(id int) error
        DeleteNodeAttributeByNodeAndAttribute(nodeID, attributeID int) error
}

type NodeAttributeHandler struct {
        *BaseHandler
        nodeAttributeService NodeAttributeService
}

func NewNodeAttributeHandler(nodeAttributeService NodeAttributeService) *NodeAttributeHandler <span class="cov0" title="0">{
        return &amp;NodeAttributeHandler{
                BaseHandler:          NewBaseHandler(),
                nodeAttributeService: nodeAttributeService,
        }
}</span>

func (h *NodeAttributeHandler) CreateNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := h.ParseIntParam(c, "url_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateNodeAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">nodeAttribute, err := h.nodeAttributeService.CreateNodeAttribute(nodeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, nodeAttribute)</span>
}

func (h *NodeAttributeHandler) GetNodeAttributesByNode(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := h.ParseIntParam(c, "url_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attributes, err := h.nodeAttributeService.GetNodeAttributesByNodeID(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "attributes": attributes,
        })</span>
}

func (h *NodeAttributeHandler) GetNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.nodeAttributeService.GetNodeAttributeByID(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

func (h *NodeAttributeHandler) UpdateNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateNodeAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.nodeAttributeService.UpdateNodeAttribute(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

func (h *NodeAttributeHandler) DeleteNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">err = h.nodeAttributeService.DeleteNodeAttribute(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *NodeAttributeHandler) DeleteNodeAttributeByNodeAndAttribute(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := h.ParseIntParam(c, "url_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attributeID, err := h.ParseIntParam(c, "attribute_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">err = h.nodeAttributeService.DeleteNodeAttributeByNodeAndAttribute(nodeID, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *NodeAttributeHandler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                // Individual node attribute operations
                urlAttributes := api.Group("/url-attributes")
                </span><span class="cov0" title="0">{
                        urlAttributes.GET("/:id", h.GetNodeAttribute)
                        urlAttributes.PUT("/:id", h.UpdateNodeAttribute)
                        urlAttributes.DELETE("/:id", h.DeleteNodeAttribute)
                }</span>

                // Node-specific attribute operations
                <span class="cov0" title="0">urls := api.Group("/urls")
                </span><span class="cov0" title="0">{
                        urlNodeAttributes := urls.Group("/:url_id/attributes")
                        </span><span class="cov0" title="0">{
                                urlNodeAttributes.POST("", h.CreateNodeAttribute)
                                urlNodeAttributes.GET("", h.GetNodeAttributesByNode)
                                urlNodeAttributes.DELETE("/:attribute_id", h.DeleteNodeAttributeByNodeAndAttribute)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type NodeService interface {
        CreateNode(domainID int, req *models.CreateNodeRequest) (*models.Node, error)
        GetNodeByID(id int) (*models.Node, error)
        GetNodesByDomainID(domainID, page, size int) (*models.NodeListResponse, error)
        FindNodeByURL(domainID int, req *models.FindNodeByURLRequest) (*models.Node, error)
        UpdateNode(id int, req *models.UpdateNodeRequest) (*models.Node, error)
        DeleteNode(id int) error
        SearchNodes(domainID int, query string, page, size int) (*models.NodeListResponse, error)
}

type NodeHandler struct {
        *BaseHandler
        nodeService NodeService
}

func NewNodeHandler(nodeService NodeService) *NodeHandler <span class="cov8" title="1">{
        return &amp;NodeHandler{
                BaseHandler: NewBaseHandler(),
                nodeService: nodeService,
        }
}</span>

func (h *NodeHandler) CreateNode(c *gin.Context) <span class="cov8" title="1">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">var req models.CreateNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">node, err := h.nodeService.CreateNode(domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, node)</span>
}

func (h *NodeHandler) GetNodesByDomain(c *gin.Context) <span class="cov8" title="1">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">page := h.ParseIntQuery(c, "page", 1)
        size := h.ParseIntQuery(c, "size", 20)
        search := h.GetStringQuery(c, "search")

        if size &gt; 100 </span><span class="cov8" title="1">{
                size = 100
        }</span>

        <span class="cov8" title="1">var response *models.NodeListResponse
        if search != "" </span><span class="cov8" title="1">{
                response, err = h.nodeService.SearchNodes(domainID, search, page, size)
        }</span> else<span class="cov8" title="1"> {
                response, err = h.nodeService.GetNodesByDomainID(domainID, page, size)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, response)</span>
}

func (h *NodeHandler) GetNode(c *gin.Context) <span class="cov8" title="1">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">node, err := h.nodeService.GetNodeByID(id)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, node)</span>
}

func (h *NodeHandler) UpdateNode(c *gin.Context) <span class="cov8" title="1">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">var req models.UpdateNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">node, err := h.nodeService.UpdateNode(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, node)</span>
}

func (h *NodeHandler) DeleteNode(c *gin.Context) <span class="cov8" title="1">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">err = h.nodeService.DeleteNode(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.Status(http.StatusNoContent)</span>
}

func (h *NodeHandler) FindNodeByURL(c *gin.Context) <span class="cov8" title="1">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">var req models.FindNodeByURLRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov8" title="1">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">node, err := h.nodeService.FindNodeByURL(domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, node)</span>
}

func (h *NodeHandler) RegisterRoutes(r *gin.Engine) <span class="cov8" title="1">{
        api := r.Group("/api")
        </span><span class="cov8" title="1">{
                // Individual node operations
                urls := api.Group("/urls")
                </span><span class="cov8" title="1">{
                        urls.GET("/:id", h.GetNode)
                        urls.PUT("/:id", h.UpdateNode)
                        urls.DELETE("/:id", h.DeleteNode)
                }</span>

                // Domain-specific node operations
                <span class="cov8" title="1">domains := api.Group("/domains")
                </span><span class="cov8" title="1">{
                        domainUrls := domains.Group("/:domain_id/urls")
                        </span><span class="cov8" title="1">{
                                domainUrls.POST("", h.CreateNode)
                                domainUrls.GET("", h.GetNodesByDomain)
                                domainUrls.POST("/find", h.FindNodeByURL)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
)

func SetupRoutes(r *gin.Engine,
        domainHandler *DomainHandler,
        nodeHandler *NodeHandler,
        attributeHandler *AttributeHandler,
        nodeAttributeHandler *NodeAttributeHandler,
        mcpHandler *MCPHandler,
        healthHandler *HealthHandler,
        subscriptionHandler *SubscriptionHandler,
        dependencyHandler *DependencyHandler,
        eventHandler *EventHandler) <span class="cov0" title="0">{

        // Setup middleware
        SetupMiddleware(r)

        // Health check routes (no auth required)
        healthHandler.RegisterRoutes(r)

        // API routes
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                // Domain routes
                domains := api.Group("/domains")
                </span><span class="cov0" title="0">{
                        domains.POST("", domainHandler.CreateDomain)
                        domains.GET("", domainHandler.GetDomains)
                        domains.GET("/:id", domainHandler.GetDomain)
                        domains.PUT("/:id", domainHandler.UpdateDomain)
                        domains.DELETE("/:id", domainHandler.DeleteDomain)

                        // Domain-specific node routes
                        domainNodes := domains.Group("/:domain_id/urls")
                        </span><span class="cov0" title="0">{
                                domainNodes.POST("", nodeHandler.CreateNode)
                                domainNodes.GET("", nodeHandler.GetNodesByDomain)
                                domainNodes.POST("/find", nodeHandler.FindNodeByURL)
                        }</span>

                        // Domain-specific attribute routes
                        <span class="cov0" title="0">domainAttributes := domains.Group("/:domain_id/attributes")
                        </span><span class="cov0" title="0">{
                                domainAttributes.POST("", attributeHandler.CreateAttribute)
                                domainAttributes.GET("", attributeHandler.GetAttributesByDomain)
                        }</span>
                }

                // Node routes
                <span class="cov0" title="0">urls := api.Group("/urls")
                </span><span class="cov0" title="0">{
                        urls.GET("/:id", nodeHandler.GetNode)
                        urls.PUT("/:id", nodeHandler.UpdateNode)
                        urls.DELETE("/:id", nodeHandler.DeleteNode)

                        // Node-specific attribute routes
                        urlAttributes := urls.Group("/:url_id/attributes")
                        </span><span class="cov0" title="0">{
                                urlAttributes.POST("", nodeAttributeHandler.CreateNodeAttribute)
                                urlAttributes.GET("", nodeAttributeHandler.GetNodeAttributesByNode)
                                urlAttributes.DELETE("/:attribute_id", nodeAttributeHandler.DeleteNodeAttributeByNodeAndAttribute)
                        }</span>
                }

                // Attribute routes
                <span class="cov0" title="0">attributes := api.Group("/attributes")
                </span><span class="cov0" title="0">{
                        attributes.GET("/:id", attributeHandler.GetAttribute)
                        attributes.PUT("/:id", attributeHandler.UpdateAttribute)
                        attributes.DELETE("/:id", attributeHandler.DeleteAttribute)
                }</span>

                // Node attribute routes
                <span class="cov0" title="0">urlAttributesGlobal := api.Group("/url-attributes")
                </span><span class="cov0" title="0">{
                        urlAttributesGlobal.GET("/:id", nodeAttributeHandler.GetNodeAttribute)
                        urlAttributesGlobal.PUT("/:id", nodeAttributeHandler.UpdateNodeAttribute)
                        urlAttributesGlobal.DELETE("/:id", nodeAttributeHandler.DeleteNodeAttribute)
                }</span>

                // External dependency management routes
                // Subscription routes
                <span class="cov0" title="0">subscriptions := api.Group("/subscriptions")
                </span><span class="cov0" title="0">{
                        subscriptions.GET("/:id", subscriptionHandler.GetSubscription)
                        subscriptions.PUT("/:id", subscriptionHandler.UpdateSubscription)
                        subscriptions.DELETE("/:id", subscriptionHandler.DeleteSubscription)
                        subscriptions.GET("", subscriptionHandler.GetServiceSubscriptions) // with ?service= query param
                }</span>

                // Node subscription routes
                <span class="cov0" title="0">nodes := api.Group("/nodes")
                </span><span class="cov0" title="0">{
                        nodes.POST("/:nodeId/subscriptions", subscriptionHandler.CreateSubscription)
                        nodes.GET("/:nodeId/subscriptions", subscriptionHandler.GetNodeSubscriptions)

                        // Node dependency routes
                        nodes.POST("/:nodeId/dependencies", dependencyHandler.CreateDependency)
                        nodes.GET("/:nodeId/dependencies", dependencyHandler.GetNodeDependencies)
                        nodes.GET("/:nodeId/dependents", dependencyHandler.GetNodeDependents)

                        // Node event routes
                        nodes.GET("/:nodeId/events", eventHandler.GetNodeEvents)
                }</span>

                // Dependency routes
                <span class="cov0" title="0">dependencies := api.Group("/dependencies")
                </span><span class="cov0" title="0">{
                        dependencies.GET("/:id", dependencyHandler.GetDependency)
                        dependencies.DELETE("/:id", dependencyHandler.DeleteDependency)
                }</span>

                // Event routes
                <span class="cov0" title="0">events := api.Group("/events")
                </span><span class="cov0" title="0">{
                        events.GET("/pending", eventHandler.GetPendingEvents)
                        events.POST("/:eventId/process", eventHandler.ProcessEvent)
                        events.GET("", eventHandler.GetEventsByType) // with query params
                        events.GET("/stats", eventHandler.GetEventStats)
                        events.POST("/cleanup", eventHandler.CleanupEvents)
                }</span>

                // MCP routes
                <span class="cov0" title="0">mcp := api.Group("/mcp")
                </span><span class="cov0" title="0">{
                        // Node operations
                        nodes := mcp.Group("/nodes")
                        </span><span class="cov0" title="0">{
                                nodes.POST("", mcpHandler.CreateMCPNode)
                                nodes.GET("", mcpHandler.GetMCPNodes)
                                nodes.GET("/:composite_id", mcpHandler.GetMCPNode)
                                nodes.PUT("/:composite_id", mcpHandler.UpdateMCPNode)
                                nodes.DELETE("/:composite_id", mcpHandler.DeleteMCPNode)
                                nodes.POST("/find", mcpHandler.FindMCPNodeByURL)
                                nodes.POST("/batch", mcpHandler.BatchGetMCPNodes)

                                // Node attributes
                                nodes.GET("/:composite_id/attributes", mcpHandler.GetMCPNodeAttributes)
                                nodes.PUT("/:composite_id/attributes", mcpHandler.SetMCPNodeAttributes)
                        }</span>

                        // Domain operations
                        <span class="cov0" title="0">domains := mcp.Group("/domains")
                        </span><span class="cov0" title="0">{
                                domains.GET("", mcpHandler.GetMCPDomains)
                                domains.POST("", mcpHandler.CreateMCPDomain)
                        }</span>

                        // Server info
                        <span class="cov0" title="0">server := mcp.Group("/server")
                        </span><span class="cov0" title="0">{
                                server.GET("/info", mcpHandler.GetMCPServerInfo)
                        }</span>
                }
        }
}

func NewRouter() *gin.Engine <span class="cov0" title="0">{
        // Set gin mode based on environment
        gin.SetMode(gin.ReleaseMode) // Can be configured via environment variable

        r := gin.New()

        // Add basic middleware that should always be present
        r.Use(gin.Recovery())

        return r
}</span>

type RouterConfig struct {
        DomainHandler        *DomainHandler
        NodeHandler          *NodeHandler
        AttributeHandler     *AttributeHandler
        NodeAttributeHandler *NodeAttributeHandler
        MCPHandler           *MCPHandler
        HealthHandler        *HealthHandler
        SubscriptionHandler  *SubscriptionHandler
        DependencyHandler    *DependencyHandler
        EventHandler         *EventHandler
}

func SetupRouter(config *RouterConfig) *gin.Engine <span class="cov0" title="0">{
        r := NewRouter()

        SetupRoutes(r,
                config.DomainHandler,
                config.NodeHandler,
                config.AttributeHandler,
                config.NodeAttributeHandler,
                config.MCPHandler,
                config.HealthHandler,
                config.SubscriptionHandler,
                config.DependencyHandler,
                config.EventHandler,
        )

        return r
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
)

// This file provides compatibility interfaces for legacy routing setup
// The actual implementations are in the individual handler files

func SetupLegacyRoutes(r *gin.Engine,
        domainHandler interface{ RegisterRoutes(r *gin.Engine) },
        nodeHandler interface{ RegisterRoutes(r *gin.Engine) },
        attributeHandler interface{ RegisterRoutes(r *gin.Engine) },
        nodeAttributeHandler interface{ RegisterRoutes(r *gin.Engine) },
        mcpHandler interface{ RegisterRoutes(r *gin.Engine) }) <span class="cov0" title="0">{

        // Setup CORS middleware
        r.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })

        // Health check endpoint
        <span class="cov0" title="0">r.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "status":  "healthy",
                        "service": "url-db",
                })
        }</span>)

        // Register all handler routes if they implement RegisterRoutes
        <span class="cov0" title="0">if domainHandler != nil </span><span class="cov0" title="0">{
                domainHandler.RegisterRoutes(r)
        }</span>
        <span class="cov0" title="0">if nodeHandler != nil </span><span class="cov0" title="0">{
                nodeHandler.RegisterRoutes(r)
        }</span>
        <span class="cov0" title="0">if attributeHandler != nil </span><span class="cov0" title="0">{
                attributeHandler.RegisterRoutes(r)
        }</span>
        <span class="cov0" title="0">if nodeAttributeHandler != nil </span><span class="cov0" title="0">{
                nodeAttributeHandler.RegisterRoutes(r)
        }</span>
        <span class="cov0" title="0">if mcpHandler != nil </span><span class="cov0" title="0">{
                mcpHandler.RegisterRoutes(r)
        }</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
        "url-db/internal/services"
)

// SubscriptionHandler handles HTTP requests for subscriptions
type SubscriptionHandler struct {
        subscriptionService *services.SubscriptionService
}

// NewSubscriptionHandler creates a new subscription handler
func NewSubscriptionHandler(subscriptionService *services.SubscriptionService) *SubscriptionHandler <span class="cov0" title="0">{
        return &amp;SubscriptionHandler{
                subscriptionService: subscriptionService,
        }
}</span>

// CreateSubscription creates a new subscription
// @Summary Create subscription
// @Description Create a new subscription for node events
// @Tags subscriptions
// @Accept json
// @Produce json
// @Param nodeId path int true "Node ID"
// @Param request body models.CreateNodeSubscriptionRequest true "Subscription details"
// @Success 201 {object} models.NodeSubscription
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/subscriptions [post]
func (h *SubscriptionHandler) CreateSubscription(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateNodeSubscriptionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid request body",
                })
                return
        }</span>

        <span class="cov0" title="0">subscription, err := h.subscriptionService.CreateSubscription(nodeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to create subscription",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, subscription)</span>
}

// GetSubscription retrieves a subscription
// @Summary Get subscription
// @Description Get a subscription by ID
// @Tags subscriptions
// @Produce json
// @Param id path int true "Subscription ID"
// @Success 200 {object} models.NodeSubscription
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/subscriptions/{id} [get]
func (h *SubscriptionHandler) GetSubscription(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid subscription ID",
                })
                return
        }</span>

        <span class="cov0" title="0">subscription, err := h.subscriptionService.GetSubscription(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "subscription not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Subscription not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get subscription",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, subscription)</span>
}

// UpdateSubscription updates a subscription
// @Summary Update subscription
// @Description Update a subscription
// @Tags subscriptions
// @Accept json
// @Produce json
// @Param id path int true "Subscription ID"
// @Param request body models.UpdateNodeSubscriptionRequest true "Update details"
// @Success 200 {object} models.NodeSubscription
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/subscriptions/{id} [put]
func (h *SubscriptionHandler) UpdateSubscription(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid subscription ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateNodeSubscriptionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid request body",
                })
                return
        }</span>

        <span class="cov0" title="0">subscription, err := h.subscriptionService.UpdateSubscription(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "subscription not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Subscription not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to update subscription",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, subscription)</span>
}

// DeleteSubscription deletes a subscription
// @Summary Delete subscription
// @Description Delete a subscription
// @Tags subscriptions
// @Param id path int true "Subscription ID"
// @Success 204
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/subscriptions/{id} [delete]
func (h *SubscriptionHandler) DeleteSubscription(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid subscription ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.subscriptionService.DeleteSubscription(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "subscription not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Subscription not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to delete subscription",
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetNodeSubscriptions retrieves all subscriptions for a node
// @Summary Get node subscriptions
// @Description Get all subscriptions for a specific node
// @Tags subscriptions
// @Produce json
// @Param nodeId path int true "Node ID"
// @Success 200 {array} models.NodeSubscription
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/subscriptions [get]
func (h *SubscriptionHandler) GetNodeSubscriptions(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">subscriptions, err := h.subscriptionService.GetNodeSubscriptions(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get subscriptions",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, subscriptions)</span>
}

// GetServiceSubscriptions retrieves all subscriptions for a service
// @Summary Get service subscriptions
// @Description Get all subscriptions for a specific service
// @Tags subscriptions
// @Produce json
// @Param service query string true "Service name"
// @Success 200 {array} models.NodeSubscription
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/subscriptions [get]
func (h *SubscriptionHandler) GetServiceSubscriptions(c *gin.Context) <span class="cov0" title="0">{
        service := c.Query("service")
        if service == "" </span><span class="cov0" title="0">{
                // Get all subscriptions with pagination
                page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
                pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))

                subscriptions, total, err := h.subscriptionService.GetAllSubscriptions(page, pageSize)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, ErrorResponse{
                                Error:   "internal_error",
                                Message: "Failed to get subscriptions",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "subscriptions": subscriptions,
                        "total":         total,
                        "page":          page,
                        "page_size":     pageSize,
                })
                return</span>
        }

        <span class="cov0" title="0">subscriptions, err := h.subscriptionService.GetServiceSubscriptions(service)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get subscriptions",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, subscriptions)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package config

import (
        "os"
        "strconv"
        "url-db/internal/constants"
)

type Config struct {
        Port        string
        DatabaseURL string
        ToolName    string
}

func Load() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Port:        getEnv("PORT", strconv.Itoa(constants.DefaultPort)),
                DatabaseURL: getEnv("DATABASE_URL", "file:./"+constants.DefaultDBPath),
                ToolName:    getEnv("TOOL_NAME", constants.DefaultServerName),
        }
}</span>

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package database

import "time"

type Config struct {
        URL             string
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
        WALMode         bool
        ForeignKeys     bool
        JournalMode     string
        Synchronous     string
}

func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                URL:             "file:./app.db",
                MaxOpenConns:    10,
                MaxIdleConns:    5,
                ConnMaxLifetime: time.Hour,
                WALMode:         true,
                ForeignKeys:     true,
                JournalMode:     "WAL",
                Synchronous:     "NORMAL",
        }
}</span>

func TestConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                URL:             ":memory:",
                MaxOpenConns:    1,
                MaxIdleConns:    1,
                ConnMaxLifetime: time.Hour,
                WALMode:         false,
                ForeignKeys:     true,
                JournalMode:     "DELETE",
                Synchronous:     "OFF",
        }
}</span>

func ProductionConfig(dbPath string) *Config <span class="cov0" title="0">{
        return &amp;Config{
                URL:             "file:" + dbPath,
                MaxOpenConns:    100,
                MaxIdleConns:    50,
                ConnMaxLifetime: time.Hour,
                WALMode:         true,
                ForeignKeys:     true,
                JournalMode:     "WAL",
                Synchronous:     "FULL",
        }
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"

        _ "github.com/mattn/go-sqlite3"
)

// Schema file path relative to project root
const schemaFilePath = "schema.sql"

type Database struct {
        db     *sql.DB
        config *Config
}

func New(config *Config) (*Database, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultConfig()
        }</span>

        <span class="cov8" title="1">db, err := sql.Open("sqlite3", config.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov8" title="1">if err := configureDatabase(db, config); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to configure database: %w", err)
        }</span>

        <span class="cov8" title="1">database := &amp;Database{
                db:     db,
                config: config,
        }

        if err := database.createSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to create schema: %w", err)
        }</span>

        <span class="cov8" title="1">return database, nil</span>
}

func configureDatabase(db *sql.DB, config *Config) error <span class="cov8" title="1">{
        db.SetMaxOpenConns(config.MaxOpenConns)
        db.SetMaxIdleConns(config.MaxIdleConns)
        db.SetConnMaxLifetime(config.ConnMaxLifetime)

        pragmas := []string{
                fmt.Sprintf("PRAGMA journal_mode = %s", config.JournalMode),
                fmt.Sprintf("PRAGMA synchronous = %s", config.Synchronous),
        }

        if config.ForeignKeys </span><span class="cov8" title="1">{
                pragmas = append(pragmas, "PRAGMA foreign_keys = ON")
        }</span>

        <span class="cov8" title="1">if config.WALMode </span><span class="cov8" title="1">{
                pragmas = append(pragmas, "PRAGMA journal_mode = WAL")
        }</span>

        <span class="cov8" title="1">for _, pragma := range pragmas </span><span class="cov8" title="1">{
                if _, err := db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute pragma %s: %w", pragma, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (d *Database) createSchema() error <span class="cov8" title="1">{
        // Load schema from external file
        schema, err := d.loadSchemaFromFile()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to inline schema if file not found
                fmt.Fprintf(os.Stderr, "Warning: Could not load schema.sql file, using inline schema: %v\n", err)
                schema = d.getInlineSchema()
        }</span>

        <span class="cov8" title="1">if _, err := d.db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute schema: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadSchemaFromFile loads schema from external schema.sql file
func (d *Database) loadSchemaFromFile() (string, error) <span class="cov8" title="1">{
        // Find project root by looking for go.mod
        projectRoot, err := findProjectRoot()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not find project root: %w", err)
        }</span>

        <span class="cov8" title="1">schemaPath := filepath.Join(projectRoot, schemaFilePath)
        schemaBytes, err := os.ReadFile(schemaPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not read schema file %s: %w", schemaPath, err)
        }</span>

        <span class="cov8" title="1">return string(schemaBytes), nil</span>
}

// findProjectRoot finds the project root by looking for go.mod file
func findProjectRoot() (string, error) <span class="cov8" title="1">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Walk up the directory tree looking for go.mod
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov8" title="1">{
                        return dir, nil
                }</span>

                <span class="cov8" title="1">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        break</span> // reached root directory
                }
                <span class="cov8" title="1">dir = parent</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("go.mod not found")</span>
}

// getInlineSchema returns the inline schema as fallback
func (d *Database) getInlineSchema() string <span class="cov0" title="0">{
        return `
        -- 도메인 폴더 테이블
        CREATE TABLE IF NOT EXISTS domains (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- 노드 테이블 (URL 등의 컨텐츠 저장)
        CREATE TABLE IF NOT EXISTS nodes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                content TEXT NOT NULL,
                domain_id INTEGER NOT NULL,
                title TEXT,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE,
                UNIQUE(content, domain_id)
        );

        -- 속성 정의 테이블
        CREATE TABLE IF NOT EXISTS attributes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                domain_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                type TEXT NOT NULL CHECK (type IN ('tag', 'ordered_tag', 'number', 'string', 'markdown', 'image')),
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE,
                UNIQUE(domain_id, name)
        );

        -- 노드 속성 값 테이블
        CREATE TABLE IF NOT EXISTS node_attributes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                node_id INTEGER NOT NULL,
                attribute_id INTEGER NOT NULL,
                value TEXT NOT NULL,
                order_index INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (attribute_id) REFERENCES attributes(id) ON DELETE CASCADE
        );

        -- 노드 간 연결관계 테이블
        CREATE TABLE IF NOT EXISTS node_connections (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source_node_id INTEGER NOT NULL,
                target_node_id INTEGER NOT NULL,
                relationship_type TEXT NOT NULL,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (source_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (target_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                UNIQUE(source_node_id, target_node_id, relationship_type)
        );

        -- 노드 구독 테이블 (이벤트 구독 관리)
        CREATE TABLE IF NOT EXISTS node_subscriptions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                subscriber_service TEXT NOT NULL,
                subscriber_endpoint TEXT,
                subscribed_node_id INTEGER NOT NULL,
                event_types TEXT NOT NULL, -- JSON array of event types
                filter_conditions TEXT,    -- JSON object for filter conditions
                is_active BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (subscribed_node_id) REFERENCES nodes(id) ON DELETE CASCADE
        );

        -- 의존성 타입 레지스트리
        CREATE TABLE IF NOT EXISTS dependency_types (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                type_name TEXT NOT NULL UNIQUE,
                category TEXT NOT NULL, -- 'structural', 'behavioral', 'data'
                cascade_delete BOOLEAN DEFAULT FALSE,
                cascade_update BOOLEAN DEFAULT FALSE,
                validation_required BOOLEAN DEFAULT TRUE,
                metadata_schema TEXT, -- JSON schema for type-specific metadata
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- 노드 의존성 테이블 (기존 호환성용)
        CREATE TABLE IF NOT EXISTS node_dependencies (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                dependent_node_id INTEGER NOT NULL,
                dependency_node_id INTEGER NOT NULL,
                dependency_type TEXT NOT NULL,
                cascade_delete BOOLEAN DEFAULT FALSE,
                cascade_update BOOLEAN DEFAULT FALSE,
                metadata TEXT, -- JSON metadata
                description TEXT,
                is_required BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (dependent_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (dependency_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                UNIQUE(dependent_node_id, dependency_node_id, dependency_type)
        );

        -- 고도화된 노드 의존성 테이블 V2
        CREATE TABLE IF NOT EXISTS node_dependencies_v2 (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                dependent_node_id INTEGER NOT NULL,
                dependency_node_id INTEGER NOT NULL,
                dependency_type_id INTEGER NOT NULL,
                strength INTEGER DEFAULT 50, -- 0-100, dependency strength
                priority INTEGER DEFAULT 50, -- 0-100, resolution priority
                metadata TEXT, -- JSON: type-specific metadata
                version_constraint TEXT, -- Semantic versioning constraint
                is_required BOOLEAN DEFAULT TRUE,
                is_active BOOLEAN DEFAULT TRUE,
                valid_from DATETIME DEFAULT CURRENT_TIMESTAMP,
                valid_until DATETIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                created_by TEXT,
                FOREIGN KEY (dependent_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (dependency_node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                FOREIGN KEY (dependency_type_id) REFERENCES dependency_types(id),
                UNIQUE(dependent_node_id, dependency_node_id, dependency_type_id, valid_from)
        );

        -- 의존성 히스토리 추적
        CREATE TABLE IF NOT EXISTS dependency_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                dependency_id INTEGER NOT NULL,
                action TEXT NOT NULL, -- 'created', 'updated', 'deleted', 'activated', 'deactivated'
                previous_state TEXT, -- JSON: previous dependency state
                new_state TEXT, -- JSON: new dependency state
                change_reason TEXT,
                changed_by TEXT,
                changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (dependency_id) REFERENCES node_dependencies_v2(id)
        );

        -- 의존성 그래프 캐시
        CREATE TABLE IF NOT EXISTS dependency_graph_cache (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                node_id INTEGER NOT NULL,
                graph_data TEXT NOT NULL, -- JSON: pre-computed dependency graph
                depth INTEGER DEFAULT 0, -- Max depth in dependency tree
                total_dependencies INTEGER DEFAULT 0,
                total_dependents INTEGER DEFAULT 0,
                has_circular BOOLEAN DEFAULT FALSE,
                computed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                expires_at DATETIME,
                FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE
        );

        -- 의존성 검증 규칙
        CREATE TABLE IF NOT EXISTS dependency_rules (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                domain_id INTEGER,
                rule_name TEXT NOT NULL,
                rule_type TEXT NOT NULL, -- 'circular_prevention', 'max_depth', 'type_compatibility'
                rule_config TEXT NOT NULL, -- JSON: rule configuration
                is_active BOOLEAN DEFAULT TRUE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE
        );

        -- 의존성 영향 분석 결과
        CREATE TABLE IF NOT EXISTS dependency_impact_analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source_node_id INTEGER NOT NULL,
                impact_type TEXT NOT NULL, -- 'delete', 'update', 'version_change'
                affected_nodes TEXT NOT NULL, -- JSON: array of affected node IDs with impact details
                impact_score INTEGER, -- 0-100, overall impact severity
                analysis_metadata TEXT, -- JSON: detailed analysis results
                analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (source_node_id) REFERENCES nodes(id) ON DELETE CASCADE
        );

        -- 인덱스 생성
        CREATE INDEX IF NOT EXISTS idx_nodes_domain ON nodes(domain_id);
        CREATE INDEX IF NOT EXISTS idx_nodes_content ON nodes(content);
        CREATE INDEX IF NOT EXISTS idx_attributes_domain ON attributes(domain_id);
        CREATE INDEX IF NOT EXISTS idx_node_attributes_node ON node_attributes(node_id);
        CREATE INDEX IF NOT EXISTS idx_node_attributes_attribute ON node_attributes(attribute_id);
        CREATE INDEX IF NOT EXISTS idx_node_connections_source ON node_connections(source_node_id);
        CREATE INDEX IF NOT EXISTS idx_node_connections_target ON node_connections(target_node_id);
        CREATE INDEX IF NOT EXISTS idx_node_subscriptions_node ON node_subscriptions(subscribed_node_id);
        CREATE INDEX IF NOT EXISTS idx_node_subscriptions_service ON node_subscriptions(subscriber_service);
        -- 기존 의존성 인덱스
        CREATE INDEX IF NOT EXISTS idx_node_dependencies_dependent ON node_dependencies(dependent_node_id);
        CREATE INDEX IF NOT EXISTS idx_node_dependencies_dependency ON node_dependencies(dependency_node_id);
        
        -- 고도화된 의존성 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_v2_dependent ON node_dependencies_v2(dependent_node_id);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_dependency ON node_dependencies_v2(dependency_node_id);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_type ON node_dependencies_v2(dependency_type_id);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_active ON node_dependencies_v2(is_active);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_valid_from ON node_dependencies_v2(valid_from);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_valid_until ON node_dependencies_v2(valid_until);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_strength ON node_dependencies_v2(strength);
        CREATE INDEX IF NOT EXISTS idx_deps_v2_priority ON node_dependencies_v2(priority);
        
        -- 의존성 히스토리 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_history_dep ON dependency_history(dependency_id);
        CREATE INDEX IF NOT EXISTS idx_deps_history_action ON dependency_history(action);
        CREATE INDEX IF NOT EXISTS idx_deps_history_changed_at ON dependency_history(changed_at);
        
        -- 의존성 그래프 캐시 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_cache_node ON dependency_graph_cache(node_id);
        CREATE INDEX IF NOT EXISTS idx_deps_cache_expires ON dependency_graph_cache(expires_at);
        CREATE INDEX IF NOT EXISTS idx_deps_cache_computed ON dependency_graph_cache(computed_at);
        
        -- 의존성 영향 분석 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_impact_source ON dependency_impact_analysis(source_node_id);
        CREATE INDEX IF NOT EXISTS idx_deps_impact_type ON dependency_impact_analysis(impact_type);
        CREATE INDEX IF NOT EXISTS idx_deps_impact_analyzed ON dependency_impact_analysis(analyzed_at);
        
        -- 의존성 타입 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_types_name ON dependency_types(type_name);
        CREATE INDEX IF NOT EXISTS idx_deps_types_category ON dependency_types(category);
        
        -- 의존성 규칙 인덱스
        CREATE INDEX IF NOT EXISTS idx_deps_rules_domain ON dependency_rules(domain_id);
        CREATE INDEX IF NOT EXISTS idx_deps_rules_type ON dependency_rules(rule_type);
        CREATE INDEX IF NOT EXISTS idx_deps_rules_active ON dependency_rules(is_active);

        -- 트리거: updated_at 자동 업데이트
        CREATE TRIGGER IF NOT EXISTS domains_updated_at 
                AFTER UPDATE ON domains 
                FOR EACH ROW 
                BEGIN 
                        UPDATE domains SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
                END;

        CREATE TRIGGER IF NOT EXISTS nodes_updated_at 
                AFTER UPDATE ON nodes 
                FOR EACH ROW 
                BEGIN 
                        UPDATE nodes SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
                END;

        CREATE TRIGGER IF NOT EXISTS node_subscriptions_updated_at 
                AFTER UPDATE ON node_subscriptions 
                FOR EACH ROW 
                BEGIN 
                        UPDATE node_subscriptions SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
                END;

        -- 노드 이벤트 로그 테이블
        CREATE TABLE IF NOT EXISTS node_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                node_id INTEGER NOT NULL,
                event_type TEXT NOT NULL,             -- 'created', 'updated', 'deleted', 'attribute_changed'
                event_data TEXT,                      -- JSON: 이벤트 상세 데이터
                occurred_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                processed_at DATETIME,                -- 처리 완료 시간
                FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE
        );

        -- 이벤트 테이블 인덱스
        CREATE INDEX IF NOT EXISTS idx_events_node ON node_events(node_id);
        CREATE INDEX IF NOT EXISTS idx_events_type ON node_events(event_type);
        CREATE INDEX IF NOT EXISTS idx_events_occurred ON node_events(occurred_at);
        CREATE INDEX IF NOT EXISTS idx_events_unprocessed ON node_events(processed_at) WHERE processed_at IS NULL;

        -- 기본 의존성 타입 데이터 초기화
        INSERT OR IGNORE INTO dependency_types (type_name, category, cascade_delete, cascade_update, validation_required, description) VALUES
                ('hard', 'structural', true, true, true, 'Strong coupling dependency with cascading operations'),
                ('soft', 'structural', false, false, true, 'Loose coupling dependency without cascading'),
                ('reference', 'structural', false, false, false, 'Informational reference link only'),
                ('runtime', 'behavioral', false, true, true, 'Required at runtime execution'),
                ('compile', 'behavioral', false, false, true, 'Required at build/compile time'),
                ('optional', 'behavioral', false, false, false, 'Optional enhancement dependency'),
                ('sync', 'data', false, true, true, 'Synchronous data dependency'),
                ('async', 'data', false, false, false, 'Asynchronous data dependency');
        `
}</span>

func (d *Database) DB() *sql.DB <span class="cov8" title="1">{
        return d.db
}</span>

func (d *Database) Close() error <span class="cov8" title="1">{
        if d.db != nil </span><span class="cov8" title="1">{
                return d.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *Database) Ping() error <span class="cov8" title="1">{
        return d.db.Ping()
}</span>

func (d *Database) WithTransaction(fn func(*sql.Tx) error) error <span class="cov8" title="1">{
        tx, err := d.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        panic(r)</span>
                }
        }()

        <span class="cov8" title="1">if err := fn(tx); err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

// InitDB initializes the database with the given URL
func InitDB(url string) (*Database, error) <span class="cov0" title="0">{
        config := DefaultConfig()
        config.URL = url
        return New(config)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package repositories

import (
        "database/sql"
        "url-db/internal/models"
)

// sqliteAttributeRepository 는 SQLite 기반 속성 리포지토리 구현체입니다.
type sqliteAttributeRepository struct {
        *BaseRepository
}

// NewSQLiteAttributeRepository 는 새로운 SQLite 속성 리포지토리를 생성합니다.
func NewSQLiteAttributeRepository(db *sql.DB) AttributeRepository <span class="cov0" title="0">{
        return &amp;sqliteAttributeRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 속성을 생성합니다.
func (r *sqliteAttributeRepository) Create(attribute *models.Attribute) error <span class="cov0" title="0">{
        query := `
                INSERT INTO attributes (domain_id, name, type, description, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRow(query, attribute.DomainID, attribute.Name, attribute.Type, attribute.Description).Scan(
                &amp;attribute.ID, &amp;attribute.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID 는 ID로 속성을 조회합니다.
func (r *sqliteAttributeRepository) GetByID(id int) (*models.Attribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE id = ?
        `

        attribute := &amp;models.Attribute{}
        err := r.QueryRow(query, id).Scan(
                &amp;attribute.ID, &amp;attribute.DomainID, &amp;attribute.Name,
                &amp;attribute.Type, &amp;attribute.Description, &amp;attribute.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return attribute, nil</span>
}

// GetByDomainAndName 은 도메인 ID와 이름으로 속성을 조회합니다.
func (r *sqliteAttributeRepository) GetByDomainAndName(domainID int, name string) (*models.Attribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE domain_id = ? AND name = ?
        `

        attribute := &amp;models.Attribute{}
        err := r.QueryRow(query, domainID, name).Scan(
                &amp;attribute.ID, &amp;attribute.DomainID, &amp;attribute.Name,
                &amp;attribute.Type, &amp;attribute.Description, &amp;attribute.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return attribute, nil</span>
}

// ListByDomain 은 도메인별 속성 목록을 조회합니다.
func (r *sqliteAttributeRepository) ListByDomain(domainID int) ([]models.Attribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE domain_id = ?
                ORDER BY name
        `

        rows, err := r.Query(query, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var attributes []models.Attribute
        for rows.Next() </span><span class="cov0" title="0">{
                var attribute models.Attribute
                err := rows.Scan(&amp;attribute.ID, &amp;attribute.DomainID, &amp;attribute.Name,
                        &amp;attribute.Type, &amp;attribute.Description, &amp;attribute.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">attributes = append(attributes, attribute)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return attributes, nil</span>
}

// Update 는 속성 정보를 업데이트합니다.
func (r *sqliteAttributeRepository) Update(attribute *models.Attribute) error <span class="cov0" title="0">{
        query := `
                UPDATE attributes
                SET name = ?, type = ?, description = ?
                WHERE id = ?
        `

        result, err := r.Execute(query, attribute.Name, attribute.Type, attribute.Description, attribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete 는 속성을 삭제합니다.
func (r *sqliteAttributeRepository) Delete(id int) error <span class="cov0" title="0">{
        query := `DELETE FROM attributes WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExistsByDomainAndName 은 도메인 ID와 이름으로 속성 존재 여부를 확인합니다.
func (r *sqliteAttributeRepository) ExistsByDomainAndName(domainID int, name string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM attributes WHERE domain_id = ? AND name = ?)`

        var exists bool
        err := r.QueryRow(query, domainID, name).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// 트랜잭션 지원 메서드들

// CreateTx 는 트랜잭션 내에서 속성을 생성합니다.
func (r *sqliteAttributeRepository) CreateTx(tx *sql.Tx, attribute *models.Attribute) error <span class="cov0" title="0">{
        query := `
                INSERT INTO attributes (domain_id, name, type, description, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRowInTransaction(tx, query, attribute.DomainID, attribute.Name, attribute.Type, attribute.Description).Scan(
                &amp;attribute.ID, &amp;attribute.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 속성을 업데이트합니다.
func (r *sqliteAttributeRepository) UpdateTx(tx *sql.Tx, attribute *models.Attribute) error <span class="cov0" title="0">{
        query := `
                UPDATE attributes
                SET name = ?, type = ?, description = ?
                WHERE id = ?
        `

        result, err := r.ExecuteInTransaction(tx, query, attribute.Name, attribute.Type, attribute.Description, attribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 속성을 삭제합니다.
func (r *sqliteAttributeRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM attributes WHERE id = ?`

        result, err := r.ExecuteInTransaction(tx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package repositories

import (
        "database/sql"
)

// BaseRepository 는 모든 리포지토리의 공통 베이스 구조체입니다.
type BaseRepository struct {
        db *sql.DB
}

// NewBaseRepository 는 새로운 베이스 리포지토리를 생성합니다.
func NewBaseRepository(db *sql.DB) *BaseRepository <span class="cov8" title="1">{
        return &amp;BaseRepository{
                db: db,
        }
}</span>

// WithTransaction 은 트랜잭션을 사용하여 함수를 실행합니다.
func (r *BaseRepository) WithTransaction(fn func(tx *sql.Tx) error) error <span class="cov8" title="1">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        panic(r)</span>
                }
        }()

        <span class="cov8" title="1">if err := fn(tx); err != nil </span><span class="cov8" title="1">{
                if rbErr := tx.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                        // 롤백 실패 시 원래 에러와 함께 로그 (실제 구현에서는 로거 사용)
                        return MapSQLiteError(err)
                }</span>
                <span class="cov8" title="1">return MapSQLiteError(err)</span>
        }

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetDB 는 데이터베이스 연결을 반환합니다.
func (r *BaseRepository) GetDB() *sql.DB <span class="cov0" title="0">{
        return r.db
}</span>

// Ping 은 데이터베이스 연결을 확인합니다.
func (r *BaseRepository) Ping() error <span class="cov0" title="0">{
        return r.db.Ping()
}</span>

// Close 는 데이터베이스 연결을 닫습니다.
func (r *BaseRepository) Close() error <span class="cov0" title="0">{
        return r.db.Close()
}</span>

// ExecuteInTransaction 은 트랜잭션 내에서 쿼리를 실행합니다.
func (r *BaseRepository) ExecuteInTransaction(tx *sql.Tx, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        result, err := tx.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// QueryInTransaction 은 트랜잭션 내에서 쿼리를 실행하고 결과를 반환합니다.
func (r *BaseRepository) QueryInTransaction(tx *sql.Tx, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        rows, err := tx.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">return rows, nil</span>
}

// QueryRowInTransaction 은 트랜잭션 내에서 단일 행 쿼리를 실행합니다.
func (r *BaseRepository) QueryRowInTransaction(tx *sql.Tx, query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        return tx.QueryRow(query, args...)
}</span>

// PrepareStatement 는 프리페어드 스테이트먼트를 생성합니다.
func (r *BaseRepository) PrepareStatement(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">return stmt, nil</span>
}

// PrepareStatementInTransaction 은 트랜잭션 내에서 프리페어드 스테이트먼트를 생성합니다.
func (r *BaseRepository) PrepareStatementInTransaction(tx *sql.Tx, query string) (*sql.Stmt, error) <span class="cov8" title="1">{
        stmt, err := tx.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">return stmt, nil</span>
}

// Execute 는 쿼리를 실행합니다.
func (r *BaseRepository) Execute(query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        result, err := r.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// Query 는 쿼리를 실행하고 결과를 반환합니다.
func (r *BaseRepository) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">return rows, nil</span>
}

// QueryRow 는 단일 행 쿼리를 실행합니다.
func (r *BaseRepository) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        return r.db.QueryRow(query, args...)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package repositories

import (
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"
        "url-db/internal/models"
)

// DependencyRepository handles database operations for dependencies
type DependencyRepository struct {
        db *sqlx.DB
}

// NewDependencyRepository creates a new dependency repository
func NewDependencyRepository(db *sqlx.DB) *DependencyRepository <span class="cov0" title="0">{
        return &amp;DependencyRepository{db: db}
}</span>

// Create creates a new dependency
func (r *DependencyRepository) Create(dependency *models.NodeDependency) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_dependencies (
                        dependent_node_id, dependency_node_id, dependency_type,
                        cascade_delete, cascade_update, metadata
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(
                query,
                dependency.DependentNodeID,
                dependency.DependencyNodeID,
                dependency.DependencyType,
                dependency.CascadeDelete,
                dependency.CascadeUpdate,
                dependency.Metadata,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dependency: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov0" title="0">dependency.ID = id
        return nil</span>
}

// GetByID retrieves a dependency by ID
func (r *DependencyRepository) GetByID(id int64) (*models.NodeDependency, error) <span class="cov0" title="0">{
        var dependency models.NodeDependency
        query := `
                SELECT id, dependent_node_id, dependency_node_id, dependency_type,
                           cascade_delete, cascade_update, metadata, created_at
                FROM node_dependencies
                WHERE id = ?
        `

        err := r.db.Get(&amp;dependency, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get dependency: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;dependency, nil</span>
}

// GetByDependentNode retrieves all dependencies for a dependent node
func (r *DependencyRepository) GetByDependentNode(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        var dependencies []*models.NodeDependency
        query := `
                SELECT id, dependent_node_id, dependency_node_id, dependency_type,
                           cascade_delete, cascade_update, metadata, created_at
                FROM node_dependencies
                WHERE dependent_node_id = ?
                ORDER BY created_at DESC
        `

        err := r.db.Select(&amp;dependencies, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependencies: %w", err)
        }</span>

        <span class="cov0" title="0">return dependencies, nil</span>
}

// GetByDependencyNode retrieves all dependencies where a node is the dependency
func (r *DependencyRepository) GetByDependencyNode(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        var dependencies []*models.NodeDependency
        query := `
                SELECT id, dependent_node_id, dependency_node_id, dependency_type,
                           cascade_delete, cascade_update, metadata, created_at
                FROM node_dependencies
                WHERE dependency_node_id = ?
                ORDER BY created_at DESC
        `

        err := r.db.Select(&amp;dependencies, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependencies: %w", err)
        }</span>

        <span class="cov0" title="0">return dependencies, nil</span>
}

// CheckCircularDependency checks if creating a dependency would create a circular reference
func (r *DependencyRepository) CheckCircularDependency(dependentID, dependencyID int64) (bool, error) <span class="cov0" title="0">{
        // Recursive CTE to check for circular dependencies
        query := `
                WITH RECURSIVE dependency_chain AS (
                        SELECT dependent_node_id, dependency_node_id
                        FROM node_dependencies
                        WHERE dependent_node_id = ?
                        
                        UNION
                        
                        SELECT nd.dependent_node_id, nd.dependency_node_id
                        FROM node_dependencies nd
                        INNER JOIN dependency_chain dc ON nd.dependent_node_id = dc.dependency_node_id
                )
                SELECT COUNT(*) FROM dependency_chain WHERE dependency_node_id = ?
        `

        var count int
        err := r.db.Get(&amp;count, query, dependencyID, dependentID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check circular dependency: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// Delete deletes a dependency
func (r *DependencyRepository) Delete(id int64) error <span class="cov0" title="0">{
        query := "DELETE FROM node_dependencies WHERE id = ?"

        result, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete dependency: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDependentsWithCascadeDelete retrieves all dependent nodes that should be deleted
func (r *DependencyRepository) GetDependentsWithCascadeDelete(nodeID int64) ([]int64, error) <span class="cov0" title="0">{
        var dependentIDs []int64
        query := `
                SELECT dependent_node_id
                FROM node_dependencies
                WHERE dependency_node_id = ? AND cascade_delete = true
        `

        err := r.db.Select(&amp;dependentIDs, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cascade delete dependents: %w", err)
        }</span>

        <span class="cov0" title="0">return dependentIDs, nil</span>
}

// GetDependentsWithCascadeUpdate retrieves all dependent nodes that should be notified
func (r *DependencyRepository) GetDependentsWithCascadeUpdate(nodeID int64) ([]int64, error) <span class="cov0" title="0">{
        var dependentIDs []int64
        query := `
                SELECT dependent_node_id
                FROM node_dependencies
                WHERE dependency_node_id = ? AND cascade_update = true
        `

        err := r.db.Select(&amp;dependentIDs, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cascade update dependents: %w", err)
        }</span>

        <span class="cov0" title="0">return dependentIDs, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package repositories

import (
        "database/sql"
        "url-db/internal/models"
)

// sqliteDomainRepository 는 SQLite 기반 도메인 리포지토리 구현체입니다.
type sqliteDomainRepository struct {
        *BaseRepository
}

// NewSQLiteDomainRepository 는 새로운 SQLite 도메인 리포지토리를 생성합니다.
func NewSQLiteDomainRepository(db *sql.DB) DomainRepository <span class="cov8" title="1">{
        return &amp;sqliteDomainRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 도메인을 생성합니다.
func (r *sqliteDomainRepository) Create(domain *models.Domain) error <span class="cov8" title="1">{
        query := `
                INSERT INTO domains (name, description, created_at, updated_at)
                VALUES (?, ?, datetime('now'), datetime('now'))
                RETURNING id, created_at, updated_at
        `

        err := r.QueryRow(query, domain.Name, domain.Description).Scan(
                &amp;domain.ID, &amp;domain.CreatedAt, &amp;domain.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetByID 는 ID로 도메인을 조회합니다.
func (r *sqliteDomainRepository) GetByID(id int) (*models.Domain, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM domains
                WHERE id = ?
        `

        domain := &amp;models.Domain{}
        err := r.QueryRow(query, id).Scan(
                &amp;domain.ID, &amp;domain.Name, &amp;domain.Description,
                &amp;domain.CreatedAt, &amp;domain.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return domain, nil</span>
}

// GetByName 은 이름으로 도메인을 조회합니다.
func (r *sqliteDomainRepository) GetByName(name string) (*models.Domain, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM domains
                WHERE name = ?
        `

        domain := &amp;models.Domain{}
        err := r.QueryRow(query, name).Scan(
                &amp;domain.ID, &amp;domain.Name, &amp;domain.Description,
                &amp;domain.CreatedAt, &amp;domain.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return domain, nil</span>
}

// List 는 도메인 목록을 페이지네이션과 함께 조회합니다.
func (r *sqliteDomainRepository) List(offset, limit int) ([]models.Domain, int, error) <span class="cov8" title="1">{
        // 데이터 조회
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM domains
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var domains []models.Domain
        for rows.Next() </span><span class="cov8" title="1">{
                var domain models.Domain
                err := rows.Scan(&amp;domain.ID, &amp;domain.Name, &amp;domain.Description,
                        &amp;domain.CreatedAt, &amp;domain.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov8" title="1">domains = append(domains, domain)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov8" title="1">countQuery := `SELECT COUNT(*) FROM domains`
        var total int
        err = r.QueryRow(countQuery).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return domains, total, nil</span>
}

// Update 는 도메인 정보를 업데이트합니다.
func (r *sqliteDomainRepository) Update(domain *models.Domain) error <span class="cov8" title="1">{
        query := `
                UPDATE domains
                SET name = ?, description = ?, updated_at = datetime('now')
                WHERE id = ?
                RETURNING updated_at
        `

        err := r.QueryRow(query, domain.Name, domain.Description, domain.ID).Scan(
                &amp;domain.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete 는 도메인을 삭제합니다.
func (r *sqliteDomainRepository) Delete(id int) error <span class="cov8" title="1">{
        query := `DELETE FROM domains WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ExistsByName 은 이름으로 도메인 존재 여부를 확인합니다.
func (r *sqliteDomainRepository) ExistsByName(name string) (bool, error) <span class="cov8" title="1">{
        query := `SELECT EXISTS(SELECT 1 FROM domains WHERE name = ?)`

        var exists bool
        err := r.QueryRow(query, name).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// 트랜잭션 지원 메서드들

// CreateTx 는 트랜잭션 내에서 도메인을 생성합니다.
func (r *sqliteDomainRepository) CreateTx(tx *sql.Tx, domain *models.Domain) error <span class="cov8" title="1">{
        query := `
                INSERT INTO domains (name, description, created_at, updated_at)
                VALUES (?, ?, datetime('now'), datetime('now'))
                RETURNING id, created_at, updated_at
        `

        err := r.QueryRowInTransaction(tx, query, domain.Name, domain.Description).Scan(
                &amp;domain.ID, &amp;domain.CreatedAt, &amp;domain.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 도메인을 업데이트합니다.
func (r *sqliteDomainRepository) UpdateTx(tx *sql.Tx, domain *models.Domain) error <span class="cov0" title="0">{
        query := `
                UPDATE domains
                SET name = ?, description = ?, updated_at = datetime('now')
                WHERE id = ?
                RETURNING updated_at
        `

        err := r.QueryRowInTransaction(tx, query, domain.Name, domain.Description, domain.ID).Scan(
                &amp;domain.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrDomainNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 도메인을 삭제합니다.
func (r *sqliteDomainRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM domains WHERE id = ?`

        result, err := r.ExecuteInTransaction(tx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrDomainNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package repositories

import (
        "database/sql"
        "errors"
        "strings"
)

// 리포지토리 에러 정의
var (
        ErrDomainNotFound         = errors.New("domain not found")
        ErrNodeNotFound           = errors.New("node not found")
        ErrAttributeNotFound      = errors.New("attribute not found")
        ErrNodeAttributeNotFound  = errors.New("node attribute not found")
        ErrNodeConnectionNotFound = errors.New("node connection not found")
        ErrDuplicateEntry         = errors.New("duplicate entry")
        ErrForeignKeyConstraint   = errors.New("foreign key constraint violation")
        ErrInvalidInput           = errors.New("invalid input")
        ErrConnectionTimeout      = errors.New("database connection timeout")
        ErrTransactionFailed      = errors.New("transaction failed")
)

// SQLiteError 는 SQLite 관련 에러를 처리하는 구조체입니다.
type SQLiteError struct {
        Code    int
        Message string
        Query   string
}

func (e SQLiteError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// MapSQLiteError 는 SQLite 에러를 도메인 에러로 매핑합니다.
func MapSQLiteError(err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // sql.ErrNoRows 처리
        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrDomainNotFound // 기본값, 각 리포지토리에서 적절히 변경
        }</span>

        // SQLite 에러 처리 (문자열 기반)
        <span class="cov8" title="1">errStr := err.Error()
        if strings.Contains(errStr, "UNIQUE constraint failed") </span><span class="cov8" title="1">{
                return ErrDuplicateEntry
        }</span>
        <span class="cov8" title="1">if strings.Contains(errStr, "FOREIGN KEY constraint failed") </span><span class="cov0" title="0">{
                return ErrForeignKeyConstraint
        }</span>
        <span class="cov8" title="1">if strings.Contains(errStr, "CHECK constraint failed") ||
                strings.Contains(errStr, "NOT NULL constraint failed") </span><span class="cov0" title="0">{
                return ErrInvalidInput
        }</span>
        <span class="cov8" title="1">if strings.Contains(errStr, "database is locked") ||
                strings.Contains(errStr, "database is busy") </span><span class="cov0" title="0">{
                return ErrConnectionTimeout
        }</span>

        <span class="cov8" title="1">return err</span>
}

// IsNotFoundError 는 해당 에러가 "찾을 수 없음" 에러인지 확인합니다.
func IsNotFoundError(err error) bool <span class="cov0" title="0">{
        return err == ErrDomainNotFound ||
                err == ErrNodeNotFound ||
                err == ErrAttributeNotFound ||
                err == ErrNodeAttributeNotFound ||
                err == ErrNodeConnectionNotFound
}</span>

// IsDuplicateError 는 해당 에러가 중복 에러인지 확인합니다.
func IsDuplicateError(err error) bool <span class="cov0" title="0">{
        return err == ErrDuplicateEntry
}</span>

// IsForeignKeyError 는 해당 에러가 외래키 제약 조건 에러인지 확인합니다.
func IsForeignKeyError(err error) bool <span class="cov0" title="0">{
        return err == ErrForeignKeyConstraint
}</span>

// IsInvalidInputError 는 해당 에러가 잘못된 입력 에러인지 확인합니다.
func IsInvalidInputError(err error) bool <span class="cov0" title="0">{
        return err == ErrInvalidInput
}</span>

// IsConnectionError 는 해당 에러가 연결 관련 에러인지 확인합니다.
func IsConnectionError(err error) bool <span class="cov0" title="0">{
        return err == ErrConnectionTimeout
}</span>

// IsTransactionError 는 해당 에러가 트랜잭션 관련 에러인지 확인합니다.
func IsTransactionError(err error) bool <span class="cov0" title="0">{
        return err == ErrTransactionFailed
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package repositories

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/jmoiron/sqlx"
        "url-db/internal/models"
)

// EventRepository handles database operations for events
type EventRepository struct {
        db *sqlx.DB
}

// NewEventRepository creates a new event repository
func NewEventRepository(db *sqlx.DB) *EventRepository <span class="cov0" title="0">{
        return &amp;EventRepository{db: db}
}</span>

// Create creates a new event
func (r *EventRepository) Create(event *models.NodeEvent) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_events (
                        node_id, event_type, event_data
                ) VALUES (?, ?, ?)
        `

        result, err := r.db.Exec(
                query,
                event.NodeID,
                event.EventType,
                event.EventData,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create event: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov0" title="0">event.ID = id
        return nil</span>
}

// GetByID retrieves an event by ID
func (r *EventRepository) GetByID(id int64) (*models.NodeEvent, error) <span class="cov0" title="0">{
        var event models.NodeEvent
        query := `
                SELECT id, node_id, event_type, event_data, occurred_at, processed_at
                FROM node_events
                WHERE id = ?
        `

        err := r.db.Get(&amp;event, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get event: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;event, nil</span>
}

// GetByNode retrieves all events for a specific node
func (r *EventRepository) GetByNode(nodeID int64, limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        var events []*models.NodeEvent
        query := `
                SELECT id, node_id, event_type, event_data, occurred_at, processed_at
                FROM node_events
                WHERE node_id = ?
                ORDER BY occurred_at DESC
                LIMIT ?
        `

        err := r.db.Select(&amp;events, query, nodeID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get events: %w", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// GetPendingEvents retrieves unprocessed events
func (r *EventRepository) GetPendingEvents(limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        var events []*models.NodeEvent
        query := `
                SELECT id, node_id, event_type, event_data, occurred_at, processed_at
                FROM node_events
                WHERE processed_at IS NULL
                ORDER BY occurred_at ASC
                LIMIT ?
        `

        err := r.db.Select(&amp;events, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending events: %w", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// MarkAsProcessed marks an event as processed
func (r *EventRepository) MarkAsProcessed(id int64) error <span class="cov0" title="0">{
        query := "UPDATE node_events SET processed_at = ? WHERE id = ?"

        _, err := r.db.Exec(query, time.Now(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark event as processed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByTypeAndDateRange retrieves events by type within a date range
func (r *EventRepository) GetByTypeAndDateRange(eventType string, start, end time.Time) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        var events []*models.NodeEvent
        query := `
                SELECT id, node_id, event_type, event_data, occurred_at, processed_at
                FROM node_events
                WHERE event_type = ? AND occurred_at BETWEEN ? AND ?
                ORDER BY occurred_at DESC
        `

        err := r.db.Select(&amp;events, query, eventType, start, end)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get events by type and date: %w", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// DeleteOldEvents deletes events older than the specified duration
func (r *EventRepository) DeleteOldEvents(olderThan time.Duration) (int64, error) <span class="cov0" title="0">{
        cutoffTime := time.Now().Add(-olderThan)
        query := "DELETE FROM node_events WHERE occurred_at &lt; ? AND processed_at IS NOT NULL"

        result, err := r.db.Exec(query, cutoffTime)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to delete old events: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// GetEventStats retrieves statistics about events
func (r *EventRepository) GetEventStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Total events
        var totalEvents int
        err := r.db.Get(&amp;totalEvents, "SELECT COUNT(*) FROM node_events")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total events: %w", err)
        }</span>
        <span class="cov0" title="0">stats["total_events"] = totalEvents

        // Pending events
        var pendingEvents int
        err = r.db.Get(&amp;pendingEvents, "SELECT COUNT(*) FROM node_events WHERE processed_at IS NULL")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending events: %w", err)
        }</span>
        <span class="cov0" title="0">stats["pending_events"] = pendingEvents

        // Events by type
        type eventTypeCount struct {
                EventType string `db:"event_type"`
                Count     int    `db:"count"`
        }
        var eventTypeCounts []eventTypeCount

        query := `
                SELECT event_type, COUNT(*) as count
                FROM node_events
                GROUP BY event_type
                ORDER BY count DESC
        `
        err = r.db.Select(&amp;eventTypeCounts, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get events by type: %w", err)
        }</span>

        <span class="cov0" title="0">eventsByType := make(map[string]int)
        for _, etc := range eventTypeCounts </span><span class="cov0" title="0">{
                eventsByType[etc.EventType] = etc.Count
        }</span>
        <span class="cov0" title="0">stats["events_by_type"] = eventsByType

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "url-db/internal/models"
)

// DomainRepository 는 도메인 데이터 접근을 위한 인터페이스입니다.
type DomainRepository interface {
        Create(domain *models.Domain) error
        GetByID(id int) (*models.Domain, error)
        GetByName(name string) (*models.Domain, error)
        List(offset, limit int) ([]models.Domain, int, error)
        Update(domain *models.Domain) error
        Delete(id int) error
        ExistsByName(name string) (bool, error)

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, domain *models.Domain) error
        UpdateTx(tx *sql.Tx, domain *models.Domain) error
        DeleteTx(tx *sql.Tx, id int) error
}

// NodeRepository 는 노드 데이터 접근을 위한 인터페이스입니다.
type NodeRepository interface {
        Create(node *models.Node) error
        GetByID(id int) (*models.Node, error)
        GetByDomainAndContent(domainID int, content string) (*models.Node, error)
        ListByDomain(domainID int, offset, limit int) ([]models.Node, int, error)
        Search(domainID int, query string, offset, limit int) ([]models.Node, int, error)
        Update(node *models.Node) error
        Delete(id int) error
        ExistsByDomainAndContent(domainID int, content string) (bool, error)
        CountNodesByDomain(ctx context.Context, domainID int) (int, error)

        // 배치 처리 메서드
        BatchCreate(nodes []models.Node) error
        BatchUpdate(nodes []models.Node) error
        BatchDelete(ids []int) error

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, node *models.Node) error
        UpdateTx(tx *sql.Tx, node *models.Node) error
        DeleteTx(tx *sql.Tx, id int) error
}

// AttributeRepository 는 속성 데이터 접근을 위한 인터페이스입니다.
type AttributeRepository interface {
        Create(attribute *models.Attribute) error
        GetByID(id int) (*models.Attribute, error)
        GetByDomainAndName(domainID int, name string) (*models.Attribute, error)
        ListByDomain(domainID int) ([]models.Attribute, error)
        Update(attribute *models.Attribute) error
        Delete(id int) error
        ExistsByDomainAndName(domainID int, name string) (bool, error)

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, attribute *models.Attribute) error
        UpdateTx(tx *sql.Tx, attribute *models.Attribute) error
        DeleteTx(tx *sql.Tx, id int) error
}

// NodeAttributeRepository 는 노드 속성 데이터 접근을 위한 인터페이스입니다.
type NodeAttributeRepository interface {
        Create(nodeAttribute *models.NodeAttribute) error
        GetByID(id int) (*models.NodeAttribute, error)
        GetByNodeAndAttribute(nodeID, attributeID int) (*models.NodeAttribute, error)
        ListByNode(nodeID int) ([]models.NodeAttributeWithInfo, error)
        ListByAttribute(attributeID int) ([]models.NodeAttribute, error)
        Update(nodeAttribute *models.NodeAttribute) error
        Delete(id int) error
        DeleteByNode(nodeID int) error
        DeleteByAttribute(attributeID int) error
        ExistsByNodeAndAttribute(nodeID, attributeID int) (bool, error)

        // 배치 처리 메서드
        BatchCreate(nodeAttributes []models.NodeAttribute) error
        BatchUpdate(nodeAttributes []models.NodeAttribute) error
        BatchDeleteByNode(nodeID int) error
        BatchDeleteByAttribute(attributeID int) error

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, nodeAttribute *models.NodeAttribute) error
        UpdateTx(tx *sql.Tx, nodeAttribute *models.NodeAttribute) error
        DeleteTx(tx *sql.Tx, id int) error
}

// NodeConnectionRepository 는 노드 연결 데이터 접근을 위한 인터페이스입니다.
type NodeConnectionRepository interface {
        Create(ctx context.Context, connection *models.NodeConnection) error
        GetByID(ctx context.Context, id int) (*models.NodeConnection, error)
        GetBySourceAndTarget(ctx context.Context, sourceNodeID, targetNodeID int, relationshipType string) (*models.NodeConnection, error)
        ListBySourceNode(ctx context.Context, sourceNodeID int, offset, limit int) ([]models.NodeConnectionWithInfo, int, error)
        ListByTargetNode(ctx context.Context, targetNodeID int, offset, limit int) ([]models.NodeConnectionWithInfo, int, error)
        ListByRelationshipType(ctx context.Context, relationshipType string, offset, limit int) ([]models.NodeConnectionWithInfo, int, error)
        Update(ctx context.Context, connection *models.NodeConnection) error
        Delete(ctx context.Context, id int) error
        DeleteBySourceNode(ctx context.Context, sourceNodeID int) error
        DeleteByTargetNode(ctx context.Context, targetNodeID int) error
        ExistsBySourceAndTarget(ctx context.Context, sourceNodeID, targetNodeID int, relationshipType string) (bool, error)

        // 배치 처리 메서드
        BatchCreate(ctx context.Context, connections []models.NodeConnection) error
        BatchDelete(ctx context.Context, ids []int) error

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, connection *models.NodeConnection) error
        UpdateTx(tx *sql.Tx, connection *models.NodeConnection) error
        DeleteTx(tx *sql.Tx, id int) error
}

// Transactional 은 트랜잭션을 지원하는 인터페이스입니다.
type Transactional interface {
        WithTransaction(fn func(tx *sql.Tx) error) error
}

// Repositories 는 모든 리포지토리를 포함하는 구조체입니다.
type Repositories struct {
        Domain        DomainRepository
        Node          NodeRepository
        Attribute     AttributeRepository
        NodeAttribute NodeAttributeRepository
}

// NewRepositories 는 새로운 리포지토리 컬렉션을 생성합니다.
func NewRepositories(db *sql.DB) *Repositories <span class="cov0" title="0">{
        return &amp;Repositories{
                Domain:        NewSQLiteDomainRepository(db),
                Node:          NewSQLiteNodeRepository(db),
                Attribute:     NewSQLiteAttributeRepository(db),
                NodeAttribute: NewSQLiteNodeAttributeRepository(db),
        }
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "url-db/internal/models"
)

// sqliteNodeRepository 는 SQLite 기반 노드 리포지토리 구현체입니다.
type sqliteNodeRepository struct {
        *BaseRepository
}

// NewSQLiteNodeRepository 는 새로운 SQLite 노드 리포지토리를 생성합니다.
func NewSQLiteNodeRepository(db *sql.DB) NodeRepository <span class="cov8" title="1">{
        return &amp;sqliteNodeRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 노드를 생성합니다.
func (r *sqliteNodeRepository) Create(node *models.Node) error <span class="cov8" title="1">{
        query := `
                INSERT INTO nodes (content, domain_id, title, description, created_at, updated_at)
                VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))
                RETURNING id, created_at, updated_at
        `

        err := r.QueryRow(query, node.Content, node.DomainID, node.Title, node.Description).Scan(
                &amp;node.ID, &amp;node.CreatedAt, &amp;node.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetByID 는 ID로 노드를 조회합니다.
func (r *sqliteNodeRepository) GetByID(id int) (*models.Node, error) <span class="cov8" title="1">{
        query := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE id = ?
        `

        node := &amp;models.Node{}
        err := r.QueryRow(query, id).Scan(
                &amp;node.ID, &amp;node.Content, &amp;node.DomainID, &amp;node.Title,
                &amp;node.Description, &amp;node.CreatedAt, &amp;node.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return node, nil</span>
}

// GetByDomainAndContent 는 도메인 ID와 콘텐츠로 노드를 조회합니다.
func (r *sqliteNodeRepository) GetByDomainAndContent(domainID int, content string) (*models.Node, error) <span class="cov8" title="1">{
        query := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE domain_id = ? AND content = ?
        `

        node := &amp;models.Node{}
        err := r.QueryRow(query, domainID, content).Scan(
                &amp;node.ID, &amp;node.Content, &amp;node.DomainID, &amp;node.Title,
                &amp;node.Description, &amp;node.CreatedAt, &amp;node.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return node, nil</span>
}

// ListByDomain 은 도메인별 노드 목록을 페이지네이션과 함께 조회합니다.
func (r *sqliteNodeRepository) ListByDomain(domainID int, offset, limit int) ([]models.Node, int, error) <span class="cov8" title="1">{
        // 데이터 조회
        query := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE domain_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, domainID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var nodes []models.Node
        for rows.Next() </span><span class="cov8" title="1">{
                var node models.Node
                err := rows.Scan(&amp;node.ID, &amp;node.Content, &amp;node.DomainID, &amp;node.Title,
                        &amp;node.Description, &amp;node.CreatedAt, &amp;node.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov8" title="1">nodes = append(nodes, node)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov8" title="1">countQuery := `SELECT COUNT(*) FROM nodes WHERE domain_id = ?`
        var total int
        err = r.QueryRow(countQuery, domainID).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nodes, total, nil</span>
}

// Search 는 도메인 내에서 노드를 검색합니다.
func (r *sqliteNodeRepository) Search(domainID int, query string, offset, limit int) ([]models.Node, int, error) <span class="cov8" title="1">{
        // 데이터 검색
        searchQuery := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE domain_id = ? AND (title LIKE ? OR content LIKE ? OR description LIKE ?)
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        searchPattern := "%" + query + "%"
        rows, err := r.Query(searchQuery, domainID, searchPattern, searchPattern, searchPattern, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var nodes []models.Node
        for rows.Next() </span><span class="cov8" title="1">{
                var node models.Node
                err := rows.Scan(&amp;node.ID, &amp;node.Content, &amp;node.DomainID, &amp;node.Title,
                        &amp;node.Description, &amp;node.CreatedAt, &amp;node.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov8" title="1">nodes = append(nodes, node)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov8" title="1">countQuery := `
                SELECT COUNT(*)
                FROM nodes
                WHERE domain_id = ? AND (title LIKE ? OR content LIKE ? OR description LIKE ?)
        `

        var total int
        err = r.QueryRow(countQuery, domainID, searchPattern, searchPattern, searchPattern).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nodes, total, nil</span>
}

// Update 는 노드 정보를 업데이트합니다.
func (r *sqliteNodeRepository) Update(node *models.Node) error <span class="cov8" title="1">{
        query := `
                UPDATE nodes
                SET content = ?, title = ?, description = ?, updated_at = datetime('now')
                WHERE id = ?
                RETURNING updated_at
        `

        err := r.QueryRow(query, node.Content, node.Title, node.Description, node.ID).Scan(
                &amp;node.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete 는 노드를 삭제합니다.
func (r *sqliteNodeRepository) Delete(id int) error <span class="cov8" title="1">{
        query := `DELETE FROM nodes WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ExistsByDomainAndContent 는 도메인 ID와 콘텐츠로 노드 존재 여부를 확인합니다.
func (r *sqliteNodeRepository) ExistsByDomainAndContent(domainID int, content string) (bool, error) <span class="cov8" title="1">{
        query := `SELECT EXISTS(SELECT 1 FROM nodes WHERE domain_id = ? AND content = ?)`

        var exists bool
        err := r.QueryRow(query, domainID, content).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// CountNodesByDomain 는 도메인별 노드 수를 반환합니다.
func (r *sqliteNodeRepository) CountNodesByDomain(ctx context.Context, domainID int) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM nodes WHERE domain_id = ?`

        var count int
        err := r.QueryRow(query, domainID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// BatchCreate 는 여러 노드를 배치로 생성합니다.
func (r *sqliteNodeRepository) BatchCreate(nodes []models.Node) error <span class="cov8" title="1">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        INSERT INTO nodes (content, domain_id, title, description, created_at, updated_at)
                        VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer stmt.Close()

                for _, node := range nodes </span><span class="cov8" title="1">{
                        _, err := stmt.Exec(node.Content, node.DomainID, node.Title, node.Description)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

// BatchUpdate 는 여러 노드를 배치로 업데이트합니다.
func (r *sqliteNodeRepository) BatchUpdate(nodes []models.Node) error <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        UPDATE nodes
                        SET content = ?, title = ?, description = ?, updated_at = datetime('now')
                        WHERE id = ?
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, node := range nodes </span><span class="cov0" title="0">{
                        _, err := stmt.Exec(node.Content, node.Title, node.Description, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// BatchDelete 는 여러 노드를 배치로 삭제합니다.
func (r *sqliteNodeRepository) BatchDelete(ids []int) error <span class="cov8" title="1">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                stmt, err := r.PrepareStatementInTransaction(tx, `DELETE FROM nodes WHERE id = ?`)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer stmt.Close()

                for _, id := range ids </span><span class="cov8" title="1">{
                        _, err := stmt.Exec(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

// 트랜잭션 지원 메서드들

// CreateTx 는 트랜잭션 내에서 노드를 생성합니다.
func (r *sqliteNodeRepository) CreateTx(tx *sql.Tx, node *models.Node) error <span class="cov0" title="0">{
        query := `
                INSERT INTO nodes (content, domain_id, title, description, created_at, updated_at)
                VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))
                RETURNING id, created_at, updated_at
        `

        err := r.QueryRowInTransaction(tx, query, node.Content, node.DomainID, node.Title, node.Description).Scan(
                &amp;node.ID, &amp;node.CreatedAt, &amp;node.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 노드를 업데이트합니다.
func (r *sqliteNodeRepository) UpdateTx(tx *sql.Tx, node *models.Node) error <span class="cov0" title="0">{
        query := `
                UPDATE nodes
                SET content = ?, title = ?, description = ?, updated_at = datetime('now')
                WHERE id = ?
                RETURNING updated_at
        `

        err := r.QueryRowInTransaction(tx, query, node.Content, node.Title, node.Description, node.ID).Scan(
                &amp;node.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNodeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 노드를 삭제합니다.
func (r *sqliteNodeRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM nodes WHERE id = ?`

        result, err := r.ExecuteInTransaction(tx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package repositories

import (
        "database/sql"
        "url-db/internal/models"
)

// sqliteNodeAttributeRepository 는 SQLite 기반 노드 속성 리포지토리 구현체입니다.
type sqliteNodeAttributeRepository struct {
        *BaseRepository
}

// NewSQLiteNodeAttributeRepository 는 새로운 SQLite 노드 속성 리포지토리를 생성합니다.
func NewSQLiteNodeAttributeRepository(db *sql.DB) NodeAttributeRepository <span class="cov0" title="0">{
        return &amp;sqliteNodeAttributeRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 노드 속성을 생성합니다.
func (r *sqliteNodeAttributeRepository) Create(nodeAttribute *models.NodeAttribute) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_attributes (node_id, attribute_id, value, order_index, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRow(query, nodeAttribute.NodeID, nodeAttribute.AttributeID,
                nodeAttribute.Value, nodeAttribute.OrderIndex).Scan(
                &amp;nodeAttribute.ID, &amp;nodeAttribute.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID 는 ID로 노드 속성을 조회합니다.
func (r *sqliteNodeAttributeRepository) GetByID(id int) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, node_id, attribute_id, value, order_index, created_at
                FROM node_attributes
                WHERE id = ?
        `

        nodeAttribute := &amp;models.NodeAttribute{}
        err := r.QueryRow(query, id).Scan(
                &amp;nodeAttribute.ID, &amp;nodeAttribute.NodeID, &amp;nodeAttribute.AttributeID,
                &amp;nodeAttribute.Value, &amp;nodeAttribute.OrderIndex, &amp;nodeAttribute.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nodeAttribute, nil</span>
}

// GetByNodeAndAttribute 는 노드 ID와 속성 ID로 노드 속성을 조회합니다.
func (r *sqliteNodeAttributeRepository) GetByNodeAndAttribute(nodeID, attributeID int) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, node_id, attribute_id, value, order_index, created_at
                FROM node_attributes
                WHERE node_id = ? AND attribute_id = ?
        `

        nodeAttribute := &amp;models.NodeAttribute{}
        err := r.QueryRow(query, nodeID, attributeID).Scan(
                &amp;nodeAttribute.ID, &amp;nodeAttribute.NodeID, &amp;nodeAttribute.AttributeID,
                &amp;nodeAttribute.Value, &amp;nodeAttribute.OrderIndex, &amp;nodeAttribute.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nodeAttribute, nil</span>
}

// ListByNode 은 노드 ID로 노드 속성 목록을 조회합니다 (속성 정보 포함).
func (r *sqliteNodeAttributeRepository) ListByNode(nodeID int) ([]models.NodeAttributeWithInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT na.id, na.node_id, na.attribute_id, na.value, na.order_index, na.created_at,
                       a.name, a.type
                FROM node_attributes na
                JOIN attributes a ON na.attribute_id = a.id
                WHERE na.node_id = ?
                ORDER BY a.name, na.order_index
        `

        rows, err := r.Query(query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var attributes []models.NodeAttributeWithInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var attr models.NodeAttributeWithInfo
                err := rows.Scan(&amp;attr.ID, &amp;attr.NodeID, &amp;attr.AttributeID,
                        &amp;attr.Value, &amp;attr.OrderIndex, &amp;attr.CreatedAt,
                        &amp;attr.Name, &amp;attr.Type)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">attributes = append(attributes, attr)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return attributes, nil</span>
}

// ListByAttribute 는 속성 ID로 노드 속성 목록을 조회합니다.
func (r *sqliteNodeAttributeRepository) ListByAttribute(attributeID int) ([]models.NodeAttribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, node_id, attribute_id, value, order_index, created_at
                FROM node_attributes
                WHERE attribute_id = ?
                ORDER BY order_index
        `

        rows, err := r.Query(query, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var nodeAttributes []models.NodeAttribute
        for rows.Next() </span><span class="cov0" title="0">{
                var nodeAttribute models.NodeAttribute
                err := rows.Scan(&amp;nodeAttribute.ID, &amp;nodeAttribute.NodeID, &amp;nodeAttribute.AttributeID,
                        &amp;nodeAttribute.Value, &amp;nodeAttribute.OrderIndex, &amp;nodeAttribute.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">nodeAttributes = append(nodeAttributes, nodeAttribute)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nodeAttributes, nil</span>
}

// Update 는 노드 속성 정보를 업데이트합니다.
func (r *sqliteNodeAttributeRepository) Update(nodeAttribute *models.NodeAttribute) error <span class="cov0" title="0">{
        query := `
                UPDATE node_attributes
                SET value = ?, order_index = ?
                WHERE id = ?
        `

        result, err := r.Execute(query, nodeAttribute.Value, nodeAttribute.OrderIndex, nodeAttribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete 는 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) Delete(id int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteByNode 는 노드 ID로 모든 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) DeleteByNode(nodeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE node_id = ?`

        _, err := r.Execute(query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteByAttribute 는 속성 ID로 모든 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) DeleteByAttribute(attributeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE attribute_id = ?`

        _, err := r.Execute(query, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExistsByNodeAndAttribute 는 노드 ID와 속성 ID로 노드 속성 존재 여부를 확인합니다.
func (r *sqliteNodeAttributeRepository) ExistsByNodeAndAttribute(nodeID, attributeID int) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM node_attributes WHERE node_id = ? AND attribute_id = ?)`

        var exists bool
        err := r.QueryRow(query, nodeID, attributeID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// BatchCreate 는 여러 노드 속성을 배치로 생성합니다.
func (r *sqliteNodeAttributeRepository) BatchCreate(nodeAttributes []models.NodeAttribute) error <span class="cov0" title="0">{
        if len(nodeAttributes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        INSERT INTO node_attributes (node_id, attribute_id, value, order_index, created_at)
                        VALUES (?, ?, ?, ?, datetime('now'))
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, nodeAttribute := range nodeAttributes </span><span class="cov0" title="0">{
                        _, err := stmt.Exec(nodeAttribute.NodeID, nodeAttribute.AttributeID,
                                nodeAttribute.Value, nodeAttribute.OrderIndex)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// BatchUpdate 는 여러 노드 속성을 배치로 업데이트합니다.
func (r *sqliteNodeAttributeRepository) BatchUpdate(nodeAttributes []models.NodeAttribute) error <span class="cov0" title="0">{
        if len(nodeAttributes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        UPDATE node_attributes
                        SET value = ?, order_index = ?
                        WHERE id = ?
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, nodeAttribute := range nodeAttributes </span><span class="cov0" title="0">{
                        _, err := stmt.Exec(nodeAttribute.Value, nodeAttribute.OrderIndex, nodeAttribute.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// BatchDeleteByNode 는 노드 ID로 모든 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) BatchDeleteByNode(nodeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE node_id = ?`

        _, err := r.Execute(query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// BatchDeleteByAttribute 는 속성 ID로 모든 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) BatchDeleteByAttribute(attributeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE attribute_id = ?`

        _, err := r.Execute(query, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// 트랜잭션 지원 메서드들

// CreateTx 는 트랜잭션 내에서 노드 속성을 생성합니다.
func (r *sqliteNodeAttributeRepository) CreateTx(tx *sql.Tx, nodeAttribute *models.NodeAttribute) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_attributes (node_id, attribute_id, value, order_index, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRowInTransaction(tx, query, nodeAttribute.NodeID, nodeAttribute.AttributeID,
                nodeAttribute.Value, nodeAttribute.OrderIndex).Scan(
                &amp;nodeAttribute.ID, &amp;nodeAttribute.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 노드 속성을 업데이트합니다.
func (r *sqliteNodeAttributeRepository) UpdateTx(tx *sql.Tx, nodeAttribute *models.NodeAttribute) error <span class="cov0" title="0">{
        query := `
                UPDATE node_attributes
                SET value = ?, order_index = ?
                WHERE id = ?
        `

        result, err := r.ExecuteInTransaction(tx, query, nodeAttribute.Value, nodeAttribute.OrderIndex, nodeAttribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE id = ?`

        result, err := r.ExecuteInTransaction(tx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "url-db/internal/models"
)

// sqliteNodeConnectionRepository 는 SQLite 기반 노드 연결 리포지토리 구현체입니다.
type sqliteNodeConnectionRepository struct {
        *BaseRepository
}

// NewSQLiteNodeConnectionRepository 는 새로운 SQLite 노드 연결 리포지토리를 생성합니다.
func NewSQLiteNodeConnectionRepository(db *sql.DB) NodeConnectionRepository <span class="cov0" title="0">{
        return &amp;sqliteNodeConnectionRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 노드 연결을 생성합니다.
func (r *sqliteNodeConnectionRepository) Create(ctx context.Context, connection *models.NodeConnection) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_connections (source_node_id, target_node_id, relationship_type, description, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRow(query, connection.SourceNodeID, connection.TargetNodeID, connection.RelationshipType, connection.Description).Scan(
                &amp;connection.ID, &amp;connection.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID 는 ID로 노드 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) GetByID(ctx context.Context, id int) (*models.NodeConnection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, source_node_id, target_node_id, relationship_type, description, created_at
                FROM node_connections
                WHERE id = ?
        `

        connection := &amp;models.NodeConnection{}
        err := r.QueryRow(query, id).Scan(
                &amp;connection.ID, &amp;connection.SourceNodeID, &amp;connection.TargetNodeID,
                &amp;connection.RelationshipType, &amp;connection.Description, &amp;connection.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNodeConnectionNotFound
                }</span>
                <span class="cov0" title="0">return nil, MapSQLiteError(err)</span>
        }

        <span class="cov0" title="0">return connection, nil</span>
}

// GetBySourceAndTarget 는 소스 노드와 타겟 노드 및 관계 유형으로 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) GetBySourceAndTarget(ctx context.Context, sourceNodeID, targetNodeID int, relationshipType string) (*models.NodeConnection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, source_node_id, target_node_id, relationship_type, description, created_at
                FROM node_connections
                WHERE source_node_id = ? AND target_node_id = ? AND relationship_type = ?
        `

        connection := &amp;models.NodeConnection{}
        err := r.QueryRow(query, sourceNodeID, targetNodeID, relationshipType).Scan(
                &amp;connection.ID, &amp;connection.SourceNodeID, &amp;connection.TargetNodeID,
                &amp;connection.RelationshipType, &amp;connection.Description, &amp;connection.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNodeConnectionNotFound
                }</span>
                <span class="cov0" title="0">return nil, MapSQLiteError(err)</span>
        }

        <span class="cov0" title="0">return connection, nil</span>
}

// ListBySourceNode 는 소스 노드별로 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) ListBySourceNode(ctx context.Context, sourceNodeID int, offset, limit int) ([]models.NodeConnectionWithInfo, int, error) <span class="cov0" title="0">{
        query := `
                SELECT nc.id, nc.source_node_id, nc.target_node_id, nc.relationship_type, nc.description, nc.created_at,
                           sn.content as source_node_url, tn.content as target_node_url,
                           sn.title as source_node_title, tn.title as target_node_title
                FROM node_connections nc
                JOIN nodes sn ON nc.source_node_id = sn.id
                JOIN nodes tn ON nc.target_node_id = tn.id
                WHERE nc.source_node_id = ?
                ORDER BY nc.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, sourceNodeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var connections []models.NodeConnectionWithInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var conn models.NodeConnectionWithInfo
                err := rows.Scan(
                        &amp;conn.ID, &amp;conn.SourceNodeID, &amp;conn.TargetNodeID, &amp;conn.RelationshipType,
                        &amp;conn.Description, &amp;conn.CreatedAt, &amp;conn.SourceNodeURL, &amp;conn.TargetNodeURL,
                        &amp;conn.SourceNodeTitle, &amp;conn.TargetNodeTitle,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">connections = append(connections, conn)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov0" title="0">countQuery := `SELECT COUNT(*) FROM node_connections WHERE source_node_id = ?`
        var totalCount int
        err = r.QueryRow(countQuery, sourceNodeID).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return connections, totalCount, nil</span>
}

// ListByTargetNode 는 타겟 노드별로 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) ListByTargetNode(ctx context.Context, targetNodeID int, offset, limit int) ([]models.NodeConnectionWithInfo, int, error) <span class="cov0" title="0">{
        query := `
                SELECT nc.id, nc.source_node_id, nc.target_node_id, nc.relationship_type, nc.description, nc.created_at,
                           sn.content as source_node_url, tn.content as target_node_url,
                           sn.title as source_node_title, tn.title as target_node_title
                FROM node_connections nc
                JOIN nodes sn ON nc.source_node_id = sn.id
                JOIN nodes tn ON nc.target_node_id = tn.id
                WHERE nc.target_node_id = ?
                ORDER BY nc.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, targetNodeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var connections []models.NodeConnectionWithInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var conn models.NodeConnectionWithInfo
                err := rows.Scan(
                        &amp;conn.ID, &amp;conn.SourceNodeID, &amp;conn.TargetNodeID, &amp;conn.RelationshipType,
                        &amp;conn.Description, &amp;conn.CreatedAt, &amp;conn.SourceNodeURL, &amp;conn.TargetNodeURL,
                        &amp;conn.SourceNodeTitle, &amp;conn.TargetNodeTitle,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">connections = append(connections, conn)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov0" title="0">countQuery := `SELECT COUNT(*) FROM node_connections WHERE target_node_id = ?`
        var totalCount int
        err = r.QueryRow(countQuery, targetNodeID).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return connections, totalCount, nil</span>
}

// ListByRelationshipType 는 관계 유형별로 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) ListByRelationshipType(ctx context.Context, relationshipType string, offset, limit int) ([]models.NodeConnectionWithInfo, int, error) <span class="cov0" title="0">{
        query := `
                SELECT nc.id, nc.source_node_id, nc.target_node_id, nc.relationship_type, nc.description, nc.created_at,
                           sn.content as source_node_url, tn.content as target_node_url,
                           sn.title as source_node_title, tn.title as target_node_title
                FROM node_connections nc
                JOIN nodes sn ON nc.source_node_id = sn.id
                JOIN nodes tn ON nc.target_node_id = tn.id
                WHERE nc.relationship_type = ?
                ORDER BY nc.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, relationshipType, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var connections []models.NodeConnectionWithInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var conn models.NodeConnectionWithInfo
                err := rows.Scan(
                        &amp;conn.ID, &amp;conn.SourceNodeID, &amp;conn.TargetNodeID, &amp;conn.RelationshipType,
                        &amp;conn.Description, &amp;conn.CreatedAt, &amp;conn.SourceNodeURL, &amp;conn.TargetNodeURL,
                        &amp;conn.SourceNodeTitle, &amp;conn.TargetNodeTitle,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">connections = append(connections, conn)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov0" title="0">countQuery := `SELECT COUNT(*) FROM node_connections WHERE relationship_type = ?`
        var totalCount int
        err = r.QueryRow(countQuery, relationshipType).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return connections, totalCount, nil</span>
}

// Update 는 노드 연결을 업데이트합니다.
func (r *sqliteNodeConnectionRepository) Update(ctx context.Context, connection *models.NodeConnection) error <span class="cov0" title="0">{
        query := `
                UPDATE node_connections
                SET relationship_type = ?, description = ?
                WHERE id = ?
        `

        result, err := r.Execute(query, connection.RelationshipType, connection.Description, connection.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeConnectionNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete 는 노드 연결을 삭제합니다.
func (r *sqliteNodeConnectionRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_connections WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeConnectionNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteBySourceNode 는 소스 노드로 연결을 삭제합니다.
func (r *sqliteNodeConnectionRepository) DeleteBySourceNode(ctx context.Context, sourceNodeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_connections WHERE source_node_id = ?`

        _, err := r.Execute(query, sourceNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteByTargetNode 는 타겟 노드로 연결을 삭제합니다.
func (r *sqliteNodeConnectionRepository) DeleteByTargetNode(ctx context.Context, targetNodeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_connections WHERE target_node_id = ?`

        _, err := r.Execute(query, targetNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExistsBySourceAndTarget 는 소스 노드와 타겟 노드 및 관계 유형으로 연결 존재 여부를 확인합니다.
func (r *sqliteNodeConnectionRepository) ExistsBySourceAndTarget(ctx context.Context, sourceNodeID, targetNodeID int, relationshipType string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM node_connections WHERE source_node_id = ? AND target_node_id = ? AND relationship_type = ?)`

        var exists bool
        err := r.QueryRow(query, sourceNodeID, targetNodeID, relationshipType).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// BatchCreate 는 여러 노드 연결을 배치로 생성합니다.
func (r *sqliteNodeConnectionRepository) BatchCreate(ctx context.Context, connections []models.NodeConnection) error <span class="cov0" title="0">{
        if len(connections) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        INSERT INTO node_connections (source_node_id, target_node_id, relationship_type, description, created_at)
                        VALUES (?, ?, ?, ?, datetime('now'))
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, connection := range connections </span><span class="cov0" title="0">{
                        _, err = stmt.Exec(connection.SourceNodeID, connection.TargetNodeID, connection.RelationshipType, connection.Description)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// BatchDelete 는 여러 노드 연결을 배치로 삭제합니다.
func (r *sqliteNodeConnectionRepository) BatchDelete(ctx context.Context, ids []int) error <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `DELETE FROM node_connections WHERE id = ?`)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, id := range ids </span><span class="cov0" title="0">{
                        _, err = stmt.Exec(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// CreateTx 는 트랜잭션 내에서 노드 연결을 생성합니다.
func (r *sqliteNodeConnectionRepository) CreateTx(tx *sql.Tx, connection *models.NodeConnection) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_connections (source_node_id, target_node_id, relationship_type, description, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := tx.QueryRow(query, connection.SourceNodeID, connection.TargetNodeID, connection.RelationshipType, connection.Description).Scan(
                &amp;connection.ID, &amp;connection.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 노드 연결을 업데이트합니다.
func (r *sqliteNodeConnectionRepository) UpdateTx(tx *sql.Tx, connection *models.NodeConnection) error <span class="cov0" title="0">{
        query := `
                UPDATE node_connections
                SET relationship_type = ?, description = ?
                WHERE id = ?
        `

        result, err := tx.Exec(query, connection.RelationshipType, connection.Description, connection.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeConnectionNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 노드 연결을 삭제합니다.
func (r *sqliteNodeConnectionRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_connections WHERE id = ?`

        result, err := tx.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeConnectionNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package repositories

import (
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"
        "url-db/internal/models"
)

// SubscriptionRepository handles database operations for subscriptions
type SubscriptionRepository struct {
        db *sqlx.DB
}

// NewSubscriptionRepository creates a new subscription repository
func NewSubscriptionRepository(db *sqlx.DB) *SubscriptionRepository <span class="cov0" title="0">{
        return &amp;SubscriptionRepository{db: db}
}</span>

// Create creates a new subscription
func (r *SubscriptionRepository) Create(subscription *models.NodeSubscription) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_subscriptions (
                        subscriber_service, subscriber_endpoint, subscribed_node_id,
                        event_types, filter_conditions, is_active
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(
                query,
                subscription.SubscriberService,
                subscription.SubscriberEndpoint,
                subscription.SubscribedNodeID,
                subscription.EventTypes,
                subscription.FilterConditions,
                subscription.IsActive,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create subscription: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov0" title="0">subscription.ID = id
        return nil</span>
}

// GetByID retrieves a subscription by ID
func (r *SubscriptionRepository) GetByID(id int64) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        var subscription models.NodeSubscription
        query := `
                SELECT id, subscriber_service, subscriber_endpoint, subscribed_node_id,
                           event_types, filter_conditions, is_active, created_at, updated_at
                FROM node_subscriptions
                WHERE id = ?
        `

        err := r.db.Get(&amp;subscription, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get subscription: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;subscription, nil</span>
}

// GetByNode retrieves all subscriptions for a specific node
func (r *SubscriptionRepository) GetByNode(nodeID int64) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        var subscriptions []*models.NodeSubscription
        query := `
                SELECT id, subscriber_service, subscriber_endpoint, subscribed_node_id,
                           event_types, filter_conditions, is_active, created_at, updated_at
                FROM node_subscriptions
                WHERE subscribed_node_id = ? AND is_active = true
        `

        err := r.db.Select(&amp;subscriptions, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subscriptions: %w", err)
        }</span>

        <span class="cov0" title="0">return subscriptions, nil</span>
}

// GetByService retrieves all subscriptions for a specific service
func (r *SubscriptionRepository) GetByService(service string) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        var subscriptions []*models.NodeSubscription
        query := `
                SELECT id, subscriber_service, subscriber_endpoint, subscribed_node_id,
                           event_types, filter_conditions, is_active, created_at, updated_at
                FROM node_subscriptions
                WHERE subscriber_service = ?
                ORDER BY created_at DESC
        `

        err := r.db.Select(&amp;subscriptions, query, service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subscriptions: %w", err)
        }</span>

        <span class="cov0" title="0">return subscriptions, nil</span>
}

// Update updates a subscription
func (r *SubscriptionRepository) Update(id int64, updates map[string]interface{}) error <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := "UPDATE node_subscriptions SET "
        args := []interface{}{}

        for field, value := range updates </span><span class="cov0" title="0">{
                query += field + " = ?, "
                args = append(args, value)
        }</span>

        <span class="cov0" title="0">query = query[:len(query)-2] + " WHERE id = ?"
        args = append(args, id)

        _, err := r.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete deletes a subscription
func (r *SubscriptionRepository) Delete(id int64) error <span class="cov0" title="0">{
        query := "DELETE FROM node_subscriptions WHERE id = ?"

        result, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete subscription: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAll retrieves all subscriptions with pagination
func (r *SubscriptionRepository) GetAll(offset, limit int) ([]*models.NodeSubscription, int, error) <span class="cov0" title="0">{
        var subscriptions []*models.NodeSubscription
        var total int

        countQuery := "SELECT COUNT(*) FROM node_subscriptions"
        err := r.db.Get(&amp;total, countQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count subscriptions: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, subscriber_service, subscriber_endpoint, subscribed_node_id,
                           event_types, filter_conditions, is_active, created_at, updated_at
                FROM node_subscriptions
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        err = r.db.Select(&amp;subscriptions, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get subscriptions: %w", err)
        }</span>

        <span class="cov0" title="0">return subscriptions, total, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package repositories

import (
        "database/sql"
        "testing"
        "time"
        "url-db/internal/models"

        _ "github.com/mattn/go-sqlite3"
        "github.com/stretchr/testify/require"
)

// TestDB 는 테스트용 데이터베이스 설정을 위한 구조체입니다.
type TestDB struct {
        DB *sql.DB
}

// SetupTestDB 는 테스트용 인메모리 SQLite 데이터베이스를 설정합니다.
func SetupTestDB(t *testing.T) *TestDB <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", ":memory:")
        require.NoError(t, err)

        // 테스트용 스키마 생성
        createTestSchema(t, db)

        return &amp;TestDB{DB: db}
}</span>

// Close 는 테스트 데이터베이스를 닫습니다.
func (tdb *TestDB) Close() <span class="cov8" title="1">{
        tdb.DB.Close()
}</span>

// createTestSchema 는 테스트용 스키마를 생성합니다.
func createTestSchema(t *testing.T, db *sql.DB) <span class="cov8" title="1">{
        schema := `
                CREATE TABLE domains (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL UNIQUE,
                        description TEXT,
                        created_at DATETIME NOT NULL,
                        updated_at DATETIME NOT NULL
                );

                CREATE TABLE nodes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        content TEXT NOT NULL,
                        domain_id INTEGER NOT NULL,
                        title TEXT,
                        description TEXT,
                        created_at DATETIME NOT NULL,
                        updated_at DATETIME NOT NULL,
                        FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE,
                        UNIQUE(content, domain_id)
                );

                CREATE TABLE attributes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        domain_id INTEGER NOT NULL,
                        name TEXT NOT NULL,
                        type TEXT NOT NULL CHECK (type IN ('tag', 'ordered_tag', 'number', 'string', 'markdown', 'image')),
                        description TEXT,
                        created_at DATETIME NOT NULL,
                        FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE,
                        UNIQUE(domain_id, name)
                );

                CREATE TABLE node_attributes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        node_id INTEGER NOT NULL,
                        attribute_id INTEGER NOT NULL,
                        value TEXT NOT NULL,
                        order_index INTEGER DEFAULT 0,
                        created_at DATETIME NOT NULL,
                        FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                        FOREIGN KEY (attribute_id) REFERENCES attributes(id) ON DELETE CASCADE,
                        UNIQUE(node_id, attribute_id, order_index)
                );

                -- 인덱스 생성
                CREATE INDEX idx_nodes_domain_id ON nodes(domain_id);
                CREATE INDEX idx_nodes_content ON nodes(content);
                CREATE INDEX idx_attributes_domain_id ON attributes(domain_id);
                CREATE INDEX idx_node_attributes_node_id ON node_attributes(node_id);
                CREATE INDEX idx_node_attributes_attribute_id ON node_attributes(attribute_id);
        `

        _, err := db.Exec(schema)
        require.NoError(t, err)
}</span>

// TestDomainBuilder 는 테스트용 도메인 빌더입니다.
type TestDomainBuilder struct {
        domain *models.Domain
}

// NewTestDomainBuilder 는 새로운 테스트 도메인 빌더를 생성합니다.
func NewTestDomainBuilder() *TestDomainBuilder <span class="cov8" title="1">{
        return &amp;TestDomainBuilder{
                domain: &amp;models.Domain{
                        Name:        "test-domain",
                        Description: "Test domain",
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
        }
}</span>

// WithName 은 도메인 이름을 설정합니다.
func (b *TestDomainBuilder) WithName(name string) *TestDomainBuilder <span class="cov8" title="1">{
        b.domain.Name = name
        return b
}</span>

// WithDescription 은 도메인 설명을 설정합니다.
func (b *TestDomainBuilder) WithDescription(description string) *TestDomainBuilder <span class="cov0" title="0">{
        b.domain.Description = description
        return b
}</span>

// WithID 는 도메인 ID를 설정합니다.
func (b *TestDomainBuilder) WithID(id int) *TestDomainBuilder <span class="cov0" title="0">{
        b.domain.ID = id
        return b
}</span>

// Build 는 도메인을 빌드합니다.
func (b *TestDomainBuilder) Build() *models.Domain <span class="cov8" title="1">{
        return b.domain
}</span>

// TestNodeBuilder 는 테스트용 노드 빌더입니다.
type TestNodeBuilder struct {
        node *models.Node
}

// NewTestNodeBuilder 는 새로운 테스트 노드 빌더를 생성합니다.
func NewTestNodeBuilder() *TestNodeBuilder <span class="cov8" title="1">{
        return &amp;TestNodeBuilder{
                node: &amp;models.Node{
                        Content:     "https://example.com",
                        DomainID:    1,
                        Title:       "Test Node",
                        Description: "Test node description",
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
        }
}</span>

// WithContent 는 노드 콘텐츠를 설정합니다.
func (b *TestNodeBuilder) WithContent(content string) *TestNodeBuilder <span class="cov8" title="1">{
        b.node.Content = content
        return b
}</span>

// WithDomainID 는 도메인 ID를 설정합니다.
func (b *TestNodeBuilder) WithDomainID(domainID int) *TestNodeBuilder <span class="cov8" title="1">{
        b.node.DomainID = domainID
        return b
}</span>

// WithTitle 은 노드 제목을 설정합니다.
func (b *TestNodeBuilder) WithTitle(title string) *TestNodeBuilder <span class="cov8" title="1">{
        b.node.Title = title
        return b
}</span>

// WithDescription 은 노드 설명을 설정합니다.
func (b *TestNodeBuilder) WithDescription(description string) *TestNodeBuilder <span class="cov8" title="1">{
        b.node.Description = description
        return b
}</span>

// WithID 는 노드 ID를 설정합니다.
func (b *TestNodeBuilder) WithID(id int) *TestNodeBuilder <span class="cov0" title="0">{
        b.node.ID = id
        return b
}</span>

// Build 는 노드를 빌드합니다.
func (b *TestNodeBuilder) Build() *models.Node <span class="cov8" title="1">{
        return b.node
}</span>

// TestAttributeBuilder 는 테스트용 속성 빌더입니다.
type TestAttributeBuilder struct {
        attribute *models.Attribute
}

// NewTestAttributeBuilder 는 새로운 테스트 속성 빌더를 생성합니다.
func NewTestAttributeBuilder() *TestAttributeBuilder <span class="cov0" title="0">{
        return &amp;TestAttributeBuilder{
                attribute: &amp;models.Attribute{
                        DomainID:    1,
                        Name:        "test-attribute",
                        Type:        "tag",
                        Description: "Test attribute",
                        CreatedAt:   time.Now(),
                },
        }
}</span>

// WithDomainID 는 도메인 ID를 설정합니다.
func (b *TestAttributeBuilder) WithDomainID(domainID int) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.DomainID = domainID
        return b
}</span>

// WithName 은 속성 이름을 설정합니다.
func (b *TestAttributeBuilder) WithName(name string) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.Name = name
        return b
}</span>

// WithType 은 속성 타입을 설정합니다.
func (b *TestAttributeBuilder) WithType(attrType string) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.Type = models.AttributeType(attrType)
        return b
}</span>

// WithDescription 은 속성 설명을 설정합니다.
func (b *TestAttributeBuilder) WithDescription(description string) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.Description = description
        return b
}</span>

// WithID 는 속성 ID를 설정합니다.
func (b *TestAttributeBuilder) WithID(id int) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.ID = id
        return b
}</span>

// Build 는 속성을 빌드합니다.
func (b *TestAttributeBuilder) Build() *models.Attribute <span class="cov0" title="0">{
        return b.attribute
}</span>

// TestNodeAttributeBuilder 는 테스트용 노드 속성 빌더입니다.
type TestNodeAttributeBuilder struct {
        nodeAttribute *models.NodeAttribute
}

// NewTestNodeAttributeBuilder 는 새로운 테스트 노드 속성 빌더를 생성합니다.
func NewTestNodeAttributeBuilder() *TestNodeAttributeBuilder <span class="cov0" title="0">{
        return &amp;TestNodeAttributeBuilder{
                nodeAttribute: &amp;models.NodeAttribute{
                        NodeID:      1,
                        AttributeID: 1,
                        Value:       "test-value",
                        OrderIndex:  nil,
                        CreatedAt:   time.Now(),
                },
        }
}</span>

// WithNodeID 는 노드 ID를 설정합니다.
func (b *TestNodeAttributeBuilder) WithNodeID(nodeID int) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.NodeID = nodeID
        return b
}</span>

// WithAttributeID 는 속성 ID를 설정합니다.
func (b *TestNodeAttributeBuilder) WithAttributeID(attributeID int) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.AttributeID = attributeID
        return b
}</span>

// WithValue 는 속성 값을 설정합니다.
func (b *TestNodeAttributeBuilder) WithValue(value string) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.Value = value
        return b
}</span>

// WithOrderIndex 는 순서 인덱스를 설정합니다.
func (b *TestNodeAttributeBuilder) WithOrderIndex(orderIndex int) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.OrderIndex = &amp;orderIndex
        return b
}</span>

// WithID 는 노드 속성 ID를 설정합니다.
func (b *TestNodeAttributeBuilder) WithID(id int) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.ID = id
        return b
}</span>

// Build 는 노드 속성을 빌드합니다.
func (b *TestNodeAttributeBuilder) Build() *models.NodeAttribute <span class="cov0" title="0">{
        return b.nodeAttribute
}</span>

// CreateTestDomain 은 테스트용 도메인을 생성합니다.
func CreateTestDomain(t *testing.T, repo DomainRepository) *models.Domain <span class="cov8" title="1">{
        domain := NewTestDomainBuilder().Build()
        err := repo.Create(domain)
        require.NoError(t, err)
        return domain
}</span>

// CreateTestNode 는 테스트용 노드를 생성합니다.
func CreateTestNode(t *testing.T, repo NodeRepository, domainID int) *models.Node <span class="cov8" title="1">{
        node := NewTestNodeBuilder().WithDomainID(domainID).Build()
        err := repo.Create(node)
        require.NoError(t, err)
        return node
}</span>

// CreateTestAttribute 는 테스트용 속성을 생성합니다.
func CreateTestAttribute(t *testing.T, repo AttributeRepository, domainID int) *models.Attribute <span class="cov0" title="0">{
        attribute := NewTestAttributeBuilder().WithDomainID(domainID).Build()
        err := repo.Create(attribute)
        require.NoError(t, err)
        return attribute
}</span>

// CreateTestNodeAttribute 는 테스트용 노드 속성을 생성합니다.
func CreateTestNodeAttribute(t *testing.T, repo NodeAttributeRepository, nodeID, attributeID int) *models.NodeAttribute <span class="cov0" title="0">{
        nodeAttribute := NewTestNodeAttributeBuilder().WithNodeID(nodeID).WithAttributeID(attributeID).Build()
        err := repo.Create(nodeAttribute)
        require.NoError(t, err)
        return nodeAttribute
}</span>

// AssertDomainEqual 은 두 도메인이 같은지 확인합니다.
func AssertDomainEqual(t *testing.T, expected, actual *models.Domain) <span class="cov8" title="1">{
        require.Equal(t, expected.Name, actual.Name)
        require.Equal(t, expected.Description, actual.Description)
        if expected.ID != 0 </span><span class="cov8" title="1">{
                require.Equal(t, expected.ID, actual.ID)
        }</span>
}

// AssertNodeEqual 은 두 노드가 같은지 확인합니다.
func AssertNodeEqual(t *testing.T, expected, actual *models.Node) <span class="cov8" title="1">{
        require.Equal(t, expected.Content, actual.Content)
        require.Equal(t, expected.DomainID, actual.DomainID)
        require.Equal(t, expected.Title, actual.Title)
        require.Equal(t, expected.Description, actual.Description)
        if expected.ID != 0 </span><span class="cov8" title="1">{
                require.Equal(t, expected.ID, actual.ID)
        }</span>
}

// AssertAttributeEqual 은 두 속성이 같은지 확인합니다.
func AssertAttributeEqual(t *testing.T, expected, actual *models.Attribute) <span class="cov0" title="0">{
        require.Equal(t, expected.DomainID, actual.DomainID)
        require.Equal(t, expected.Name, actual.Name)
        require.Equal(t, expected.Type, actual.Type)
        require.Equal(t, expected.Description, actual.Description)
        if expected.ID != 0 </span><span class="cov0" title="0">{
                require.Equal(t, expected.ID, actual.ID)
        }</span>
}

// AssertNodeAttributeEqual 은 두 노드 속성이 같은지 확인합니다.
func AssertNodeAttributeEqual(t *testing.T, expected, actual *models.NodeAttribute) <span class="cov0" title="0">{
        require.Equal(t, expected.NodeID, actual.NodeID)
        require.Equal(t, expected.AttributeID, actual.AttributeID)
        require.Equal(t, expected.Value, actual.Value)
        require.Equal(t, expected.OrderIndex, actual.OrderIndex)
        if expected.ID != 0 </span><span class="cov0" title="0">{
                require.Equal(t, expected.ID, actual.ID)
        }</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type AttributeService interface {
        CreateAttribute(domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error)
        GetAttributesByDomainID(domainID int) ([]models.Attribute, error)
        GetAttributeByID(id int) (*models.Attribute, error)
        UpdateAttribute(id int, req *models.UpdateAttributeRequest) (*models.Attribute, error)
        DeleteAttribute(id int) error
}

type AttributeHandler struct {
        *BaseHandler
        attributeService AttributeService
}

func NewAttributeHandler(attributeService AttributeService) *AttributeHandler <span class="cov0" title="0">{
        return &amp;AttributeHandler{
                BaseHandler:      NewBaseHandler(),
                attributeService: attributeService,
        }
}</span>

func (h *AttributeHandler) CreateAttribute(c *gin.Context) <span class="cov0" title="0">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.attributeService.CreateAttribute(domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, attribute)</span>
}

func (h *AttributeHandler) GetAttributesByDomain(c *gin.Context) <span class="cov0" title="0">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attributes, err := h.attributeService.GetAttributesByDomainID(domainID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "attributes": attributes,
        })</span>
}

func (h *AttributeHandler) GetAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.attributeService.GetAttributeByID(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

func (h *AttributeHandler) UpdateAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.attributeService.UpdateAttribute(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

func (h *AttributeHandler) DeleteAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">err = h.attributeService.DeleteAttribute(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *AttributeHandler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                // Individual attribute operations
                attributes := api.Group("/attributes")
                </span><span class="cov0" title="0">{
                        attributes.GET("/:id", h.GetAttribute)
                        attributes.PUT("/:id", h.UpdateAttribute)
                        attributes.DELETE("/:id", h.DeleteAttribute)
                }</span>

                // Domain-specific attribute operations
                <span class="cov0" title="0">domains := api.Group("/domains")
                </span><span class="cov0" title="0">{
                        domainAttributes := domains.Group("/:domain_id/attributes")
                        </span><span class="cov0" title="0">{
                                domainAttributes.POST("", h.CreateAttribute)
                                domainAttributes.GET("", h.GetAttributesByDomain)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package handlers

import (
        "strconv"

        "github.com/gin-gonic/gin"
)

type BaseHandler struct{}

func NewBaseHandler() *BaseHandler <span class="cov0" title="0">{
        return &amp;BaseHandler{}
}</span>

func (h *BaseHandler) HandleError(c *gin.Context, err error) <span class="cov0" title="0">{
        HandleError(c, err)
}</span>

func (h *BaseHandler) ParseIntParam(c *gin.Context, param string) (int, error) <span class="cov0" title="0">{
        str := c.Param(param)
        if str == "" </span><span class="cov0" title="0">{
                return 0, NewValidationError("Missing parameter: "+param, nil)
        }</span>

        <span class="cov0" title="0">value, err := strconv.Atoi(str)
        if err != nil </span><span class="cov0" title="0">{
                return 0, NewValidationError("Invalid parameter: "+param, nil)
        }</span>

        <span class="cov0" title="0">return value, nil</span>
}

func (h *BaseHandler) ParseIntQuery(c *gin.Context, query string, defaultValue int) int <span class="cov0" title="0">{
        str := c.Query(query)
        if str == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">value, err := strconv.Atoi(str)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">return value</span>
}

func (h *BaseHandler) GetStringQuery(c *gin.Context, query string) string <span class="cov0" title="0">{
        return c.Query(query)
}</span>

func (h *BaseHandler) BindJSON(c *gin.Context, obj interface{}) error <span class="cov0" title="0">{
        if err := c.ShouldBindJSON(obj); err != nil </span><span class="cov0" title="0">{
                return NewValidationError("Invalid JSON format", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
        "url-db/internal/services"
)

// DependencyHandler handles HTTP requests for dependencies
type DependencyHandler struct {
        dependencyService *services.DependencyService
}

// NewDependencyHandler creates a new dependency handler
func NewDependencyHandler(dependencyService *services.DependencyService) *DependencyHandler <span class="cov0" title="0">{
        return &amp;DependencyHandler{
                dependencyService: dependencyService,
        }
}</span>

// CreateDependency creates a new dependency
// @Summary Create dependency
// @Description Create a new dependency relationship between nodes
// @Tags dependencies
// @Accept json
// @Produce json
// @Param nodeId path int true "Dependent Node ID"
// @Param request body models.CreateNodeDependencyRequest true "Dependency details"
// @Success 201 {object} models.NodeDependency
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse "Circular dependency detected"
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/dependencies [post]
func (h *DependencyHandler) CreateDependency(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateNodeDependencyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid request body",
                })
                return
        }</span>

        <span class="cov0" title="0">dependency, err := h.dependencyService.CreateDependency(nodeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "dependent node not found" || err.Error() == "dependency node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "circular dependency detected" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, ErrorResponse{
                                Error:   "conflict",
                                Message: "Circular dependency detected",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to create dependency",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, dependency)</span>
}

// GetDependency retrieves a dependency
// @Summary Get dependency
// @Description Get a dependency by ID
// @Tags dependencies
// @Produce json
// @Param id path int true "Dependency ID"
// @Success 200 {object} models.NodeDependency
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/dependencies/{id} [get]
func (h *DependencyHandler) GetDependency(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid dependency ID",
                })
                return
        }</span>

        <span class="cov0" title="0">dependency, err := h.dependencyService.GetDependency(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "dependency not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Dependency not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get dependency",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, dependency)</span>
}

// DeleteDependency deletes a dependency
// @Summary Delete dependency
// @Description Delete a dependency relationship
// @Tags dependencies
// @Param id path int true "Dependency ID"
// @Success 204
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/dependencies/{id} [delete]
func (h *DependencyHandler) DeleteDependency(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid dependency ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.dependencyService.DeleteDependency(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "dependency not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Dependency not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to delete dependency",
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetNodeDependencies retrieves all dependencies for a node
// @Summary Get node dependencies
// @Description Get all dependencies where the node is dependent
// @Tags dependencies
// @Produce json
// @Param nodeId path int true "Node ID"
// @Success 200 {array} models.NodeDependency
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/dependencies [get]
func (h *DependencyHandler) GetNodeDependencies(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">dependencies, err := h.dependencyService.GetNodeDependencies(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get dependencies",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, dependencies)</span>
}

// GetNodeDependents retrieves all nodes that depend on this node
// @Summary Get node dependents
// @Description Get all nodes that depend on this node
// @Tags dependencies
// @Produce json
// @Param nodeId path int true "Node ID"
// @Success 200 {array} models.NodeDependency
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/dependents [get]
func (h *DependencyHandler) GetNodeDependents(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">dependents, err := h.dependencyService.GetNodeDependents(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get dependents",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, dependents)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type DomainService interface {
        CreateDomain(req *models.CreateDomainRequest) (*models.Domain, error)
        GetDomains(page, size int) (*models.DomainListResponse, error)
        GetDomainByID(id int) (*models.Domain, error)
        UpdateDomain(id int, req *models.UpdateDomainRequest) (*models.Domain, error)
        DeleteDomain(id int) error
}

type DomainHandler struct {
        *BaseHandler
        domainService DomainService
}

func NewDomainHandler(domainService DomainService) *DomainHandler <span class="cov0" title="0">{
        return &amp;DomainHandler{
                BaseHandler:   NewBaseHandler(),
                domainService: domainService,
        }
}</span>

func (h *DomainHandler) CreateDomain(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateDomainRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.domainService.CreateDomain(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, domain)</span>
}

func (h *DomainHandler) GetDomains(c *gin.Context) <span class="cov0" title="0">{
        page := h.ParseIntQuery(c, "page", 1)
        size := h.ParseIntQuery(c, "size", 20)

        if size &gt; 100 </span><span class="cov0" title="0">{
                size = 100
        }</span>

        <span class="cov0" title="0">response, err := h.domainService.GetDomains(page, size)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *DomainHandler) GetDomain(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.domainService.GetDomainByID(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, domain)</span>
}

func (h *DomainHandler) UpdateDomain(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateDomainRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.domainService.UpdateDomain(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, domain)</span>
}

func (h *DomainHandler) DeleteDomain(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">err = h.domainService.DeleteDomain(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *DomainHandler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                domains := api.Group("/domains")
                </span><span class="cov0" title="0">{
                        domains.POST("", h.CreateDomain)
                        domains.GET("", h.GetDomains)
                        domains.GET("/:id", h.GetDomain)
                        domains.PUT("/:id", h.UpdateDomain)
                        domains.DELETE("/:id", h.DeleteDomain)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type ErrorResponse struct {
        Error   string      `json:"error"`
        Message string      `json:"message"`
        Details interface{} `json:"details,omitempty"`
}

type ValidationError struct {
        Message string
        Details interface{}
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

type NotFoundError struct {
        Message string
}

func (e *NotFoundError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

type ConflictError struct {
        Message string
}

func (e *ConflictError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

type InternalError struct {
        Message string
}

func (e *InternalError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

func HandleError(c *gin.Context, err error) <span class="cov8" title="1">{
        switch e := err.(type) </span>{
        case *ValidationError:<span class="cov8" title="1">
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: e.Message,
                        Details: e.Details,
                })</span>
        case *NotFoundError:<span class="cov8" title="1">
                c.JSON(http.StatusNotFound, ErrorResponse{
                        Error:   "not_found",
                        Message: e.Message,
                })</span>
        case *ConflictError:<span class="cov8" title="1">
                c.JSON(http.StatusConflict, ErrorResponse{
                        Error:   "conflict",
                        Message: e.Message,
                })</span>
        case *InternalError:<span class="cov8" title="1">
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: e.Message,
                })</span>
        default:<span class="cov8" title="1">
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "An unexpected error occurred",
                })</span>
        }
}

func NewValidationError(message string, details interface{}) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Message: message,
                Details: details,
        }
}</span>

func NewNotFoundError(message string) *NotFoundError <span class="cov8" title="1">{
        return &amp;NotFoundError{
                Message: message,
        }
}</span>

func NewConflictError(message string) *ConflictError <span class="cov8" title="1">{
        return &amp;ConflictError{
                Message: message,
        }
}</span>

func NewInternalError(message string) *InternalError <span class="cov8" title="1">{
        return &amp;InternalError{
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package handlers

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "url-db/internal/services"
)

// EventHandler handles HTTP requests for events
type EventHandler struct {
        eventService *services.EventService
}

// NewEventHandler creates a new event handler
func NewEventHandler(eventService *services.EventService) *EventHandler <span class="cov0" title="0">{
        return &amp;EventHandler{
                eventService: eventService,
        }
}</span>

// GetNodeEvents retrieves events for a node
// @Summary Get node events
// @Description Get events for a specific node
// @Tags events
// @Produce json
// @Param nodeId path int true "Node ID"
// @Param limit query int false "Maximum number of events to return" default(50)
// @Success 200 {array} models.NodeEvent
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/events [get]
func (h *EventHandler) GetNodeEvents(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        events, err := h.eventService.GetNodeEvents(nodeID, limit)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get events",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, events)</span>
}

// GetPendingEvents retrieves unprocessed events
// @Summary Get pending events
// @Description Get unprocessed events for processing
// @Tags events
// @Produce json
// @Param limit query int false "Maximum number of events to return" default(100)
// @Success 200 {array} models.NodeEvent
// @Failure 500 {object} ErrorResponse
// @Router /api/events/pending [get]
func (h *EventHandler) GetPendingEvents(c *gin.Context) <span class="cov0" title="0">{
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))

        events, err := h.eventService.GetPendingEvents(limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get pending events",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, events)</span>
}

// ProcessEvent marks an event as processed
// @Summary Process event
// @Description Mark an event as processed
// @Tags events
// @Param eventId path int true "Event ID"
// @Success 204
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/events/{eventId}/process [post]
func (h *EventHandler) ProcessEvent(c *gin.Context) <span class="cov0" title="0">{
        eventID, err := strconv.ParseInt(c.Param("eventId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid event ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.eventService.ProcessEvent(eventID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "event not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Event not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "event already processed" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, ErrorResponse{
                                Error:   "validation_error",
                                Message: "Event already processed",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to process event",
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetEventsByType retrieves events by type and date range
// @Summary Get events by type
// @Description Get events by type within a date range
// @Tags events
// @Produce json
// @Param type query string true "Event type"
// @Param start query string true "Start date (RFC3339)"
// @Param end query string true "End date (RFC3339)"
// @Success 200 {array} models.NodeEvent
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/events [get]
func (h *EventHandler) GetEventsByType(c *gin.Context) <span class="cov0" title="0">{
        eventType := c.Query("type")
        if eventType == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Event type is required",
                })
                return
        }</span>

        <span class="cov0" title="0">startStr := c.Query("start")
        endStr := c.Query("end")

        start, err := time.Parse(time.RFC3339, startStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid start date format",
                })
                return
        }</span>

        <span class="cov0" title="0">end, err := time.Parse(time.RFC3339, endStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid end date format",
                })
                return
        }</span>

        <span class="cov0" title="0">events, err := h.eventService.GetEventsByTypeAndDateRange(eventType, start, end)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "end date must be after start date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, ErrorResponse{
                                Error:   "validation_error",
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get events",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, events)</span>
}

// GetEventStats retrieves event statistics
// @Summary Get event statistics
// @Description Get statistics about events in the system
// @Tags events
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} ErrorResponse
// @Router /api/events/stats [get]
func (h *EventHandler) GetEventStats(c *gin.Context) <span class="cov0" title="0">{
        stats, err := h.eventService.GetEventStats()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get event statistics",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

// CleanupEvents deletes old processed events
// @Summary Cleanup old events
// @Description Delete processed events older than specified days
// @Tags events
// @Param days query int true "Number of days to retain events" minimum(1)
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/events/cleanup [post]
func (h *EventHandler) CleanupEvents(c *gin.Context) <span class="cov0" title="0">{
        days, err := strconv.Atoi(c.Query("days"))
        if err != nil || days &lt; 1 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid days parameter",
                })
                return
        }</span>

        <span class="cov0" title="0">retention := time.Duration(days) * 24 * time.Hour
        deleted, err := h.eventService.CleanupOldEvents(retention)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "minimum retention period is 24 hours" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, ErrorResponse{
                                Error:   "validation_error",
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to cleanup events",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "deleted_events": deleted,
                "message":        "Events cleaned up successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

type HealthService interface {
        CheckDatabaseConnection() error
        GetSystemInfo() (*HealthInfo, error)
}

type HealthInfo struct {
        Status    string            `json:"status"`
        Version   string            `json:"version"`
        Timestamp time.Time         `json:"timestamp"`
        Database  DatabaseHealth    `json:"database"`
        System    SystemHealth      `json:"system"`
        Checks    map[string]string `json:"checks"`
}

type DatabaseHealth struct {
        Status     string `json:"status"`
        Connection string `json:"connection"`
        Response   string `json:"response"`
}

type SystemHealth struct {
        Uptime    time.Duration `json:"uptime"`
        GoVersion string        `json:"go_version"`
        Platform  string        `json:"platform"`
}

type HealthHandler struct {
        *BaseHandler
        healthService HealthService
        startTime     time.Time
}

func NewHealthHandler(healthService HealthService) *HealthHandler <span class="cov0" title="0">{
        return &amp;HealthHandler{
                BaseHandler:   NewBaseHandler(),
                healthService: healthService,
                startTime:     time.Now(),
        }
}</span>

func (h *HealthHandler) GetHealth(c *gin.Context) <span class="cov0" title="0">{
        checks := make(map[string]string)
        overallStatus := "healthy"

        // Check database connection
        dbStatus := "healthy"
        if err := h.healthService.CheckDatabaseConnection(); err != nil </span><span class="cov0" title="0">{
                dbStatus = "unhealthy"
                overallStatus = "unhealthy"
                checks["database"] = err.Error()
        }</span> else<span class="cov0" title="0"> {
                checks["database"] = "ok"
        }</span>

        <span class="cov0" title="0">health := &amp;HealthInfo{
                Status:    overallStatus,
                Version:   "1.0.0",
                Timestamp: time.Now(),
                Database: DatabaseHealth{
                        Status:     dbStatus,
                        Connection: "sqlite",
                        Response:   "ok",
                },
                System: SystemHealth{
                        Uptime:    time.Since(h.startTime),
                        GoVersion: "go1.21",
                        Platform:  "linux/amd64",
                },
                Checks: checks,
        }

        statusCode := http.StatusOK
        if overallStatus == "unhealthy" </span><span class="cov0" title="0">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, health)</span>
}

func (h *HealthHandler) GetLiveness(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status":    "alive",
                "timestamp": time.Now(),
        })
}</span>

func (h *HealthHandler) GetReadiness(c *gin.Context) <span class="cov0" title="0">{
        // Check if the service is ready to serve traffic
        if err := h.healthService.CheckDatabaseConnection(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{
                        "status":    "not ready",
                        "reason":    "database connection failed",
                        "error":     err.Error(),
                        "timestamp": time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "status":    "ready",
                "timestamp": time.Now(),
        })</span>
}

func (h *HealthHandler) GetVersion(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "version":    "1.0.0",
                "build_time": "2024-01-01T00:00:00Z",
                "commit":     "abc123",
                "go_version": "go1.21",
        })
}</span>

func (h *HealthHandler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        // Health check endpoints
        health := r.Group("/health")
        </span><span class="cov0" title="0">{
                health.GET("", h.GetHealth)
                health.GET("/live", h.GetLiveness)
                health.GET("/ready", h.GetReadiness)
        }</span>

        // Version endpoint
        <span class="cov0" title="0">r.GET("/version", h.GetVersion)</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package handlers

import (
        "net/http"

        "url-db/internal/models"

        "github.com/gin-gonic/gin"
)

type MCPService interface {
        CreateMCPNode(req *models.CreateMCPNodeRequest) (*models.MCPNode, error)
        GetMCPNodeByCompositeID(compositeID string) (*models.MCPNode, error)
        GetMCPNodes(domainName string, page, size int, search string) (*models.MCPNodeListResponse, error)
        UpdateMCPNode(compositeID string, req *models.UpdateMCPNodeRequest) (*models.MCPNode, error)
        DeleteMCPNode(compositeID string) error
        FindMCPNodeByURL(req *models.FindMCPNodeRequest) (*models.MCPNode, error)
        BatchGetMCPNodes(req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error)
        GetMCPDomains() ([]models.MCPDomain, error)
        CreateMCPDomain(req *models.CreateMCPDomainRequest) (*models.MCPDomain, error)
        GetMCPNodeAttributes(compositeID string) (*models.MCPNodeAttributesResponse, error)
        SetMCPNodeAttributes(compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributesResponse, error)
        GetMCPServerInfo() (*models.MCPServerInfo, error)
        // Domain attribute management methods
        ListDomainAttributes(domainName string) (*models.MCPDomainAttributeListResponse, error)
        CreateDomainAttribute(domainName string, req *models.CreateAttributeRequest) (*models.MCPDomainAttribute, error)
        GetDomainAttribute(compositeID string) (*models.MCPDomainAttribute, error)
        UpdateDomainAttribute(compositeID string, req *models.UpdateAttributeRequest) (*models.MCPDomainAttribute, error)
        DeleteDomainAttribute(compositeID string) error
}

type MCPHandler struct {
        *BaseHandler
        mcpService MCPService
}

func NewMCPHandler(mcpService MCPService) *MCPHandler <span class="cov0" title="0">{
        return &amp;MCPHandler{
                BaseHandler: NewBaseHandler(),
                mcpService:  mcpService,
        }
}</span>

// CreateMCPNode godoc
// @Summary      Create a new MCP node
// @Description  Create a new URL node using MCP composite key format
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        node  body      models.CreateMCPNodeRequest  true  "MCP node data"
// @Success      201   {object}  models.MCPNode
// @Failure      400   {object}  map[string]interface{}
// @Failure      404   {object}  map[string]interface{}
// @Failure      409   {object}  map[string]interface{}
// @Failure      500   {object}  map[string]interface{}
// @Router       /mcp/nodes [post]
func (h *MCPHandler) CreateMCPNode(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateMCPNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.CreateMCPNode(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, node)</span>
}

// GetMCPNode godoc
// @Summary      Get an MCP node
// @Description  Get MCP node by composite ID
// @Tags         mcp
// @Produce      json
// @Param        composite_id  path      string  true  "Composite ID (domain::url)"
// @Success      200           {object}  models.MCPNode
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id} [get]
func (h *MCPHandler) GetMCPNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.GetMCPNodeByCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

// GetMCPNodes godoc
// @Summary      List MCP nodes
// @Description  Get all MCP nodes with pagination, domain filtering, and search
// @Tags         mcp
// @Produce      json
// @Param        domain_name  query  string  false  "Filter by domain name"
// @Param        page         query  int     false  "Page number" default(1)
// @Param        size         query  int     false  "Page size (max 100)" default(20)
// @Param        search       query  string  false  "Search term for URL content"
// @Success      200          {object}  models.MCPNodeListResponse
// @Failure      500          {object}  map[string]interface{}
// @Router       /mcp/nodes [get]
func (h *MCPHandler) GetMCPNodes(c *gin.Context) <span class="cov0" title="0">{
        domainName := h.GetStringQuery(c, "domain_name")
        page := h.ParseIntQuery(c, "page", 1)
        size := h.ParseIntQuery(c, "size", 20)
        search := h.GetStringQuery(c, "search")

        if size &gt; 100 </span><span class="cov0" title="0">{
                size = 100
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.GetMCPNodes(domainName, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// UpdateMCPNode godoc
// @Summary      Update an MCP node
// @Description  Update MCP node title and description by composite ID
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        composite_id  path      string                       true  "Composite ID (domain::url)"
// @Param        node          body      models.UpdateMCPNodeRequest  true  "Updated MCP node data"
// @Success      200           {object}  models.MCPNode
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id} [put]
func (h *MCPHandler) UpdateMCPNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateMCPNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.UpdateMCPNode(compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

// DeleteMCPNode godoc
// @Summary      Delete an MCP node
// @Description  Delete MCP node by composite ID
// @Tags         mcp
// @Param        composite_id  path  string  true  "Composite ID (domain::url)"
// @Success      204
// @Failure      400  {object}  map[string]interface{}
// @Failure      404  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id} [delete]
func (h *MCPHandler) DeleteMCPNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">err := h.mcpService.DeleteMCPNode(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// FindMCPNodeByURL godoc
// @Summary      Find MCP node by URL
// @Description  Find an MCP node by its URL within a domain
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        request  body      models.FindMCPNodeRequest  true  "Domain and URL to search for"
// @Success      200      {object}  models.MCPNode
// @Failure      400      {object}  map[string]interface{}
// @Failure      404      {object}  map[string]interface{}
// @Failure      500      {object}  map[string]interface{}
// @Router       /mcp/nodes/find [post]
func (h *MCPHandler) FindMCPNodeByURL(c *gin.Context) <span class="cov0" title="0">{
        var req models.FindMCPNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.FindMCPNodeByURL(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

// BatchGetMCPNodes godoc
// @Summary      Batch get MCP nodes
// @Description  Get multiple MCP nodes by their composite IDs in a single request
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        request  body      models.BatchMCPNodeRequest  true  "List of composite IDs"
// @Success      200      {object}  models.BatchMCPNodeResponse
// @Failure      400      {object}  map[string]interface{}
// @Failure      500      {object}  map[string]interface{}
// @Router       /mcp/nodes/batch [post]
func (h *MCPHandler) BatchGetMCPNodes(c *gin.Context) <span class="cov0" title="0">{
        var req models.BatchMCPNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.BatchGetMCPNodes(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetMCPDomains godoc
// @Summary      List MCP domains
// @Description  Get all domains with their node counts in MCP format
// @Tags         mcp
// @Produce      json
// @Success      200  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /mcp/domains [get]
func (h *MCPHandler) GetMCPDomains(c *gin.Context) <span class="cov0" title="0">{
        domains, err := h.mcpService.GetMCPDomains()
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "domains": domains,
        })</span>
}

// CreateMCPDomain godoc
// @Summary      Create a new MCP domain
// @Description  Create a new domain using MCP format
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        domain  body      models.CreateMCPDomainRequest  true  "MCP domain data"
// @Success      201     {object}  models.MCPDomain
// @Failure      400     {object}  map[string]interface{}
// @Failure      409     {object}  map[string]interface{}
// @Failure      500     {object}  map[string]interface{}
// @Router       /mcp/domains [post]
func (h *MCPHandler) CreateMCPDomain(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateMCPDomainRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.mcpService.CreateMCPDomain(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, domain)</span>
}

// GetMCPNodeAttributes godoc
// @Summary      Get MCP node attributes
// @Description  Get all attribute values for an MCP node by composite ID
// @Tags         mcp
// @Produce      json
// @Param        composite_id  path      string  true  "Composite ID (domain::url)"
// @Success      200           {object}  models.MCPNodeAttributesResponse
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id}/attributes [get]
func (h *MCPHandler) GetMCPNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.GetMCPNodeAttributes(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// SetMCPNodeAttributes godoc
// @Summary      Set MCP node attributes
// @Description  Set or update attribute values for an MCP node by composite ID
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        composite_id  path      string                              true  "Composite ID (domain::url)"
// @Param        attributes    body      models.SetMCPNodeAttributesRequest  true  "Attribute data to set"
// @Success      200           {object}  models.MCPNodeAttributesResponse
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/nodes/{composite_id}/attributes [put]
func (h *MCPHandler) SetMCPNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">var req models.SetMCPNodeAttributesRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.SetMCPNodeAttributes(compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetMCPServerInfo godoc
// @Summary      Get MCP server information
// @Description  Get server capabilities and configuration information
// @Tags         mcp
// @Produce      json
// @Success      200  {object}  models.MCPServerInfo
// @Failure      500  {object}  map[string]interface{}
// @Router       /mcp/server/info [get]
func (h *MCPHandler) GetMCPServerInfo(c *gin.Context) <span class="cov0" title="0">{
        info, err := h.mcpService.GetMCPServerInfo()
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, info)</span>
}

// ListDomainAttributes godoc
// @Summary      List domain attributes
// @Description  Get all attribute definitions for a domain
// @Tags         mcp
// @Produce      json
// @Param        domain_name  path      string  true  "Domain name"
// @Success      200          {object}  models.MCPDomainAttributeListResponse
// @Failure      400          {object}  map[string]interface{}
// @Failure      404          {object}  map[string]interface{}
// @Failure      500          {object}  map[string]interface{}
// @Router       /mcp/domains/{domain_name}/attributes [get]
func (h *MCPHandler) ListDomainAttributes(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing domain_name parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.ListDomainAttributes(domainName)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// CreateDomainAttribute godoc
// @Summary      Create domain attribute
// @Description  Create a new attribute definition for a domain
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        domain_name  path      string                        true  "Domain name"
// @Param        attribute    body      models.CreateAttributeRequest  true  "Attribute data"
// @Success      201          {object}  models.MCPDomainAttribute
// @Failure      400          {object}  map[string]interface{}
// @Failure      404          {object}  map[string]interface{}
// @Failure      409          {object}  map[string]interface{}
// @Failure      500          {object}  map[string]interface{}
// @Router       /mcp/domains/{domain_name}/attributes [post]
func (h *MCPHandler) CreateDomainAttribute(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing domain_name parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.mcpService.CreateDomainAttribute(domainName, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, attribute)</span>
}

// GetDomainAttribute godoc
// @Summary      Get domain attribute
// @Description  Get a specific attribute definition by composite ID
// @Tags         mcp
// @Produce      json
// @Param        composite_id  path      string  true  "Composite ID (domain:attribute_id)"
// @Success      200           {object}  models.MCPDomainAttribute
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/attributes/{composite_id} [get]
func (h *MCPHandler) GetDomainAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.mcpService.GetDomainAttribute(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

// UpdateDomainAttribute godoc
// @Summary      Update domain attribute
// @Description  Update an attribute definition by composite ID
// @Tags         mcp
// @Accept       json
// @Produce      json
// @Param        composite_id  path      string                        true  "Composite ID (domain:attribute_id)"
// @Param        attribute     body      models.UpdateAttributeRequest  true  "Attribute update data"
// @Success      200           {object}  models.MCPDomainAttribute
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/attributes/{composite_id} [put]
func (h *MCPHandler) UpdateDomainAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.mcpService.UpdateDomainAttribute(compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

// DeleteDomainAttribute godoc
// @Summary      Delete domain attribute
// @Description  Delete an attribute definition by composite ID
// @Tags         mcp
// @Produce      json
// @Param        composite_id  path      string  true  "Composite ID (domain:attribute_id)"
// @Success      200           {object}  map[string]interface{}
// @Failure      400           {object}  map[string]interface{}
// @Failure      404           {object}  map[string]interface{}
// @Failure      500           {object}  map[string]interface{}
// @Router       /mcp/attributes/{composite_id} [delete]
func (h *MCPHandler) DeleteDomainAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.HandleError(c, NewValidationError("Missing composite_id parameter", nil))
                return
        }</span>

        <span class="cov0" title="0">err := h.mcpService.DeleteDomainAttribute(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Attribute deleted successfully"})</span>
}

func (h *MCPHandler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                mcp := api.Group("/mcp")
                </span><span class="cov0" title="0">{
                        // Node operations
                        nodes := mcp.Group("/nodes")
                        </span><span class="cov0" title="0">{
                                nodes.POST("", h.CreateMCPNode)
                                nodes.GET("", h.GetMCPNodes)
                                nodes.GET("/:composite_id", h.GetMCPNode)
                                nodes.PUT("/:composite_id", h.UpdateMCPNode)
                                nodes.DELETE("/:composite_id", h.DeleteMCPNode)
                                nodes.POST("/find", h.FindMCPNodeByURL)
                                nodes.POST("/batch", h.BatchGetMCPNodes)

                                // Node attributes
                                nodes.GET("/:composite_id/attributes", h.GetMCPNodeAttributes)
                                nodes.PUT("/:composite_id/attributes", h.SetMCPNodeAttributes)
                        }</span>

                        // Domain operations
                        <span class="cov0" title="0">domains := mcp.Group("/domains")
                        </span><span class="cov0" title="0">{
                                domains.GET("", h.GetMCPDomains)
                                domains.POST("", h.CreateMCPDomain)
                                domains.GET("/:domain_name/attributes", h.ListDomainAttributes)
                                domains.POST("/:domain_name/attributes", h.CreateDomainAttribute)
                        }</span>

                        // Domain attributes (by composite ID)
                        <span class="cov0" title="0">attributes := mcp.Group("/attributes")
                        </span><span class="cov0" title="0">{
                                attributes.GET("/:composite_id", h.GetDomainAttribute)
                                attributes.PUT("/:composite_id", h.UpdateDomainAttribute)
                                attributes.DELETE("/:composite_id", h.DeleteDomainAttribute)
                        }</span>

                        // Server info
                        <span class="cov0" title="0">server := mcp.Group("/server")
                        </span><span class="cov0" title="0">{
                                server.GET("/info", h.GetMCPServerInfo)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package handlers

import (
        "fmt"
        "log"
        "os"
        "time"

        "github.com/gin-gonic/gin"
)

func LoggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
                        param.ClientIP,
                        param.TimeStamp.Format(time.RFC3339),
                        param.Method,
                        param.Path,
                        param.Request.Proto,
                        param.StatusCode,
                        param.Latency,
                        param.Request.UserAgent(),
                        param.ErrorMessage,
                )
        }</span>)
}

func CORSMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Accept, Authorization, X-Requested-With")
                c.Header("Access-Control-Expose-Headers", "Content-Length, Content-Type")
                c.Header("Access-Control-Allow-Credentials", "true")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func RecoveryMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.RecoveryWithWriter(os.Stdout, func(c *gin.Context, recovered interface{}) </span><span class="cov0" title="0">{
                if err, ok := recovered.(error); ok </span><span class="cov0" title="0">{
                        log.Printf("Panic recovered: %s", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Panic recovered: %v", recovered)
                }</span>

                <span class="cov0" title="0">c.JSON(500, gin.H{
                        "error":   "internal_error",
                        "message": "An unexpected error occurred",
                })</span>
        })
}

func SecurityHeadersMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
                c.Header("Content-Security-Policy", "default-src 'self'")

                c.Next()
        }</span>
}

func RequestSizeMiddleware(maxSize int64) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.ContentLength &gt; maxSize </span><span class="cov0" title="0">{
                        c.JSON(413, gin.H{
                                "error":   "request_too_large",
                                "message": "Request body too large",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Request-Timeout", timeout.String())
                c.Next()
        }</span>
}

func JSONOnlyMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.Method == "POST" || c.Request.Method == "PUT" || c.Request.Method == "PATCH" </span><span class="cov0" title="0">{
                        contentType := c.GetHeader("Content-Type")
                        if contentType != "application/json" &amp;&amp; contentType != "application/json; charset=utf-8" </span><span class="cov0" title="0">{
                                c.JSON(415, gin.H{
                                        "error":   "unsupported_media_type",
                                        "message": "Content-Type must be application/json",
                                })
                                c.Abort()
                                return
                        }</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

func RequestIDMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = fmt.Sprintf("%d", time.Now().UnixNano())
                }</span>

                <span class="cov0" title="0">c.Header("X-Request-ID", requestID)
                c.Set("request_id", requestID)

                c.Next()</span>
        }
}

func APIVersionMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-API-Version", "v1")
                c.Next()
        }</span>
}

func SetupMiddleware(r *gin.Engine) <span class="cov0" title="0">{
        // Recovery middleware should be first
        r.Use(RecoveryMiddleware())

        // Request ID for tracing
        r.Use(RequestIDMiddleware())

        // Logging middleware
        r.Use(LoggingMiddleware())

        // CORS middleware
        r.Use(CORSMiddleware())

        // Security headers
        r.Use(SecurityHeadersMiddleware())

        // Request size limit (10MB)
        r.Use(RequestSizeMiddleware(10 * 1024 * 1024))

        // JSON content type enforcement for API routes
        apiGroup := r.Group("/api")
        apiGroup.Use(JSONOnlyMiddleware())

        // API version header
        r.Use(APIVersionMiddleware())

        // Timeout middleware (30 seconds)
        r.Use(TimeoutMiddleware(30 * time.Second))
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type NodeAttributeService interface {
        CreateNodeAttribute(nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttribute, error)
        GetNodeAttributesByNodeID(nodeID int) ([]models.NodeAttributeWithInfo, error)
        GetNodeAttributeByID(id int) (*models.NodeAttributeWithInfo, error)
        UpdateNodeAttribute(id int, req *models.UpdateNodeAttributeRequest) (*models.NodeAttribute, error)
        DeleteNodeAttribute(id int) error
        DeleteNodeAttributeByNodeAndAttribute(nodeID, attributeID int) error
}

type NodeAttributeHandler struct {
        *BaseHandler
        nodeAttributeService NodeAttributeService
}

func NewNodeAttributeHandler(nodeAttributeService NodeAttributeService) *NodeAttributeHandler <span class="cov0" title="0">{
        return &amp;NodeAttributeHandler{
                BaseHandler:          NewBaseHandler(),
                nodeAttributeService: nodeAttributeService,
        }
}</span>

func (h *NodeAttributeHandler) CreateNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := h.ParseIntParam(c, "url_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateNodeAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">nodeAttribute, err := h.nodeAttributeService.CreateNodeAttribute(nodeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, nodeAttribute)</span>
}

func (h *NodeAttributeHandler) GetNodeAttributesByNode(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := h.ParseIntParam(c, "url_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attributes, err := h.nodeAttributeService.GetNodeAttributesByNodeID(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "attributes": attributes,
        })</span>
}

func (h *NodeAttributeHandler) GetNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.nodeAttributeService.GetNodeAttributeByID(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

func (h *NodeAttributeHandler) UpdateNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateNodeAttributeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attribute, err := h.nodeAttributeService.UpdateNodeAttribute(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, attribute)</span>
}

func (h *NodeAttributeHandler) DeleteNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">err = h.nodeAttributeService.DeleteNodeAttribute(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *NodeAttributeHandler) DeleteNodeAttributeByNodeAndAttribute(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := h.ParseIntParam(c, "url_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">attributeID, err := h.ParseIntParam(c, "attribute_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">err = h.nodeAttributeService.DeleteNodeAttributeByNodeAndAttribute(nodeID, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *NodeAttributeHandler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                // Individual node attribute operations
                urlAttributes := api.Group("/url-attributes")
                </span><span class="cov0" title="0">{
                        urlAttributes.GET("/:id", h.GetNodeAttribute)
                        urlAttributes.PUT("/:id", h.UpdateNodeAttribute)
                        urlAttributes.DELETE("/:id", h.DeleteNodeAttribute)
                }</span>

                // Node-specific attribute operations
                <span class="cov0" title="0">urls := api.Group("/urls")
                </span><span class="cov0" title="0">{
                        urlNodeAttributes := urls.Group("/:url_id/attributes")
                        </span><span class="cov0" title="0">{
                                urlNodeAttributes.POST("", h.CreateNodeAttribute)
                                urlNodeAttributes.GET("", h.GetNodeAttributesByNode)
                                urlNodeAttributes.DELETE("/:attribute_id", h.DeleteNodeAttributeByNodeAndAttribute)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type NodeService interface {
        CreateNode(domainID int, req *models.CreateNodeRequest) (*models.Node, error)
        GetNodeByID(id int) (*models.Node, error)
        GetNodesByDomainID(domainID, page, size int) (*models.NodeListResponse, error)
        FindNodeByURL(domainID int, req *models.FindNodeByURLRequest) (*models.Node, error)
        UpdateNode(id int, req *models.UpdateNodeRequest) (*models.Node, error)
        DeleteNode(id int) error
        SearchNodes(domainID int, query string, page, size int) (*models.NodeListResponse, error)
}

type NodeHandler struct {
        *BaseHandler
        nodeService NodeService
}

func NewNodeHandler(nodeService NodeService) *NodeHandler <span class="cov0" title="0">{
        return &amp;NodeHandler{
                BaseHandler: NewBaseHandler(),
                nodeService: nodeService,
        }
}</span>

func (h *NodeHandler) CreateNode(c *gin.Context) <span class="cov0" title="0">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.nodeService.CreateNode(domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, node)</span>
}

func (h *NodeHandler) GetNodesByDomain(c *gin.Context) <span class="cov0" title="0">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">page := h.ParseIntQuery(c, "page", 1)
        size := h.ParseIntQuery(c, "size", 20)
        search := h.GetStringQuery(c, "search")

        if size &gt; 100 </span><span class="cov0" title="0">{
                size = 100
        }</span>

        <span class="cov0" title="0">var response *models.NodeListResponse
        if search != "" </span><span class="cov0" title="0">{
                response, err = h.nodeService.SearchNodes(domainID, search, page, size)
        }</span> else<span class="cov0" title="0"> {
                response, err = h.nodeService.GetNodesByDomainID(domainID, page, size)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *NodeHandler) GetNode(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.nodeService.GetNodeByID(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *NodeHandler) UpdateNode(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateNodeRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.nodeService.UpdateNode(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *NodeHandler) DeleteNode(c *gin.Context) <span class="cov0" title="0">{
        id, err := h.ParseIntParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">err = h.nodeService.DeleteNode(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *NodeHandler) FindNodeByURL(c *gin.Context) <span class="cov0" title="0">{
        domainID, err := h.ParseIntParam(c, "domain_id")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req models.FindNodeByURLRequest
        if err := h.BindJSON(c, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.nodeService.FindNodeByURL(domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *NodeHandler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                // Individual node operations
                urls := api.Group("/urls")
                </span><span class="cov0" title="0">{
                        urls.GET("/:id", h.GetNode)
                        urls.PUT("/:id", h.UpdateNode)
                        urls.DELETE("/:id", h.DeleteNode)
                }</span>

                // Domain-specific node operations
                <span class="cov0" title="0">domains := api.Group("/domains")
                </span><span class="cov0" title="0">{
                        domainUrls := domains.Group("/:domain_id/urls")
                        </span><span class="cov0" title="0">{
                                domainUrls.POST("", h.CreateNode)
                                domainUrls.GET("", h.GetNodesByDomain)
                                domainUrls.POST("/find", h.FindNodeByURL)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
)

func SetupRoutes(r *gin.Engine,
        domainHandler *DomainHandler,
        nodeHandler *NodeHandler,
        attributeHandler *AttributeHandler,
        nodeAttributeHandler *NodeAttributeHandler,
        mcpHandler *MCPHandler,
        healthHandler *HealthHandler,
        subscriptionHandler *SubscriptionHandler,
        dependencyHandler *DependencyHandler,
        eventHandler *EventHandler) <span class="cov0" title="0">{

        // Setup middleware
        SetupMiddleware(r)

        // Health check routes (no auth required)
        healthHandler.RegisterRoutes(r)

        // API routes
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                // Domain routes
                domains := api.Group("/domains")
                </span><span class="cov0" title="0">{
                        domains.POST("", domainHandler.CreateDomain)
                        domains.GET("", domainHandler.GetDomains)
                        domains.GET("/:id", domainHandler.GetDomain)
                        domains.PUT("/:id", domainHandler.UpdateDomain)
                        domains.DELETE("/:id", domainHandler.DeleteDomain)

                        // Domain-specific node routes
                        domainNodes := domains.Group("/:domain_id/urls")
                        </span><span class="cov0" title="0">{
                                domainNodes.POST("", nodeHandler.CreateNode)
                                domainNodes.GET("", nodeHandler.GetNodesByDomain)
                                domainNodes.POST("/find", nodeHandler.FindNodeByURL)
                        }</span>

                        // Domain-specific attribute routes
                        <span class="cov0" title="0">domainAttributes := domains.Group("/:domain_id/attributes")
                        </span><span class="cov0" title="0">{
                                domainAttributes.POST("", attributeHandler.CreateAttribute)
                                domainAttributes.GET("", attributeHandler.GetAttributesByDomain)
                        }</span>
                }

                // Node routes
                <span class="cov0" title="0">urls := api.Group("/urls")
                </span><span class="cov0" title="0">{
                        urls.GET("/:id", nodeHandler.GetNode)
                        urls.PUT("/:id", nodeHandler.UpdateNode)
                        urls.DELETE("/:id", nodeHandler.DeleteNode)

                        // Node-specific attribute routes
                        urlAttributes := urls.Group("/:url_id/attributes")
                        </span><span class="cov0" title="0">{
                                urlAttributes.POST("", nodeAttributeHandler.CreateNodeAttribute)
                                urlAttributes.GET("", nodeAttributeHandler.GetNodeAttributesByNode)
                                urlAttributes.DELETE("/:attribute_id", nodeAttributeHandler.DeleteNodeAttributeByNodeAndAttribute)
                        }</span>
                }

                // Attribute routes
                <span class="cov0" title="0">attributes := api.Group("/attributes")
                </span><span class="cov0" title="0">{
                        attributes.GET("/:id", attributeHandler.GetAttribute)
                        attributes.PUT("/:id", attributeHandler.UpdateAttribute)
                        attributes.DELETE("/:id", attributeHandler.DeleteAttribute)
                }</span>

                // Node attribute routes
                <span class="cov0" title="0">urlAttributesGlobal := api.Group("/url-attributes")
                </span><span class="cov0" title="0">{
                        urlAttributesGlobal.GET("/:id", nodeAttributeHandler.GetNodeAttribute)
                        urlAttributesGlobal.PUT("/:id", nodeAttributeHandler.UpdateNodeAttribute)
                        urlAttributesGlobal.DELETE("/:id", nodeAttributeHandler.DeleteNodeAttribute)
                }</span>

                // External dependency management routes
                // Subscription routes
                <span class="cov0" title="0">subscriptions := api.Group("/subscriptions")
                </span><span class="cov0" title="0">{
                        subscriptions.GET("/:id", subscriptionHandler.GetSubscription)
                        subscriptions.PUT("/:id", subscriptionHandler.UpdateSubscription)
                        subscriptions.DELETE("/:id", subscriptionHandler.DeleteSubscription)
                        subscriptions.GET("", subscriptionHandler.GetServiceSubscriptions) // with ?service= query param
                }</span>

                // Node subscription routes
                <span class="cov0" title="0">nodes := api.Group("/nodes")
                </span><span class="cov0" title="0">{
                        nodes.POST("/:nodeId/subscriptions", subscriptionHandler.CreateSubscription)
                        nodes.GET("/:nodeId/subscriptions", subscriptionHandler.GetNodeSubscriptions)

                        // Node dependency routes
                        nodes.POST("/:nodeId/dependencies", dependencyHandler.CreateDependency)
                        nodes.GET("/:nodeId/dependencies", dependencyHandler.GetNodeDependencies)
                        nodes.GET("/:nodeId/dependents", dependencyHandler.GetNodeDependents)

                        // Node event routes
                        nodes.GET("/:nodeId/events", eventHandler.GetNodeEvents)
                }</span>

                // Dependency routes
                <span class="cov0" title="0">dependencies := api.Group("/dependencies")
                </span><span class="cov0" title="0">{
                        dependencies.GET("/:id", dependencyHandler.GetDependency)
                        dependencies.DELETE("/:id", dependencyHandler.DeleteDependency)
                }</span>

                // Event routes
                <span class="cov0" title="0">events := api.Group("/events")
                </span><span class="cov0" title="0">{
                        events.GET("/pending", eventHandler.GetPendingEvents)
                        events.POST("/:eventId/process", eventHandler.ProcessEvent)
                        events.GET("", eventHandler.GetEventsByType) // with query params
                        events.GET("/stats", eventHandler.GetEventStats)
                        events.POST("/cleanup", eventHandler.CleanupEvents)
                }</span>

                // MCP routes
                <span class="cov0" title="0">mcp := api.Group("/mcp")
                </span><span class="cov0" title="0">{
                        // Node operations
                        nodes := mcp.Group("/nodes")
                        </span><span class="cov0" title="0">{
                                nodes.POST("", mcpHandler.CreateMCPNode)
                                nodes.GET("", mcpHandler.GetMCPNodes)
                                nodes.GET("/:composite_id", mcpHandler.GetMCPNode)
                                nodes.PUT("/:composite_id", mcpHandler.UpdateMCPNode)
                                nodes.DELETE("/:composite_id", mcpHandler.DeleteMCPNode)
                                nodes.POST("/find", mcpHandler.FindMCPNodeByURL)
                                nodes.POST("/batch", mcpHandler.BatchGetMCPNodes)

                                // Node attributes
                                nodes.GET("/:composite_id/attributes", mcpHandler.GetMCPNodeAttributes)
                                nodes.PUT("/:composite_id/attributes", mcpHandler.SetMCPNodeAttributes)
                        }</span>

                        // Domain operations
                        <span class="cov0" title="0">domains := mcp.Group("/domains")
                        </span><span class="cov0" title="0">{
                                domains.GET("", mcpHandler.GetMCPDomains)
                                domains.POST("", mcpHandler.CreateMCPDomain)
                        }</span>

                        // Server info
                        <span class="cov0" title="0">server := mcp.Group("/server")
                        </span><span class="cov0" title="0">{
                                server.GET("/info", mcpHandler.GetMCPServerInfo)
                        }</span>
                }
        }
}

func NewRouter() *gin.Engine <span class="cov0" title="0">{
        // Set gin mode based on environment
        gin.SetMode(gin.ReleaseMode) // Can be configured via environment variable

        r := gin.New()

        // Add basic middleware that should always be present
        r.Use(gin.Recovery())

        return r
}</span>

type RouterConfig struct {
        DomainHandler        *DomainHandler
        NodeHandler          *NodeHandler
        AttributeHandler     *AttributeHandler
        NodeAttributeHandler *NodeAttributeHandler
        MCPHandler           *MCPHandler
        HealthHandler        *HealthHandler
        SubscriptionHandler  *SubscriptionHandler
        DependencyHandler    *DependencyHandler
        EventHandler         *EventHandler
}

func SetupRouter(config *RouterConfig) *gin.Engine <span class="cov0" title="0">{
        r := NewRouter()

        SetupRoutes(r,
                config.DomainHandler,
                config.NodeHandler,
                config.AttributeHandler,
                config.NodeAttributeHandler,
                config.MCPHandler,
                config.HealthHandler,
                config.SubscriptionHandler,
                config.DependencyHandler,
                config.EventHandler,
        )

        return r
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
)

// This file provides compatibility interfaces for legacy routing setup
// The actual implementations are in the individual handler files

func SetupLegacyRoutes(r *gin.Engine,
        domainHandler interface{ RegisterRoutes(r *gin.Engine) },
        nodeHandler interface{ RegisterRoutes(r *gin.Engine) },
        attributeHandler interface{ RegisterRoutes(r *gin.Engine) },
        nodeAttributeHandler interface{ RegisterRoutes(r *gin.Engine) },
        mcpHandler interface{ RegisterRoutes(r *gin.Engine) }) <span class="cov0" title="0">{

        // Setup CORS middleware
        r.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })

        // Health check endpoint
        <span class="cov0" title="0">r.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "status":  "healthy",
                        "service": "url-db",
                })
        }</span>)

        // Register all handler routes if they implement RegisterRoutes
        <span class="cov0" title="0">if domainHandler != nil </span><span class="cov0" title="0">{
                domainHandler.RegisterRoutes(r)
        }</span>
        <span class="cov0" title="0">if nodeHandler != nil </span><span class="cov0" title="0">{
                nodeHandler.RegisterRoutes(r)
        }</span>
        <span class="cov0" title="0">if attributeHandler != nil </span><span class="cov0" title="0">{
                attributeHandler.RegisterRoutes(r)
        }</span>
        <span class="cov0" title="0">if nodeAttributeHandler != nil </span><span class="cov0" title="0">{
                nodeAttributeHandler.RegisterRoutes(r)
        }</span>
        <span class="cov0" title="0">if mcpHandler != nil </span><span class="cov0" title="0">{
                mcpHandler.RegisterRoutes(r)
        }</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
        "url-db/internal/services"
)

// SubscriptionHandler handles HTTP requests for subscriptions
type SubscriptionHandler struct {
        subscriptionService *services.SubscriptionService
}

// NewSubscriptionHandler creates a new subscription handler
func NewSubscriptionHandler(subscriptionService *services.SubscriptionService) *SubscriptionHandler <span class="cov0" title="0">{
        return &amp;SubscriptionHandler{
                subscriptionService: subscriptionService,
        }
}</span>

// CreateSubscription creates a new subscription
// @Summary Create subscription
// @Description Create a new subscription for node events
// @Tags subscriptions
// @Accept json
// @Produce json
// @Param nodeId path int true "Node ID"
// @Param request body models.CreateNodeSubscriptionRequest true "Subscription details"
// @Success 201 {object} models.NodeSubscription
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/subscriptions [post]
func (h *SubscriptionHandler) CreateSubscription(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateNodeSubscriptionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid request body",
                })
                return
        }</span>

        <span class="cov0" title="0">subscription, err := h.subscriptionService.CreateSubscription(nodeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to create subscription",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, subscription)</span>
}

// GetSubscription retrieves a subscription
// @Summary Get subscription
// @Description Get a subscription by ID
// @Tags subscriptions
// @Produce json
// @Param id path int true "Subscription ID"
// @Success 200 {object} models.NodeSubscription
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/subscriptions/{id} [get]
func (h *SubscriptionHandler) GetSubscription(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid subscription ID",
                })
                return
        }</span>

        <span class="cov0" title="0">subscription, err := h.subscriptionService.GetSubscription(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "subscription not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Subscription not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get subscription",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, subscription)</span>
}

// UpdateSubscription updates a subscription
// @Summary Update subscription
// @Description Update a subscription
// @Tags subscriptions
// @Accept json
// @Produce json
// @Param id path int true "Subscription ID"
// @Param request body models.UpdateNodeSubscriptionRequest true "Update details"
// @Success 200 {object} models.NodeSubscription
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/subscriptions/{id} [put]
func (h *SubscriptionHandler) UpdateSubscription(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid subscription ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateNodeSubscriptionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Invalid request body",
                })
                return
        }</span>

        <span class="cov0" title="0">subscription, err := h.subscriptionService.UpdateSubscription(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "subscription not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Subscription not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to update subscription",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, subscription)</span>
}

// DeleteSubscription deletes a subscription
// @Summary Delete subscription
// @Description Delete a subscription
// @Tags subscriptions
// @Param id path int true "Subscription ID"
// @Success 204
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/subscriptions/{id} [delete]
func (h *SubscriptionHandler) DeleteSubscription(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid subscription ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.subscriptionService.DeleteSubscription(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "subscription not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Subscription not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to delete subscription",
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetNodeSubscriptions retrieves all subscriptions for a node
// @Summary Get node subscriptions
// @Description Get all subscriptions for a specific node
// @Tags subscriptions
// @Produce json
// @Param nodeId path int true "Node ID"
// @Success 200 {array} models.NodeSubscription
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/nodes/{nodeId}/subscriptions [get]
func (h *SubscriptionHandler) GetNodeSubscriptions(c *gin.Context) <span class="cov0" title="0">{
        nodeID, err := strconv.ParseInt(c.Param("nodeId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">subscriptions, err := h.subscriptionService.GetNodeSubscriptions(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "node not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, ErrorResponse{
                                Error:   "not_found",
                                Message: "Node not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get subscriptions",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, subscriptions)</span>
}

// GetServiceSubscriptions retrieves all subscriptions for a service
// @Summary Get service subscriptions
// @Description Get all subscriptions for a specific service
// @Tags subscriptions
// @Produce json
// @Param service query string true "Service name"
// @Success 200 {array} models.NodeSubscription
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/subscriptions [get]
func (h *SubscriptionHandler) GetServiceSubscriptions(c *gin.Context) <span class="cov0" title="0">{
        service := c.Query("service")
        if service == "" </span><span class="cov0" title="0">{
                // Get all subscriptions with pagination
                page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
                pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))

                subscriptions, total, err := h.subscriptionService.GetAllSubscriptions(page, pageSize)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, ErrorResponse{
                                Error:   "internal_error",
                                Message: "Failed to get subscriptions",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "subscriptions": subscriptions,
                        "total":         total,
                        "page":          page,
                        "page_size":     pageSize,
                })
                return</span>
        }

        <span class="cov0" title="0">subscriptions, err := h.subscriptionService.GetServiceSubscriptions(service)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_error",
                        Message: "Failed to get subscriptions",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, subscriptions)</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package mcp

import (
        "context"
        "fmt"
        "strings"

        "url-db/internal/models"
)

type AttributeManager struct {
        attributeService AttributeService
        domainService    DomainService
        converter        *Converter
}

func NewAttributeManager(attributeService AttributeService, domainService DomainService, converter *Converter) *AttributeManager <span class="cov0" title="0">{
        return &amp;AttributeManager{
                attributeService: attributeService,
                domainService:    domainService,
                converter:        converter,
        }
}</span>

func (am *AttributeManager) GetNodeAttributes(ctx context.Context, compositeID string) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributes, err := am.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get node attributes: %v", err))
        }</span>

        <span class="cov0" title="0">mcpAttributes := am.converter.NodeAttributesToMCPAttributes(attributes)

        return &amp;models.MCPNodeAttributeResponse{
                CompositeID: compositeID,
                Attributes:  mcpAttributes,
        }, nil</span>
}

func (am *AttributeManager) SetNodeAttributes(ctx context.Context, compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := am.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := am.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">if err := am.validateAttributeRequests(req.Attributes); err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(err.Error())
        }</span>

        <span class="cov0" title="0">existingAttributes, err := am.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get existing attributes: %v", err))
        }</span>

        <span class="cov0" title="0">existingAttrMap := make(map[string]models.NodeAttributeWithInfo)
        for _, attr := range existingAttributes </span><span class="cov0" title="0">{
                existingAttrMap[attr.Name] = attr
        }</span>

        <span class="cov0" title="0">requestedAttrMap := make(map[string]string)
        for _, attrReq := range req.Attributes </span><span class="cov0" title="0">{
                requestedAttrMap[attrReq.Name] = attrReq.Value
        }</span>

        <span class="cov0" title="0">for _, existingAttr := range existingAttributes </span><span class="cov0" title="0">{
                if _, exists := requestedAttrMap[existingAttr.Name]; !exists </span><span class="cov0" title="0">{
                        if err := am.attributeService.DeleteNodeAttribute(ctx, nodeID, existingAttr.AttributeID); err != nil </span><span class="cov0" title="0">{
                                return nil, NewInternalServerError(fmt.Sprintf("failed to delete attribute: %v", err))
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, attrReq := range req.Attributes </span><span class="cov0" title="0">{
                attribute, err := am.attributeService.GetAttributeByName(ctx, domain.ID, attrReq.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, NewValidationError(fmt.Sprintf("attribute '%s' not found in domain '%s'", attrReq.Name, domainName))
                }</span>

                <span class="cov0" title="0">if err := am.validateAttributeValue(attribute.Type, attrReq.Value); err != nil </span><span class="cov0" title="0">{
                        return nil, NewValidationError(fmt.Sprintf("invalid value for attribute '%s': %v", attrReq.Name, err))
                }</span>

                <span class="cov0" title="0">if existingAttr, exists := existingAttrMap[attrReq.Name]; exists </span><span class="cov0" title="0">{
                        if err := am.attributeService.DeleteNodeAttribute(ctx, nodeID, existingAttr.AttributeID); err != nil </span><span class="cov0" title="0">{
                                return nil, NewInternalServerError(fmt.Sprintf("failed to delete existing attribute: %v", err))
                        }</span>
                }

                <span class="cov0" title="0">createReq := &amp;models.CreateNodeAttributeRequest{
                        AttributeID: attribute.ID,
                        Value:       attrReq.Value,
                        OrderIndex:  attrReq.OrderIndex,
                }

                if _, err := am.attributeService.SetNodeAttribute(ctx, nodeID, createReq); err != nil </span><span class="cov0" title="0">{
                        return nil, NewInternalServerError(fmt.Sprintf("failed to set attribute: %v", err))
                }</span>
        }

        <span class="cov0" title="0">return am.GetNodeAttributes(ctx, compositeID)</span>
}

func (am *AttributeManager) AddNodeAttribute(ctx context.Context, compositeID string, req *AddAttributeRequest) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := am.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := am.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">attribute, err := am.attributeService.GetAttributeByName(ctx, domain.ID, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(fmt.Sprintf("attribute '%s' not found in domain '%s'", req.Name, domainName))
        }</span>

        <span class="cov0" title="0">if err := am.validateAttributeValue(attribute.Type, req.Value); err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(fmt.Sprintf("invalid value for attribute '%s': %v", req.Name, err))
        }</span>

        <span class="cov0" title="0">createReq := &amp;models.CreateNodeAttributeRequest{
                AttributeID: attribute.ID,
                Value:       req.Value,
                OrderIndex:  req.OrderIndex,
        }

        if _, err := am.attributeService.SetNodeAttribute(ctx, nodeID, createReq); err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to add attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return am.GetNodeAttributes(ctx, compositeID)</span>
}

func (am *AttributeManager) RemoveNodeAttribute(ctx context.Context, compositeID string, attributeName string) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := am.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := am.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">attribute, err := am.attributeService.GetAttributeByName(ctx, domain.ID, attributeName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(fmt.Sprintf("attribute '%s' not found in domain '%s'", attributeName, domainName))
        }</span>

        <span class="cov0" title="0">if err := am.attributeService.DeleteNodeAttribute(ctx, nodeID, attribute.ID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to remove attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return am.GetNodeAttributes(ctx, compositeID)</span>
}

func (am *AttributeManager) GetNodeAttributesByType(ctx context.Context, compositeID string, attributeType models.AttributeType) ([]models.MCPAttribute, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributes, err := am.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get node attributes: %v", err))
        }</span>

        <span class="cov0" title="0">var filteredAttributes []models.MCPAttribute
        for _, attr := range attributes </span><span class="cov0" title="0">{
                if attr.Type == attributeType </span><span class="cov0" title="0">{
                        mcpAttr := am.converter.NodeAttributeToMCPAttribute(&amp;attr)
                        if mcpAttr != nil </span><span class="cov0" title="0">{
                                filteredAttributes = append(filteredAttributes, *mcpAttr)
                        }</span>
                }
        }

        <span class="cov0" title="0">return filteredAttributes, nil</span>
}

func (am *AttributeManager) validateAttributeRequests(attributes []struct {
        Name       string `json:"name" binding:"required"`
        Value      string `json:"value" binding:"required"`
        OrderIndex *int   `json:"order_index"`
}) error <span class="cov0" title="0">{
        if len(attributes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("attributes cannot be empty")
        }</span>

        <span class="cov0" title="0">nameSet := make(map[string]bool)
        for _, attr := range attributes </span><span class="cov0" title="0">{
                if attr.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("attribute name cannot be empty")
                }</span>

                <span class="cov0" title="0">if attr.Value == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("attribute value cannot be empty")
                }</span>

                <span class="cov0" title="0">if nameSet[attr.Name] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate attribute name: %s", attr.Name)
                }</span>
                <span class="cov0" title="0">nameSet[attr.Name] = true</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateAttributeValue(attributeType models.AttributeType, value string) error <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("value cannot be empty")
        }</span>

        <span class="cov0" title="0">switch attributeType </span>{
        case models.AttributeTypeTag:<span class="cov0" title="0">
                return am.validateTagValue(value)</span>
        case models.AttributeTypeOrderedTag:<span class="cov0" title="0">
                return am.validateOrderedTagValue(value)</span>
        case models.AttributeTypeNumber:<span class="cov0" title="0">
                return am.validateNumberValue(value)</span>
        case models.AttributeTypeString:<span class="cov0" title="0">
                return am.validateStringValue(value)</span>
        case models.AttributeTypeMarkdown:<span class="cov0" title="0">
                return am.validateMarkdownValue(value)</span>
        case models.AttributeTypeImage:<span class="cov0" title="0">
                return am.validateImageValue(value)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown attribute type: %s", attributeType)</span>
        }
}

func (am *AttributeManager) validateTagValue(value string) error <span class="cov0" title="0">{
        if len(value) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("tag value cannot exceed 50 characters")
        }</span>

        <span class="cov0" title="0">value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("tag value cannot be empty after trimming")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateOrderedTagValue(value string) error <span class="cov0" title="0">{
        if len(value) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("ordered tag value cannot exceed 50 characters")
        }</span>

        <span class="cov0" title="0">value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ordered tag value cannot be empty after trimming")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateNumberValue(value string) error <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("number value cannot be empty")
        }</span>

        <span class="cov0" title="0">if _, err := fmt.Sscanf(value, "%f", new(float64)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid number format: %s", value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateStringValue(value string) error <span class="cov0" title="0">{
        if len(value) &gt; 2048 </span><span class="cov0" title="0">{
                return fmt.Errorf("string value cannot exceed 2048 characters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateMarkdownValue(value string) error <span class="cov0" title="0">{
        if len(value) &gt; 10000 </span><span class="cov0" title="0">{
                return fmt.Errorf("markdown value cannot exceed 10000 characters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateImageValue(value string) error <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("image value cannot be empty")
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(value, "http://") &amp;&amp; !strings.HasPrefix(value, "https://") &amp;&amp; !strings.HasPrefix(value, "data:image/") </span><span class="cov0" title="0">{
                return fmt.Errorf("image value must be a valid URL or data URI")
        }</span>

        <span class="cov0" title="0">if len(value) &gt; 2048 </span><span class="cov0" title="0">{
                return fmt.Errorf("image value cannot exceed 2048 characters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) BatchSetNodeAttributes(ctx context.Context, requests []BatchAttributeRequest) (*BatchAttributeResponse, error) <span class="cov0" title="0">{
        if len(requests) == 0 </span><span class="cov0" title="0">{
                return &amp;BatchAttributeResponse{
                        Success: []BatchAttributeSuccess{},
                        Failed:  []BatchAttributeFailure{},
                }, nil
        }</span>

        <span class="cov0" title="0">var successes []BatchAttributeSuccess
        var failures []BatchAttributeFailure

        for _, req := range requests </span><span class="cov0" title="0">{
                response, err := am.SetNodeAttributes(ctx, req.CompositeID, &amp;req.AttributesRequest)
                if err != nil </span><span class="cov0" title="0">{
                        failures = append(failures, BatchAttributeFailure{
                                CompositeID: req.CompositeID,
                                Error:       err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        successes = append(successes, BatchAttributeSuccess{
                                CompositeID: req.CompositeID,
                                Attributes:  response.Attributes,
                        })
                }</span>
        }

        <span class="cov0" title="0">return &amp;BatchAttributeResponse{
                Success: successes,
                Failed:  failures,
        }, nil</span>
}

type AddAttributeRequest struct {
        Name       string `json:"name" binding:"required"`
        Value      string `json:"value" binding:"required"`
        OrderIndex *int   `json:"order_index"`
}

type BatchAttributeRequest struct {
        CompositeID       string                             `json:"composite_id"`
        AttributesRequest models.SetMCPNodeAttributesRequest `json:"attributes_request"`
}

type BatchAttributeResponse struct {
        Success []BatchAttributeSuccess `json:"success"`
        Failed  []BatchAttributeFailure `json:"failed"`
}

type BatchAttributeSuccess struct {
        CompositeID string                `json:"composite_id"`
        Attributes  []models.MCPAttribute `json:"attributes"`
}

type BatchAttributeFailure struct {
        CompositeID string `json:"composite_id"`
        Error       string `json:"error"`
}

type AttributeFilter struct {
        Name  string               `json:"name,omitempty"`
        Type  models.AttributeType `json:"type,omitempty"`
        Value string               `json:"value,omitempty"`
}

type AttributeStats struct {
        AttributeName string `json:"attribute_name"`
        TotalCount    int    `json:"total_count"`
        UniqueValues  int    `json:"unique_values"`
        MostCommon    string `json:"most_common"`
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package mcp

import (
        "context"
        "fmt"

        "url-db/internal/models"
)

// Attribute operation methods for mcpService

func (s *mcpService) GetNodeAttributes(ctx context.Context, compositeID string) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributes, err := s.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get node attributes: %v", err))
        }</span>

        <span class="cov0" title="0">mcpAttributes := s.converter.NodeAttributesToMCPAttributes(attributes)

        return &amp;models.MCPNodeAttributeResponse{
                CompositeID: compositeID,
                Attributes:  mcpAttributes,
        }, nil</span>
}

func (s *mcpService) SetNodeAttributes(ctx context.Context, compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := s.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">existingAttributes, err := s.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get existing attributes: %v", err))
        }</span>

        <span class="cov0" title="0">existingAttrMap := make(map[string]int)
        for _, attr := range existingAttributes </span><span class="cov0" title="0">{
                existingAttrMap[attr.Name] = attr.AttributeID
        }</span>

        <span class="cov0" title="0">for _, attrReq := range req.Attributes </span><span class="cov0" title="0">{
                attribute, err := s.attributeService.GetAttributeByName(ctx, domain.ID, attrReq.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, NewValidationError(fmt.Sprintf("attribute '%s' not found", attrReq.Name))
                }</span>

                <span class="cov0" title="0">if existingAttrID, exists := existingAttrMap[attrReq.Name]; exists </span><span class="cov0" title="0">{
                        if err := s.attributeService.DeleteNodeAttribute(ctx, nodeID, existingAttrID); err != nil </span><span class="cov0" title="0">{
                                return nil, NewInternalServerError(fmt.Sprintf("failed to delete existing attribute: %v", err))
                        }</span>
                }

                <span class="cov0" title="0">createReq := &amp;models.CreateNodeAttributeRequest{
                        AttributeID: attribute.ID,
                        Value:       attrReq.Value,
                        OrderIndex:  attrReq.OrderIndex,
                }

                if _, err := s.attributeService.SetNodeAttribute(ctx, nodeID, createReq); err != nil </span><span class="cov0" title="0">{
                        return nil, NewInternalServerError(fmt.Sprintf("failed to set attribute: %v", err))
                }</span>
        }

        <span class="cov0" title="0">return s.GetNodeAttributes(ctx, compositeID)</span>
}

// Domain attribute management methods
func (s *mcpService) ListDomainAttributes(ctx context.Context, domainName string) (*models.MCPDomainAttributeListResponse, error) <span class="cov0" title="0">{
        domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">response, err := s.attributeService.ListAttributes(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list attributes: %v", err))
        }</span>

        <span class="cov0" title="0">mcpAttributes := make([]models.MCPDomainAttribute, len(response.Attributes))
        for i, attr := range response.Attributes </span><span class="cov0" title="0">{
                compositeID := s.converter.CreateAttributeCompositeID(domain.Name, attr.ID)
                mcpAttributes[i] = models.MCPDomainAttribute{
                        CompositeID: compositeID,
                        Name:        attr.Name,
                        Type:        attr.Type,
                        Description: attr.Description,
                        CreatedAt:   attr.CreatedAt,
                        UpdatedAt:   attr.CreatedAt, // Assuming no updated_at field in Attribute model
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomainAttributeListResponse{
                DomainName: domainName,
                Attributes: mcpAttributes,
                TotalCount: len(mcpAttributes),
        }, nil</span>
}

func (s *mcpService) CreateDomainAttribute(ctx context.Context, domainName string, req *models.CreateAttributeRequest) (*models.MCPDomainAttribute, error) <span class="cov0" title="0">{
        domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeService.CreateAttribute(ctx, domain.ID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to create attribute: %v", err))
        }</span>

        <span class="cov0" title="0">compositeID := s.converter.CreateAttributeCompositeID(domain.Name, attribute.ID)
        return &amp;models.MCPDomainAttribute{
                CompositeID: compositeID,
                Name:        attribute.Name,
                Type:        attribute.Type,
                Description: attribute.Description,
                CreatedAt:   attribute.CreatedAt,
                UpdatedAt:   attribute.CreatedAt,
        }, nil</span>
}

func (s *mcpService) GetDomainAttribute(ctx context.Context, compositeID string) (*models.MCPDomainAttribute, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateAttributeCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributeID, err := s.converter.ExtractAttributeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeService.GetAttribute(ctx, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomainAttribute{
                CompositeID: compositeID,
                Name:        attribute.Name,
                Type:        attribute.Type,
                Description: attribute.Description,
                CreatedAt:   attribute.CreatedAt,
                UpdatedAt:   attribute.CreatedAt,
        }, nil</span>
}

func (s *mcpService) UpdateDomainAttribute(ctx context.Context, compositeID string, req *models.UpdateAttributeRequest) (*models.MCPDomainAttribute, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateAttributeCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributeID, err := s.converter.ExtractAttributeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeService.UpdateAttribute(ctx, attributeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to update attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomainAttribute{
                CompositeID: compositeID,
                Name:        attribute.Name,
                Type:        attribute.Type,
                Description: attribute.Description,
                CreatedAt:   attribute.CreatedAt,
                UpdatedAt:   attribute.CreatedAt,
        }, nil</span>
}

func (s *mcpService) DeleteDomainAttribute(ctx context.Context, compositeID string) error <span class="cov0" title="0">{
        if err := s.converter.ValidateAttributeCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributeID, err := s.converter.ExtractAttributeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">if err := s.attributeService.DeleteAttribute(ctx, attributeID); err != nil </span><span class="cov0" title="0">{
                return NewInternalServerError(fmt.Sprintf("failed to delete attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package mcp

import (
        "context"
        "sync"
        "time"

        "url-db/internal/models"
)

type BatchProcessor struct {
        mcpService MCPService
        maxWorkers int
        timeout    time.Duration
}

type BatchResult struct {
        CompositeID string
        Node        *models.MCPNode
        Error       error
}

func NewBatchProcessor(mcpService MCPService, maxWorkers int, timeout time.Duration) *BatchProcessor <span class="cov0" title="0">{
        if maxWorkers &lt;= 0 </span><span class="cov0" title="0">{
                maxWorkers = 10
        }</span>
        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;BatchProcessor{
                mcpService: mcpService,
                maxWorkers: maxWorkers,
                timeout:    timeout,
        }</span>
}

func (bp *BatchProcessor) BatchGetNodes(ctx context.Context, compositeIDs []string) (*models.BatchMCPNodeResponse, error) <span class="cov0" title="0">{
        if len(compositeIDs) == 0 </span><span class="cov0" title="0">{
                return &amp;models.BatchMCPNodeResponse{
                        Nodes:    []models.MCPNode{},
                        NotFound: []string{},
                }, nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, bp.timeout)
        defer cancel()

        jobs := make(chan string, len(compositeIDs))
        results := make(chan BatchResult, len(compositeIDs))

        var wg sync.WaitGroup
        workerCount := min(bp.maxWorkers, len(compositeIDs))

        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go bp.worker(ctx, jobs, results, &amp;wg)
        }</span>

        <span class="cov0" title="0">for _, compositeID := range compositeIDs </span><span class="cov0" title="0">{
                jobs &lt;- compositeID
        }</span>
        <span class="cov0" title="0">close(jobs)

        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov0" title="0">return bp.collectResults(results, len(compositeIDs))</span>
}

func (bp *BatchProcessor) worker(ctx context.Context, jobs &lt;-chan string, results chan&lt;- BatchResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for compositeID := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        results &lt;- BatchResult{
                                CompositeID: compositeID,
                                Error:       ctx.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0">
                        node, err := bp.mcpService.GetNode(ctx, compositeID)
                        results &lt;- BatchResult{
                                CompositeID: compositeID,
                                Node:        node,
                                Error:       err,
                        }</span>
                }
        }
}

func (bp *BatchProcessor) collectResults(results &lt;-chan BatchResult, expectedCount int) (*models.BatchMCPNodeResponse, error) <span class="cov0" title="0">{
        nodes := make([]models.MCPNode, 0, expectedCount)
        notFound := make([]string, 0)

        for result := range results </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        notFound = append(notFound, result.CompositeID)
                }</span> else<span class="cov0" title="0"> if result.Node != nil </span><span class="cov0" title="0">{
                        nodes = append(nodes, *result.Node)
                }</span>
        }

        <span class="cov0" title="0">return &amp;models.BatchMCPNodeResponse{
                Nodes:    nodes,
                NotFound: notFound,
        }, nil</span>
}

func (bp *BatchProcessor) BatchCreateNodes(ctx context.Context, requests []models.CreateMCPNodeRequest) (*BatchCreateResponse, error) <span class="cov0" title="0">{
        if len(requests) == 0 </span><span class="cov0" title="0">{
                return &amp;BatchCreateResponse{
                        Nodes:  []models.MCPNode{},
                        Failed: []BatchCreateFailure{},
                }, nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, bp.timeout)
        defer cancel()

        jobs := make(chan models.CreateMCPNodeRequest, len(requests))
        results := make(chan BatchCreateResult, len(requests))

        var wg sync.WaitGroup
        workerCount := min(bp.maxWorkers, len(requests))

        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go bp.createWorker(ctx, jobs, results, &amp;wg)
        }</span>

        <span class="cov0" title="0">for _, request := range requests </span><span class="cov0" title="0">{
                jobs &lt;- request
        }</span>
        <span class="cov0" title="0">close(jobs)

        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov0" title="0">return bp.collectCreateResults(results, len(requests))</span>
}

func (bp *BatchProcessor) createWorker(ctx context.Context, jobs &lt;-chan models.CreateMCPNodeRequest, results chan&lt;- BatchCreateResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for request := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        results &lt;- BatchCreateResult{
                                Request: request,
                                Error:   ctx.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0">
                        node, err := bp.mcpService.CreateNode(ctx, &amp;request)
                        results &lt;- BatchCreateResult{
                                Request: request,
                                Node:    node,
                                Error:   err,
                        }</span>
                }
        }
}

func (bp *BatchProcessor) collectCreateResults(results &lt;-chan BatchCreateResult, expectedCount int) (*BatchCreateResponse, error) <span class="cov0" title="0">{
        nodes := make([]models.MCPNode, 0, expectedCount)
        failed := make([]BatchCreateFailure, 0)

        for result := range results </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        failed = append(failed, BatchCreateFailure{
                                Request: result.Request,
                                Error:   result.Error.Error(),
                        })
                }</span> else<span class="cov0" title="0"> if result.Node != nil </span><span class="cov0" title="0">{
                        nodes = append(nodes, *result.Node)
                }</span>
        }

        <span class="cov0" title="0">return &amp;BatchCreateResponse{
                Nodes:  nodes,
                Failed: failed,
        }, nil</span>
}

func (bp *BatchProcessor) BatchUpdateNodes(ctx context.Context, updates []BatchUpdateRequest) (*BatchUpdateResponse, error) <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return &amp;BatchUpdateResponse{
                        Nodes:  []models.MCPNode{},
                        Failed: []BatchUpdateFailure{},
                }, nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, bp.timeout)
        defer cancel()

        jobs := make(chan BatchUpdateRequest, len(updates))
        results := make(chan BatchUpdateResult, len(updates))

        var wg sync.WaitGroup
        workerCount := min(bp.maxWorkers, len(updates))

        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go bp.updateWorker(ctx, jobs, results, &amp;wg)
        }</span>

        <span class="cov0" title="0">for _, update := range updates </span><span class="cov0" title="0">{
                jobs &lt;- update
        }</span>
        <span class="cov0" title="0">close(jobs)

        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov0" title="0">return bp.collectUpdateResults(results, len(updates))</span>
}

func (bp *BatchProcessor) updateWorker(ctx context.Context, jobs &lt;-chan BatchUpdateRequest, results chan&lt;- BatchUpdateResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for request := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        results &lt;- BatchUpdateResult{
                                CompositeID: request.CompositeID,
                                Error:       ctx.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0">
                        node, err := bp.mcpService.UpdateNode(ctx, request.CompositeID, &amp;request.UpdateRequest)
                        results &lt;- BatchUpdateResult{
                                CompositeID: request.CompositeID,
                                Node:        node,
                                Error:       err,
                        }</span>
                }
        }
}

func (bp *BatchProcessor) collectUpdateResults(results &lt;-chan BatchUpdateResult, expectedCount int) (*BatchUpdateResponse, error) <span class="cov0" title="0">{
        nodes := make([]models.MCPNode, 0, expectedCount)
        failed := make([]BatchUpdateFailure, 0)

        for result := range results </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        failed = append(failed, BatchUpdateFailure{
                                CompositeID: result.CompositeID,
                                Error:       result.Error.Error(),
                        })
                }</span> else<span class="cov0" title="0"> if result.Node != nil </span><span class="cov0" title="0">{
                        nodes = append(nodes, *result.Node)
                }</span>
        }

        <span class="cov0" title="0">return &amp;BatchUpdateResponse{
                Nodes:  nodes,
                Failed: failed,
        }, nil</span>
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

type BatchCreateResult struct {
        Request models.CreateMCPNodeRequest
        Node    *models.MCPNode
        Error   error
}

type BatchCreateResponse struct {
        Nodes  []models.MCPNode     `json:"nodes"`
        Failed []BatchCreateFailure `json:"failed"`
}

type BatchCreateFailure struct {
        Request models.CreateMCPNodeRequest `json:"request"`
        Error   string                      `json:"error"`
}

type BatchUpdateRequest struct {
        CompositeID   string                   `json:"composite_id"`
        UpdateRequest models.UpdateNodeRequest `json:"update_request"`
}

type BatchUpdateResult struct {
        CompositeID string
        Node        *models.MCPNode
        Error       error
}

type BatchUpdateResponse struct {
        Nodes  []models.MCPNode     `json:"nodes"`
        Failed []BatchUpdateFailure `json:"failed"`
}

type BatchUpdateFailure struct {
        CompositeID string `json:"composite_id"`
        Error       string `json:"error"`
}

type BatchDeleteRequest struct {
        CompositeIDs []string `json:"composite_ids"`
}

type BatchDeleteResponse struct {
        Deleted []string             `json:"deleted"`
        Failed  []BatchDeleteFailure `json:"failed"`
}

type BatchDeleteFailure struct {
        CompositeID string `json:"composite_id"`
        Error       string `json:"error"`
}

func (bp *BatchProcessor) BatchDeleteNodes(ctx context.Context, compositeIDs []string) (*BatchDeleteResponse, error) <span class="cov0" title="0">{
        if len(compositeIDs) == 0 </span><span class="cov0" title="0">{
                return &amp;BatchDeleteResponse{
                        Deleted: []string{},
                        Failed:  []BatchDeleteFailure{},
                }, nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, bp.timeout)
        defer cancel()

        jobs := make(chan string, len(compositeIDs))
        results := make(chan BatchDeleteResult, len(compositeIDs))

        var wg sync.WaitGroup
        workerCount := min(bp.maxWorkers, len(compositeIDs))

        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go bp.deleteWorker(ctx, jobs, results, &amp;wg)
        }</span>

        <span class="cov0" title="0">for _, compositeID := range compositeIDs </span><span class="cov0" title="0">{
                jobs &lt;- compositeID
        }</span>
        <span class="cov0" title="0">close(jobs)

        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov0" title="0">return bp.collectDeleteResults(results, len(compositeIDs))</span>
}

func (bp *BatchProcessor) deleteWorker(ctx context.Context, jobs &lt;-chan string, results chan&lt;- BatchDeleteResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for compositeID := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        results &lt;- BatchDeleteResult{
                                CompositeID: compositeID,
                                Error:       ctx.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0">
                        err := bp.mcpService.DeleteNode(ctx, compositeID)
                        results &lt;- BatchDeleteResult{
                                CompositeID: compositeID,
                                Error:       err,
                        }</span>
                }
        }
}

func (bp *BatchProcessor) collectDeleteResults(results &lt;-chan BatchDeleteResult, expectedCount int) (*BatchDeleteResponse, error) <span class="cov0" title="0">{
        deleted := make([]string, 0, expectedCount)
        failed := make([]BatchDeleteFailure, 0)

        for result := range results </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        failed = append(failed, BatchDeleteFailure{
                                CompositeID: result.CompositeID,
                                Error:       result.Error.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        deleted = append(deleted, result.CompositeID)
                }</span>
        }

        <span class="cov0" title="0">return &amp;BatchDeleteResponse{
                Deleted: deleted,
                Failed:  failed,
        }, nil</span>
}

type BatchDeleteResult struct {
        CompositeID string
        Error       error
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package mcp

import (
        "strconv"
        "strings"

        "url-db/internal/compositekey"
)

// CompositeKeyAdapter adapts the compositekey.Service to the CompositeKeyService interface
type CompositeKeyAdapter struct {
        service *compositekey.Service
}

// NewCompositeKeyAdapter creates a new adapter
func NewCompositeKeyAdapter(service *compositekey.Service) *CompositeKeyAdapter <span class="cov8" title="1">{
        return &amp;CompositeKeyAdapter{
                service: service,
        }
}</span>

// Create creates a composite key from domain name and node ID
func (a *CompositeKeyAdapter) Create(domainName string, nodeID int) string <span class="cov8" title="1">{
        compositeKey, err := a.service.Create(domainName, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                // Return empty string if creation fails
                return ""
        }</span>
        <span class="cov8" title="1">return compositeKey</span>
}

// Parse parses a composite key string and returns a CompositeKey
func (a *CompositeKeyAdapter) Parse(compositeID string) (*CompositeKey, error) <span class="cov8" title="1">{
        toolName, domainName, id, err := a.service.ParseComponents(compositeID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;CompositeKey{
                ToolName:   toolName,
                DomainName: domainName,
                ID:         id,
        }, nil</span>
}

// Validate validates a composite key
func (a *CompositeKeyAdapter) Validate(compositeID string) error <span class="cov8" title="1">{
        if !a.service.Validate(compositeID) </span><span class="cov8" title="1">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Additional helper methods for compatibility
func (a *CompositeKeyAdapter) ExtractDomainName(compositeID string) (string, error) <span class="cov8" title="1">{
        return a.service.GetDomainName(compositeID)
}</span>

func (a *CompositeKeyAdapter) ExtractNodeID(compositeID string) (int, error) <span class="cov8" title="1">{
        return a.service.GetID(compositeID)
}</span>

func (a *CompositeKeyAdapter) ExtractToolName(compositeID string) (string, error) <span class="cov8" title="1">{
        return a.service.GetToolName(compositeID)
}</span>

// Simple parsing fallback for basic format validation
func parseCompositeID(compositeID string) (string, string, int, error) <span class="cov0" title="0">{
        parts := strings.Split(compositeID, ":")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return "", "", 0, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return "", "", 0, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">return parts[0], parts[1], id, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package mcp

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "url-db/internal/models"
)

type Converter struct {
        compositeKeyService CompositeKeyService
        toolName            string
}

type CompositeKeyService interface {
        Create(domainName string, nodeID int) string
        Parse(compositeID string) (*CompositeKey, error)
        Validate(compositeID string) error
}

type CompositeKey struct {
        ToolName   string
        DomainName string
        ID         int
}

func NewConverter(compositeKeyService CompositeKeyService, toolName string) *Converter <span class="cov0" title="0">{
        return &amp;Converter{
                compositeKeyService: compositeKeyService,
                toolName:            toolName,
        }
}</span>

// ParseCompositeID parses a composite ID and returns tool name, domain name, and node ID
func (c *Converter) ParseCompositeID(compositeID string) (string, string, string, error) <span class="cov0" title="0">{
        compositeKey, err := c.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", err
        }</span>

        <span class="cov0" title="0">return compositeKey.ToolName, compositeKey.DomainName, strconv.Itoa(compositeKey.ID), nil</span>
}

func (c *Converter) NodeToMCPNode(node *models.Node, domain *models.Domain) (*models.MCPNode, error) <span class="cov0" title="0">{
        if node == nil || domain == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node and domain cannot be nil")
        }</span>

        <span class="cov0" title="0">compositeID := c.compositeKeyService.Create(domain.Name, node.ID)

        return &amp;models.MCPNode{
                CompositeID: compositeID,
                URL:         node.Content,
                DomainName:  domain.Name,
                Title:       node.Title,
                Description: node.Description,
                CreatedAt:   node.CreatedAt,
                UpdatedAt:   node.UpdatedAt,
        }, nil</span>
}

func (c *Converter) MCPNodeToNode(mcpNode *models.MCPNode) (*models.Node, int, error) <span class="cov0" title="0">{
        if mcpNode == nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("mcpNode cannot be nil")
        }</span>

        <span class="cov0" title="0">compositeKey, err := c.compositeKeyService.Parse(mcpNode.CompositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">node := &amp;models.Node{
                ID:          compositeKey.ID,
                Content:     mcpNode.URL,
                Title:       mcpNode.Title,
                Description: mcpNode.Description,
                CreatedAt:   mcpNode.CreatedAt,
                UpdatedAt:   mcpNode.UpdatedAt,
        }

        return node, compositeKey.ID, nil</span>
}

func (c *Converter) CreateMCPNodeRequestToCreateNodeRequest(req *models.CreateMCPNodeRequest) *models.CreateNodeRequest <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;models.CreateNodeRequest{
                URL:         req.URL,
                Title:       req.Title,
                Description: req.Description,
        }</span>
}

func (c *Converter) UpdateMCPNodeRequestToUpdateNodeRequest(req *models.UpdateNodeRequest) *models.UpdateNodeRequest <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;models.UpdateNodeRequest{
                Title:       req.Title,
                Description: req.Description,
        }</span>
}

func (c *Converter) DomainToMCPDomain(domain *models.Domain, nodeCount int) *MCPDomain <span class="cov0" title="0">{
        if domain == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;MCPDomain{
                Name:        domain.Name,
                Description: domain.Description,
                NodeCount:   nodeCount,
                CreatedAt:   domain.CreatedAt,
                UpdatedAt:   domain.UpdatedAt,
        }</span>
}

func (c *Converter) NodeAttributeToMCPAttribute(attr *models.NodeAttributeWithInfo) *models.MCPAttribute <span class="cov0" title="0">{
        if attr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPAttribute{
                Name:  attr.Name,
                Type:  string(attr.Type),
                Value: attr.Value,
        }</span>
}

func (c *Converter) NodeAttributesToMCPAttributes(attrs []models.NodeAttributeWithInfo) []models.MCPAttribute <span class="cov0" title="0">{
        if attrs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mcpAttrs := make([]models.MCPAttribute, 0, len(attrs))
        for _, attr := range attrs </span><span class="cov0" title="0">{
                if mcpAttr := c.NodeAttributeToMCPAttribute(&amp;attr); mcpAttr != nil </span><span class="cov0" title="0">{
                        mcpAttrs = append(mcpAttrs, *mcpAttr)
                }</span>
        }

        <span class="cov0" title="0">return mcpAttrs</span>
}

func (c *Converter) ExtractDomainNameFromCompositeID(compositeID string) (string, error) <span class="cov0" title="0">{
        compositeKey, err := c.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return compositeKey.DomainName, nil</span>
}

func (c *Converter) ExtractNodeIDFromCompositeID(compositeID string) (int, error) <span class="cov0" title="0">{
        compositeKey, err := c.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return compositeKey.ID, nil</span>
}

func (c *Converter) ValidateCompositeID(compositeID string) error <span class="cov0" title="0">{
        return c.compositeKeyService.Validate(compositeID)
}</span>

// Attribute composite key methods
func (c *Converter) CreateAttributeCompositeID(domainName string, attributeID int) string <span class="cov0" title="0">{
        // Use a different format for attributes: tool-name:domain:attr-{id}
        return fmt.Sprintf("%s:%s:attr-%d", c.toolName, domainName, attributeID)
}</span>

func (c *Converter) ExtractAttributeIDFromCompositeID(compositeID string) (int, error) <span class="cov0" title="0">{
        // Don't use the standard validation because it expects numeric IDs
        parts := strings.Split(compositeID, ":")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid composite ID format")
        }</span>

        // Validate tool name
        <span class="cov0" title="0">if parts[0] != c.toolName </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid tool name in composite ID")
        }</span>

        // Check if this is an attribute ID (has "attr-" prefix)
        <span class="cov0" title="0">if !strings.HasPrefix(parts[2], "attr-") </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("not an attribute composite ID")
        }</span>

        // Extract the numeric ID after "attr-"
        <span class="cov0" title="0">idStr := strings.TrimPrefix(parts[2], "attr-")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid attribute ID: %v", err)
        }</span>

        <span class="cov0" title="0">if id &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("attribute ID must be positive")
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

func (c *Converter) ValidateAttributeCompositeID(compositeID string) error <span class="cov0" title="0">{
        parts := strings.Split(compositeID, ":")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid composite ID format")
        }</span>

        <span class="cov0" title="0">if parts[0] != c.toolName </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid tool name in composite ID")
        }</span>

        <span class="cov0" title="0">if parts[1] == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("domain name is empty")
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(parts[2], "attr-") </span><span class="cov0" title="0">{
                return fmt.Errorf("not an attribute composite ID")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type MCPDomain struct {
        Name        string    `json:"name"`
        Description string    `json:"description"`
        NodeCount   int       `json:"node_count"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

type MCPDomainListResponse struct {
        Domains []MCPDomain `json:"domains"`
}

type MCPServerInfo struct {
        Name               string   `json:"name"`
        Version            string   `json:"version"`
        Description        string   `json:"description"`
        Capabilities       []string `json:"capabilities"`
        CompositeKeyFormat string   `json:"composite_key_format"`
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package mcp

import (
        "context"
        "fmt"
        "regexp"
        "strings"
        "time"

        "url-db/internal/models"
)

type DomainManager struct {
        domainService    DomainService
        nodeCountService NodeCountService
        converter        *Converter
}

func NewDomainManager(domainService DomainService, nodeCountService NodeCountService, converter *Converter) *DomainManager <span class="cov0" title="0">{
        return &amp;DomainManager{
                domainService:    domainService,
                nodeCountService: nodeCountService,
                converter:        converter,
        }
}</span>

func (dm *DomainManager) ListDomains(ctx context.Context) (*MCPDomainListResponse, error) <span class="cov0" title="0">{
        response, err := dm.domainService.ListDomains(ctx, 1, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list domains: %v", err))
        }</span>

        <span class="cov0" title="0">mcpDomains := make([]MCPDomain, 0, len(response.Domains))
        for _, domain := range response.Domains </span><span class="cov0" title="0">{
                nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
                if err != nil </span><span class="cov0" title="0">{
                        nodeCount = 0
                }</span>

                <span class="cov0" title="0">mcpDomain := dm.converter.DomainToMCPDomain(&amp;domain, nodeCount)
                if mcpDomain != nil </span><span class="cov0" title="0">{
                        mcpDomains = append(mcpDomains, *mcpDomain)
                }</span>
        }

        <span class="cov0" title="0">return &amp;MCPDomainListResponse{
                Domains: mcpDomains,
        }, nil</span>
}

func (dm *DomainManager) CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*MCPDomain, error) <span class="cov0" title="0">{
        if err := dm.validateDomainName(req.Name); err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(err.Error())
        }</span>

        <span class="cov0" title="0">normalizedName := dm.normalizeDomainName(req.Name)

        normalizedReq := &amp;models.CreateDomainRequest{
                Name:        normalizedName,
                Description: req.Description,
        }

        domain, err := dm.domainService.CreateDomain(ctx, normalizedReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to create domain: %v", err))
        }</span>

        <span class="cov0" title="0">return dm.converter.DomainToMCPDomain(domain, 0), nil</span>
}

func (dm *DomainManager) GetDomain(ctx context.Context, domainName string) (*MCPDomain, error) <span class="cov0" title="0">{
        domain, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                nodeCount = 0
        }</span>

        <span class="cov0" title="0">return dm.converter.DomainToMCPDomain(domain, nodeCount), nil</span>
}

func (dm *DomainManager) UpdateDomain(ctx context.Context, domainName string, req *models.UpdateDomainRequest) (*MCPDomain, error) <span class="cov0" title="0">{
        domain, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">updatedDomain, err := dm.domainService.UpdateDomain(ctx, domain.ID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to update domain: %v", err))
        }</span>

        <span class="cov0" title="0">nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                nodeCount = 0
        }</span>

        <span class="cov0" title="0">return dm.converter.DomainToMCPDomain(updatedDomain, nodeCount), nil</span>
}

func (dm *DomainManager) DeleteDomain(ctx context.Context, domainName string) error <span class="cov0" title="0">{
        domain, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                return NewInternalServerError(fmt.Sprintf("failed to get node count: %v", err))
        }</span>

        <span class="cov0" title="0">if nodeCount &gt; 0 </span><span class="cov0" title="0">{
                return NewValidationError("도메인에 노드가 존재하므로 삭제할 수 없습니다")
        }</span>

        <span class="cov0" title="0">if err := dm.domainService.DeleteDomain(ctx, domain.ID); err != nil </span><span class="cov0" title="0">{
                return NewInternalServerError(fmt.Sprintf("failed to delete domain: %v", err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (dm *DomainManager) GetDomainStats(ctx context.Context, domainName string) (*DomainStats, error) <span class="cov0" title="0">{
        domain, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get node count: %v", err))
        }</span>

        <span class="cov0" title="0">return &amp;DomainStats{
                DomainName:  domain.Name,
                Description: domain.Description,
                NodeCount:   nodeCount,
                CreatedAt:   domain.CreatedAt,
                UpdatedAt:   domain.UpdatedAt,
        }, nil</span>
}

func (dm *DomainManager) validateDomainName(name string) error <span class="cov0" title="0">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름은 필수입니다")
        }</span>

        <span class="cov0" title="0">if len(name) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름은 50자를 초과할 수 없습니다")
        }</span>

        <span class="cov0" title="0">matched, err := regexp.MatchString(`^[a-zA-Z0-9-]+$`, name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름 검증 중 오류가 발생했습니다")
        }</span>

        <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름은 영문자, 숫자, 하이픈만 사용할 수 있습니다")
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(name, "-") || strings.HasSuffix(name, "-") </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름은 하이픈으로 시작하거나 끝날 수 없습니다")
        }</span>

        <span class="cov0" title="0">if strings.Contains(name, "--") </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름에 연속된 하이픈은 사용할 수 없습니다")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (dm *DomainManager) normalizeDomainName(name string) string <span class="cov0" title="0">{
        name = strings.ToLower(name)
        name = strings.TrimSpace(name)

        re := regexp.MustCompile(`[^a-z0-9-]`)
        name = re.ReplaceAllString(name, "-")

        re = regexp.MustCompile(`-+`)
        name = re.ReplaceAllString(name, "-")

        name = strings.Trim(name, "-")

        return name
}</span>

func (dm *DomainManager) CheckDomainExists(ctx context.Context, domainName string) (bool, error) <span class="cov0" title="0">{
        _, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (dm *DomainManager) GetDomainByPartialName(ctx context.Context, partialName string) ([]MCPDomain, error) <span class="cov0" title="0">{
        response, err := dm.domainService.ListDomains(ctx, 1, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list domains: %v", err))
        }</span>

        <span class="cov0" title="0">var matchedDomains []MCPDomain
        partialNameLower := strings.ToLower(partialName)

        for _, domain := range response.Domains </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(domain.Name), partialNameLower) ||
                        strings.Contains(strings.ToLower(domain.Description), partialNameLower) </span><span class="cov0" title="0">{

                        nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                nodeCount = 0
                        }</span>

                        <span class="cov0" title="0">mcpDomain := dm.converter.DomainToMCPDomain(&amp;domain, nodeCount)
                        if mcpDomain != nil </span><span class="cov0" title="0">{
                                matchedDomains = append(matchedDomains, *mcpDomain)
                        }</span>
                }
        }

        <span class="cov0" title="0">return matchedDomains, nil</span>
}

func (dm *DomainManager) GetPopularDomains(ctx context.Context, limit int) ([]MCPDomain, error) <span class="cov0" title="0">{
        response, err := dm.domainService.ListDomains(ctx, 1, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list domains: %v", err))
        }</span>

        <span class="cov0" title="0">type domainWithCount struct {
                domain    models.Domain
                nodeCount int
        }

        var domainsWithCounts []domainWithCount

        for _, domain := range response.Domains </span><span class="cov0" title="0">{
                nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
                if err != nil </span><span class="cov0" title="0">{
                        nodeCount = 0
                }</span>

                <span class="cov0" title="0">domainsWithCounts = append(domainsWithCounts, domainWithCount{
                        domain:    domain,
                        nodeCount: nodeCount,
                })</span>
        }

        <span class="cov0" title="0">for i := 0; i &lt; len(domainsWithCounts)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(domainsWithCounts); j++ </span><span class="cov0" title="0">{
                        if domainsWithCounts[i].nodeCount &lt; domainsWithCounts[j].nodeCount </span><span class="cov0" title="0">{
                                domainsWithCounts[i], domainsWithCounts[j] = domainsWithCounts[j], domainsWithCounts[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">if limit &gt; 0 &amp;&amp; limit &lt; len(domainsWithCounts) </span><span class="cov0" title="0">{
                domainsWithCounts = domainsWithCounts[:limit]
        }</span>

        <span class="cov0" title="0">var popularDomains []MCPDomain
        for _, dwc := range domainsWithCounts </span><span class="cov0" title="0">{
                mcpDomain := dm.converter.DomainToMCPDomain(&amp;dwc.domain, dwc.nodeCount)
                if mcpDomain != nil </span><span class="cov0" title="0">{
                        popularDomains = append(popularDomains, *mcpDomain)
                }</span>
        }

        <span class="cov0" title="0">return popularDomains, nil</span>
}

type DomainStats struct {
        DomainName  string    `json:"domain_name"`
        Description string    `json:"description"`
        NodeCount   int       `json:"node_count"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package mcp

import (
        "context"
        "fmt"

        "url-db/internal/models"
)

// Domain operation methods for mcpService

func (s *mcpService) ListDomains(ctx context.Context) (*MCPDomainListResponse, error) <span class="cov0" title="0">{
        response, err := s.domainService.ListDomains(ctx, 1, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list domains: %v", err))
        }</span>

        <span class="cov0" title="0">mcpDomains := make([]MCPDomain, 0, len(response.Domains))
        for _, domain := range response.Domains </span><span class="cov0" title="0">{
                nodeCount, err := s.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
                if err != nil </span><span class="cov0" title="0">{
                        nodeCount = 0
                }</span>

                <span class="cov0" title="0">mcpDomain := s.converter.DomainToMCPDomain(&amp;domain, nodeCount)
                if mcpDomain != nil </span><span class="cov0" title="0">{
                        mcpDomains = append(mcpDomains, *mcpDomain)
                }</span>
        }

        <span class="cov0" title="0">return &amp;MCPDomainListResponse{
                Domains: mcpDomains,
        }, nil</span>
}

func (s *mcpService) CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*MCPDomain, error) <span class="cov0" title="0">{
        domain, err := s.domainService.CreateDomain(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to create domain: %v", err))
        }</span>

        <span class="cov0" title="0">return s.converter.DomainToMCPDomain(domain, 0), nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package mcp

import (
        "errors"
        "fmt"
)

var (
        ErrInvalidCompositeKey = errors.New("invalid composite key format")
        ErrDomainNotFound      = errors.New("domain not found")
        ErrResourceNotFound    = errors.New("resource not found")
        ErrAccessDenied        = errors.New("access denied")
        ErrBatchPartialFailure = errors.New("batch partial failure")
)

type MCPError struct {
        Code     string      `json:"error"`
        Message  string      `json:"message"`
        Details  interface{} `json:"details,omitempty"`
        HTTPCode int         `json:"-"`
}

func (e MCPError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s: %s", e.Code, e.Message)
}</span>

func NewInvalidCompositeKeyError(provided string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "INVALID_COMPOSITE_KEY",
                Message:  "합성키 형식이 올바르지 않습니다",
                HTTPCode: 400,
                Details: map[string]interface{}{
                        "expected_format": "tool_name:domain_name:id",
                        "provided":        provided,
                },
        }
}</span>

func NewDomainNotFoundError(domainName string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "DOMAIN_NOT_FOUND",
                Message:  "지정된 도메인을 찾을 수 없습니다",
                HTTPCode: 404,
                Details: map[string]interface{}{
                        "domain_name": domainName,
                },
        }
}</span>

func NewResourceNotFoundError(compositeID string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "RESOURCE_NOT_FOUND",
                Message:  "리소스를 찾을 수 없습니다",
                HTTPCode: 404,
                Details: map[string]interface{}{
                        "composite_id": compositeID,
                },
        }
}</span>

func NewNodeNotFoundError(domainName, url string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "NODE_NOT_FOUND",
                Message:  "노드를 찾을 수 없습니다",
                HTTPCode: 404,
                Details: map[string]interface{}{
                        "domain_name": domainName,
                        "url":         url,
                },
        }
}</span>

func NewAccessDeniedError(resource string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "ACCESS_DENIED",
                Message:  "해당 리소스에 대한 접근 권한이 없습니다",
                HTTPCode: 403,
                Details: map[string]interface{}{
                        "resource": resource,
                },
        }
}</span>

func NewBatchPartialFailureError(failed []string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "BATCH_PARTIAL_FAILURE",
                Message:  "배치 처리 중 일부 항목에서 오류가 발생했습니다",
                HTTPCode: 207,
                Details: map[string]interface{}{
                        "failed_items": failed,
                },
        }
}</span>

func NewValidationError(message string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "VALIDATION_ERROR",
                Message:  message,
                HTTPCode: 400,
        }
}</span>

func NewInternalServerError(message string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "INTERNAL_SERVER_ERROR",
                Message:  message,
                HTTPCode: 500,
        }
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package mcp

import (
        "context"
        "fmt"
        "strconv"

        "url-db/internal/models"
)

// External Dependency Management Operations

// CreateSubscription creates a new subscription for node events
func (s *mcpService) CreateSubscription(ctx context.Context, req *MCPCreateSubscriptionRequest) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(req.CompositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        // Create subscription request
        <span class="cov0" title="0">subscriptionReq := &amp;models.CreateNodeSubscriptionRequest{
                SubscriberService:  req.SubscriberService,
                SubscriberEndpoint: req.SubscriberEndpoint,
                EventTypes:         req.EventTypes,
                FilterConditions:   req.FilterConditions,
        }

        return s.subscriptionService.CreateSubscription(nodeID, subscriptionReq)</span>
}

// ListSubscriptions lists subscriptions with optional service filter
func (s *mcpService) ListSubscriptions(ctx context.Context, serviceName string, page, size int) (*MCPSubscriptionListResponse, error) <span class="cov0" title="0">{
        var subscriptions []*models.NodeSubscription
        var total int
        var err error

        if serviceName != "" </span><span class="cov0" title="0">{
                subscriptions, err = s.subscriptionService.GetServiceSubscriptions(serviceName)
                total = len(subscriptions)

                // Apply pagination manually
                start := (page - 1) * size
                end := start + size
                if start &gt;= total </span><span class="cov0" title="0">{
                        subscriptions = []*models.NodeSubscription{}
                }</span> else<span class="cov0" title="0"> {
                        if end &gt; total </span><span class="cov0" title="0">{
                                end = total
                        }</span>
                        <span class="cov0" title="0">subscriptions = subscriptions[start:end]</span>
                }
        } else<span class="cov0" title="0"> {
                subscriptions, total, err = s.subscriptionService.GetAllSubscriptions(page, size)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;MCPSubscriptionListResponse{
                Subscriptions: subscriptions,
                Total:         total,
                Page:          page,
                Size:          size,
        }, nil</span>
}

// GetNodeSubscriptions gets all subscriptions for a specific node
func (s *mcpService) GetNodeSubscriptions(ctx context.Context, compositeID string) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        <span class="cov0" title="0">return s.subscriptionService.GetNodeSubscriptions(nodeID)</span>
}

// DeleteSubscription deletes a subscription
func (s *mcpService) DeleteSubscription(ctx context.Context, subscriptionID int64) error <span class="cov0" title="0">{
        return s.subscriptionService.DeleteSubscription(subscriptionID)
}</span>

// CreateDependency creates a new dependency relationship
func (s *mcpService) CreateDependency(ctx context.Context, req *MCPCreateDependencyRequest) (*models.NodeDependency, error) <span class="cov0" title="0">{
        // Parse dependent node composite ID
        _, _, dependentNodeIDStr, err := s.converter.ParseCompositeID(req.DependentNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid dependent node composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">dependentNodeID, err := strconv.ParseInt(dependentNodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid dependent node ID: %w", err)
        }</span>

        // Parse dependency node composite ID
        <span class="cov0" title="0">_, _, dependencyNodeIDStr, err := s.converter.ParseCompositeID(req.DependencyNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid dependency node composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">dependencyNodeID, err := strconv.ParseInt(dependencyNodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid dependency node ID: %w", err)
        }</span>

        // Create dependency request
        <span class="cov0" title="0">dependencyReq := &amp;models.CreateNodeDependencyRequest{
                DependencyNodeID: dependencyNodeID,
                DependencyType:   req.DependencyType,
                CascadeDelete:    req.CascadeDelete,
                CascadeUpdate:    req.CascadeUpdate,
                Metadata:         req.Metadata,
        }

        return s.dependencyService.CreateDependency(dependentNodeID, dependencyReq)</span>
}

// ListNodeDependencies gets all dependencies for a node
func (s *mcpService) ListNodeDependencies(ctx context.Context, compositeID string) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        <span class="cov0" title="0">return s.dependencyService.GetNodeDependencies(nodeID)</span>
}

// ListNodeDependents gets all nodes that depend on this node
func (s *mcpService) ListNodeDependents(ctx context.Context, compositeID string) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        <span class="cov0" title="0">return s.dependencyService.GetNodeDependents(nodeID)</span>
}

// DeleteDependency deletes a dependency relationship
func (s *mcpService) DeleteDependency(ctx context.Context, dependencyID int64) error <span class="cov0" title="0">{
        return s.dependencyService.DeleteDependency(dependencyID)
}</span>

// GetNodeEvents gets event history for a node
func (s *mcpService) GetNodeEvents(ctx context.Context, compositeID string, limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        <span class="cov0" title="0">return s.eventService.GetNodeEvents(nodeID, limit)</span>
}

// GetPendingEvents gets unprocessed events
func (s *mcpService) GetPendingEvents(ctx context.Context, limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        return s.eventService.GetPendingEvents(limit)
}</span>

// ProcessEvent marks an event as processed
func (s *mcpService) ProcessEvent(ctx context.Context, eventID int64) error <span class="cov0" title="0">{
        return s.eventService.ProcessEvent(eventID)
}</span>

// GetEventStats gets system event statistics
func (s *mcpService) GetEventStats(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        return s.eventService.GetEventStats()
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package mcp

import (
        "log"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type MCPHandler struct {
        mcpService       MCPService
        batchProcessor   *BatchProcessor
        domainManager    *DomainManager
        attributeManager *AttributeManager
        metadataManager  *MetadataManager
}

func NewMCPHandler(
        mcpService MCPService,
        batchProcessor *BatchProcessor,
        domainManager *DomainManager,
        attributeManager *AttributeManager,
        metadataManager *MetadataManager,
) *MCPHandler <span class="cov0" title="0">{
        return &amp;MCPHandler{
                mcpService:       mcpService,
                batchProcessor:   batchProcessor,
                domainManager:    domainManager,
                attributeManager: attributeManager,
                metadataManager:  metadataManager,
        }
}</span>

func (h *MCPHandler) CreateNode(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateMCPNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.CreateNode(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, node)</span>
}

func (h *MCPHandler) GetNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.GetNode(c.Request.Context(), compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *MCPHandler) UpdateNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.UpdateNode(c.Request.Context(), compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *MCPHandler) DeleteNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.mcpService.DeleteNode(c.Request.Context(), compositeID); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *MCPHandler) ListNodes(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Query("domain_name")
        search := c.Query("search")

        page, err := h.parseIntQuery(c, "page", 1)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">size, err := h.parseIntQuery(c, "size", 20)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if size &gt; 100 </span><span class="cov0" title="0">{
                size = 100
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.ListNodes(c.Request.Context(), domainName, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) FindNodeByURL(c *gin.Context) <span class="cov0" title="0">{
        var req models.FindMCPNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.FindNodeByURL(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *MCPHandler) BatchGetNodes(c *gin.Context) <span class="cov0" title="0">{
        var req models.BatchMCPNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(req.CompositeIDs) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.batchProcessor.BatchGetNodes(c.Request.Context(), req.CompositeIDs)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) ListDomains(c *gin.Context) <span class="cov0" title="0">{
        response, err := h.domainManager.ListDomains(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) CreateDomain(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateDomainRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.domainManager.CreateDomain(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, domain)</span>
}

func (h *MCPHandler) GetDomain(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("domain_name is required"))
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.domainManager.GetDomain(c.Request.Context(), domainName)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, domain)</span>
}

func (h *MCPHandler) UpdateDomain(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("domain_name is required"))
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateDomainRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.domainManager.UpdateDomain(c.Request.Context(), domainName, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, domain)</span>
}

func (h *MCPHandler) DeleteDomain(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("domain_name is required"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.domainManager.DeleteDomain(c.Request.Context(), domainName); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *MCPHandler) GetNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.GetNodeAttributes(c.Request.Context(), compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) SetNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">var req models.SetMCPNodeAttributesRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.SetNodeAttributes(c.Request.Context(), compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) AddNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">var req AddAttributeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.AddNodeAttribute(c.Request.Context(), compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) RemoveNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">attributeName := c.Param("attribute_name")
        if attributeName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("attribute_name is required"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.RemoveNodeAttribute(c.Request.Context(), compositeID, attributeName)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) GetServerInfo(c *gin.Context) <span class="cov0" title="0">{
        info, err := h.metadataManager.GetServerInfo(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, info)</span>
}

func (h *MCPHandler) GetDetailedServerInfo(c *gin.Context) <span class="cov0" title="0">{
        info, err := h.metadataManager.GetDetailedServerInfo(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, info)</span>
}

func (h *MCPHandler) GetHealthStatus(c *gin.Context) <span class="cov0" title="0">{
        status, err := h.metadataManager.GetHealthStatus(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, status)</span>
}

func (h *MCPHandler) GetStatistics(c *gin.Context) <span class="cov0" title="0">{
        stats, err := h.metadataManager.GetStatistics(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

func (h *MCPHandler) GetAPIDocumentation(c *gin.Context) <span class="cov0" title="0">{
        docs, err := h.metadataManager.GetAPIDocumentation(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, docs)</span>
}

func (h *MCPHandler) BatchCreateNodes(c *gin.Context) <span class="cov0" title="0">{
        var requests []models.CreateMCPNodeRequest
        if err := c.ShouldBindJSON(&amp;requests); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(requests) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.batchProcessor.BatchCreateNodes(c.Request.Context(), requests)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">statusCode := http.StatusCreated
        if len(response.Failed) &gt; 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusMultiStatus
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

func (h *MCPHandler) BatchUpdateNodes(c *gin.Context) <span class="cov0" title="0">{
        var requests []BatchUpdateRequest
        if err := c.ShouldBindJSON(&amp;requests); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(requests) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.batchProcessor.BatchUpdateNodes(c.Request.Context(), requests)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">statusCode := http.StatusOK
        if len(response.Failed) &gt; 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusMultiStatus
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

func (h *MCPHandler) BatchDeleteNodes(c *gin.Context) <span class="cov0" title="0">{
        var req BatchDeleteRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(req.CompositeIDs) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.batchProcessor.BatchDeleteNodes(c.Request.Context(), req.CompositeIDs)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">statusCode := http.StatusOK
        if len(response.Failed) &gt; 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusMultiStatus
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

func (h *MCPHandler) BatchSetNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        var requests []BatchAttributeRequest
        if err := c.ShouldBindJSON(&amp;requests); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(requests) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.BatchSetNodeAttributes(c.Request.Context(), requests)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">statusCode := http.StatusOK
        if len(response.Failed) &gt; 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusMultiStatus
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

func (h *MCPHandler) SearchDomains(c *gin.Context) <span class="cov0" title="0">{
        query := c.Query("q")
        if query == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("query parameter 'q' is required"))
                return
        }</span>

        <span class="cov0" title="0">domains, err := h.domainManager.GetDomainByPartialName(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, MCPDomainListResponse{
                Domains: domains,
        })</span>
}

func (h *MCPHandler) GetPopularDomains(c *gin.Context) <span class="cov0" title="0">{
        limit, err := h.parseIntQuery(c, "limit", 10)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">domains, err := h.domainManager.GetPopularDomains(c.Request.Context(), limit)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, MCPDomainListResponse{
                Domains: domains,
        })</span>
}

func (h *MCPHandler) GetDomainStats(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("domain_name is required"))
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.domainManager.GetDomainStats(c.Request.Context(), domainName)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

func (h *MCPHandler) parseIntQuery(c *gin.Context, key string, defaultValue int) (int, error) <span class="cov0" title="0">{
        valueStr := c.Query(key)
        if valueStr == "" </span><span class="cov0" title="0">{
                return defaultValue, nil
        }</span>

        <span class="cov0" title="0">value, err := strconv.Atoi(valueStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return value, nil</span>
}

func (h *MCPHandler) handleError(c *gin.Context, err error) <span class="cov0" title="0">{
        if mcpErr, ok := err.(*MCPError); ok </span><span class="cov0" title="0">{
                c.JSON(mcpErr.HTTPCode, mcpErr)
                return
        }</span>

        <span class="cov0" title="0">internalErr := NewInternalServerError(err.Error())
        c.JSON(internalErr.HTTPCode, internalErr)</span>
}

func (h *MCPHandler) RegisterRoutes(r *gin.RouterGroup) <span class="cov0" title="0">{
        api := r.Group("/mcp")
        </span><span class="cov0" title="0">{
                nodes := api.Group("/nodes")
                </span><span class="cov0" title="0">{
                        nodes.GET("", h.ListNodes)
                        nodes.POST("", h.CreateNode)
                        nodes.POST("/find", h.FindNodeByURL)
                        nodes.POST("/batch", h.BatchGetNodes)
                        nodes.POST("/batch/create", h.BatchCreateNodes)
                        nodes.PUT("/batch/update", h.BatchUpdateNodes)
                        nodes.DELETE("/batch/delete", h.BatchDeleteNodes)
                        nodes.GET("/:composite_id", h.GetNode)
                        nodes.PUT("/:composite_id", h.UpdateNode)
                        nodes.DELETE("/:composite_id", h.DeleteNode)

                        nodes.GET("/:composite_id/attributes", h.GetNodeAttributes)
                        nodes.PUT("/:composite_id/attributes", h.SetNodeAttributes)
                        nodes.POST("/:composite_id/attributes", h.AddNodeAttribute)
                        nodes.DELETE("/:composite_id/attributes/:attribute_name", h.RemoveNodeAttribute)
                        nodes.PUT("/attributes/batch", h.BatchSetNodeAttributes)
                }</span>

                <span class="cov0" title="0">domains := api.Group("/domains")
                </span><span class="cov0" title="0">{
                        domains.GET("", h.ListDomains)
                        domains.POST("", h.CreateDomain)
                        domains.GET("/search", h.SearchDomains)
                        domains.GET("/popular", h.GetPopularDomains)
                        domains.GET("/:domain_name", h.GetDomain)
                        domains.PUT("/:domain_name", h.UpdateDomain)
                        domains.DELETE("/:domain_name", h.DeleteDomain)
                        domains.GET("/:domain_name/stats", h.GetDomainStats)
                }</span>

                <span class="cov0" title="0">server := api.Group("/server")
                </span><span class="cov0" title="0">{
                        server.GET("/info", h.GetServerInfo)
                        server.GET("/info/detailed", h.GetDetailedServerInfo)
                        server.GET("/health", h.GetHealthStatus)
                        server.GET("/stats", h.GetStatistics)
                        server.GET("/docs", h.GetAPIDocumentation)
                }</span>
        }
}

func (h *MCPHandler) corsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func (h *MCPHandler) loggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery

                c.Next()

                latency := time.Since(start)
                clientIP := c.ClientIP()
                method := c.Request.Method
                statusCode := c.Writer.Status()

                if raw != "" </span><span class="cov0" title="0">{
                        path = path + "?" + raw
                }</span>

                <span class="cov0" title="0">log.Printf("[%s] %s %s %d %v",
                        clientIP,
                        method,
                        path,
                        statusCode,
                        latency,
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package mcp

import (
        "encoding/json"
        "fmt"
)

// JSON-RPC 2.0 프로토콜 구조체 정의

// JSONRPCRequest represents a JSON-RPC 2.0 request
type JSONRPCRequest struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id,omitempty"`
        Method  string      `json:"method"`
        Params  interface{} `json:"params,omitempty"`
}

// JSONRPCResponse represents a JSON-RPC 2.0 response
type JSONRPCResponse struct {
        JSONRPC string        `json:"jsonrpc"`
        ID      interface{}   `json:"id,omitempty"`
        Result  interface{}   `json:"result,omitempty"`
        Error   *JSONRPCError `json:"error,omitempty"`
}

// JSONRPCError represents a JSON-RPC 2.0 error
type JSONRPCError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// JSON-RPC 2.0 error codes
const (
        ParseError     = -32700
        InvalidRequest = -32600
        MethodNotFound = -32601
        InvalidParams  = -32602
        InternalError  = -32603
)

// MCP Protocol Structures

// InitializeRequest represents the MCP initialize request
type InitializeRequest struct {
        ProtocolVersion string             `json:"protocolVersion"`
        Capabilities    ClientCapabilities `json:"capabilities"`
        ClientInfo      ClientInfo         `json:"clientInfo"`
}

// ClientCapabilities represents client capabilities
type ClientCapabilities struct {
        Experimental map[string]interface{} `json:"experimental,omitempty"`
        Sampling     map[string]interface{} `json:"sampling,omitempty"`
}

// ClientInfo represents client information
type ClientInfo struct {
        Name    string `json:"name"`
        Version string `json:"version"`
}

// InitializeResult represents the MCP initialize response
type InitializeResult struct {
        ProtocolVersion string             `json:"protocolVersion"`
        Capabilities    ServerCapabilities `json:"capabilities"`
        ServerInfo      ServerInfo         `json:"serverInfo"`
}

// ServerCapabilities represents server capabilities
type ServerCapabilities struct {
        Experimental map[string]interface{} `json:"experimental,omitempty"`
        Logging      map[string]interface{} `json:"logging,omitempty"`
        Prompts      *PromptsCapability     `json:"prompts,omitempty"`
        Resources    *ResourcesCapability   `json:"resources,omitempty"`
        Tools        *ToolsCapability       `json:"tools,omitempty"`
}

// PromptsCapability represents prompts capability
type PromptsCapability struct {
        ListChanged bool `json:"listChanged,omitempty"`
}

// ResourcesCapability represents resources capability
type ResourcesCapability struct {
        Subscribe   bool `json:"subscribe,omitempty"`
        ListChanged bool `json:"listChanged,omitempty"`
}

// ToolsCapability represents tools capability
type ToolsCapability struct {
        ListChanged bool `json:"listChanged,omitempty"`
}

// ServerInfo represents server information
type ServerInfo struct {
        Name    string `json:"name"`
        Version string `json:"version"`
}

// Tool represents an MCP tool
type Tool struct {
        Name        string      `json:"name"`
        Description string      `json:"description"`
        InputSchema interface{} `json:"inputSchema"`
}

// ToolsListResult represents the tools/list response
type ToolsListResult struct {
        Tools []Tool `json:"tools"`
}

// CallToolRequest represents a tools/call request
type CallToolRequest struct {
        Name      string      `json:"name"`
        Arguments interface{} `json:"arguments,omitempty"`
}

// CallToolResult represents a tools/call response
type CallToolResult struct {
        Content []Content `json:"content"`
        IsError bool      `json:"isError,omitempty"`
}

// Content represents tool result content
type Content struct {
        Type string `json:"type"`
        Text string `json:"text,omitempty"`
}

// Resource represents an MCP resource
type Resource struct {
        URI         string `json:"uri"`
        Name        string `json:"name"`
        Description string `json:"description,omitempty"`
        MimeType    string `json:"mimeType,omitempty"`
}

// ResourcesListResult represents the resources/list response
type ResourcesListResult struct {
        Resources []Resource `json:"resources"`
}

// ReadResourceRequest represents a resources/read request
type ReadResourceRequest struct {
        URI string `json:"uri"`
}

// ReadResourceResult represents a resources/read response
type ReadResourceResult struct {
        Contents []ResourceContent `json:"contents"`
}

// ResourceContent represents resource content
type ResourceContent struct {
        URI      string `json:"uri"`
        MimeType string `json:"mimeType,omitempty"`
        Text     string `json:"text,omitempty"`
        Blob     string `json:"blob,omitempty"`
}

// Helper functions

// NewJSONRPCRequest creates a new JSON-RPC request
func NewJSONRPCRequest(id interface{}, method string, params interface{}) *JSONRPCRequest <span class="cov8" title="1">{
        return &amp;JSONRPCRequest{
                JSONRPC: "2.0",
                ID:      id,
                Method:  method,
                Params:  params,
        }
}</span>

// NewJSONRPCResponse creates a new JSON-RPC response
func NewJSONRPCResponse(id interface{}, result interface{}) *JSONRPCResponse <span class="cov8" title="1">{
        return &amp;JSONRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Result:  result,
        }
}</span>

// NewJSONRPCError creates a new JSON-RPC error response
func NewJSONRPCError(id interface{}, code int, message string, data interface{}) *JSONRPCResponse <span class="cov8" title="1">{
        return &amp;JSONRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error: &amp;JSONRPCError{
                        Code:    code,
                        Message: message,
                        Data:    data,
                },
        }
}</span>

// ParseJSONRPCRequest parses a JSON-RPC request from bytes
func ParseJSONRPCRequest(data []byte) (*JSONRPCRequest, error) <span class="cov8" title="1">{
        var req JSONRPCRequest
        if err := json.Unmarshal(data, &amp;req); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JSON-RPC request: %w", err)
        }</span>

        <span class="cov8" title="1">if req.JSONRPC != "2.0" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid JSON-RPC version: %s", req.JSONRPC)
        }</span>

        <span class="cov8" title="1">return &amp;req, nil</span>
}

// ToJSON converts a JSON-RPC response to JSON bytes
func (r *JSONRPCResponse) ToJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(r)
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package mcp

import (
        "context"
        "runtime"
        "time"
)

type MetadataManager struct {
        version     string
        buildTime   string
        gitCommit   string
        environment string
}

func NewMetadataManager(version, buildTime, gitCommit, environment string) *MetadataManager <span class="cov0" title="0">{
        if version == "" </span><span class="cov0" title="0">{
                version = "1.0.0"
        }</span>
        <span class="cov0" title="0">if buildTime == "" </span><span class="cov0" title="0">{
                buildTime = time.Now().Format(time.RFC3339)
        }</span>
        <span class="cov0" title="0">if gitCommit == "" </span><span class="cov0" title="0">{
                gitCommit = "unknown"
        }</span>
        <span class="cov0" title="0">if environment == "" </span><span class="cov0" title="0">{
                environment = "development"
        }</span>

        <span class="cov0" title="0">return &amp;MetadataManager{
                version:     version,
                buildTime:   buildTime,
                gitCommit:   gitCommit,
                environment: environment,
        }</span>
}

func (mm *MetadataManager) GetServerInfo(ctx context.Context) (*MCPServerInfo, error) <span class="cov0" title="0">{
        return &amp;MCPServerInfo{
                Name:        "url-db",
                Version:     mm.version,
                Description: "URL 데이터베이스 MCP 서버",
                Capabilities: []string{
                        "resources",
                        "tools",
                        "prompts",
                        "sampling",
                },
                CompositeKeyFormat: "url-db:domain_name:id",
        }, nil
}</span>

func (mm *MetadataManager) GetDetailedServerInfo(ctx context.Context) (*DetailedServerInfo, error) <span class="cov0" title="0">{
        return &amp;DetailedServerInfo{
                Name:               "url-db",
                Version:            mm.version,
                Description:        "URL 데이터베이스 MCP 서버",
                BuildTime:          mm.buildTime,
                GitCommit:          mm.gitCommit,
                Environment:        mm.environment,
                GoVersion:          runtime.Version(),
                Platform:           runtime.GOOS + "/" + runtime.GOARCH,
                CompositeKeyFormat: "url-db:domain_name:id",
                Capabilities: []string{
                        "resources",
                        "tools",
                        "prompts",
                        "sampling",
                },
                SupportedOperations: []string{
                        "create_node",
                        "get_node",
                        "update_node",
                        "delete_node",
                        "list_nodes",
                        "find_node_by_url",
                        "batch_get_nodes",
                        "list_domains",
                        "create_domain",
                        "get_node_attributes",
                        "set_node_attributes",
                },
                Limits: ServerLimits{
                        MaxBatchSize:            100,
                        MaxPageSize:             100,
                        MaxURLLength:            2048,
                        MaxTitleLength:          255,
                        MaxDescriptionLength:    1000,
                        MaxDomainNameLength:     50,
                        MaxAttributeValueLength: 2048,
                },
        }, nil
}</span>

func (mm *MetadataManager) GetHealthStatus(ctx context.Context) (*HealthStatus, error) <span class="cov0" title="0">{
        return &amp;HealthStatus{
                Status:    "healthy",
                Timestamp: time.Now(),
                Version:   mm.version,
                Uptime:    time.Since(getStartTime()).String(),
                Checks: map[string]HealthCheck{
                        "database": {
                                Status:  "healthy",
                                Message: "Database connection is healthy",
                        },
                        "memory": {
                                Status:  "healthy",
                                Message: "Memory usage is within normal limits",
                        },
                        "goroutines": {
                                Status:  "healthy",
                                Message: "Goroutine count is normal",
                        },
                },
        }, nil
}</span>

func (mm *MetadataManager) GetAPIDocumentation(ctx context.Context) (*APIDocumentation, error) <span class="cov0" title="0">{
        return &amp;APIDocumentation{
                OpenAPI: "3.0.0",
                Info: APIInfo{
                        Title:       "URL Database MCP API",
                        Description: "MCP (Model Context Protocol) API for URL Database",
                        Version:     mm.version,
                        Contact: APIContact{
                                Name:  "URL Database Team",
                                Email: "support@url-db.com",
                        },
                },
                Servers: []APIServer{
                        {
                                URL:         "/api/mcp",
                                Description: "MCP API Server",
                        },
                },
                Paths: map[string]APIPath{
                        "/nodes": {
                                GET: &amp;APIOperation{
                                        Summary:     "List nodes",
                                        Description: "Get a list of nodes with optional filtering",
                                        Parameters: []APIParameter{
                                                {
                                                        Name:        "domain_name",
                                                        In:          "query",
                                                        Description: "Filter by domain name",
                                                        Required:    false,
                                                        Schema:      APISchema{Type: "string"},
                                                },
                                                {
                                                        Name:        "page",
                                                        In:          "query",
                                                        Description: "Page number",
                                                        Required:    false,
                                                        Schema:      APISchema{Type: "integer", Default: 1},
                                                },
                                                {
                                                        Name:        "size",
                                                        In:          "query",
                                                        Description: "Page size",
                                                        Required:    false,
                                                        Schema:      APISchema{Type: "integer", Default: 20},
                                                },
                                        },
                                },
                                POST: &amp;APIOperation{
                                        Summary:     "Create node",
                                        Description: "Create a new node",
                                        RequestBody: &amp;APIRequestBody{
                                                Description: "Node creation request",
                                                Content: map[string]APIMediaType{
                                                        "application/json": {
                                                                Schema: APISchema{
                                                                        Type: "object",
                                                                        Properties: map[string]APISchema{
                                                                                "domain_name": {Type: "string", Description: "Domain name"},
                                                                                "url":         {Type: "string", Description: "URL"},
                                                                                "title":       {Type: "string", Description: "Title"},
                                                                                "description": {Type: "string", Description: "Description"},
                                                                        },
                                                                        Required: []string{"domain_name", "url"},
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "/nodes/{composite_id}": {
                                GET: &amp;APIOperation{
                                        Summary:     "Get node",
                                        Description: "Get a node by composite ID",
                                        Parameters: []APIParameter{
                                                {
                                                        Name:        "composite_id",
                                                        In:          "path",
                                                        Description: "Composite ID in format 'url-db:domain_name:id'",
                                                        Required:    true,
                                                        Schema:      APISchema{Type: "string"},
                                                },
                                        },
                                },
                                PUT: &amp;APIOperation{
                                        Summary:     "Update node",
                                        Description: "Update a node by composite ID",
                                        Parameters: []APIParameter{
                                                {
                                                        Name:        "composite_id",
                                                        In:          "path",
                                                        Description: "Composite ID in format 'url-db:domain_name:id'",
                                                        Required:    true,
                                                        Schema:      APISchema{Type: "string"},
                                                },
                                        },
                                },
                                DELETE: &amp;APIOperation{
                                        Summary:     "Delete node",
                                        Description: "Delete a node by composite ID",
                                        Parameters: []APIParameter{
                                                {
                                                        Name:        "composite_id",
                                                        In:          "path",
                                                        Description: "Composite ID in format 'url-db:domain_name:id'",
                                                        Required:    true,
                                                        Schema:      APISchema{Type: "string"},
                                                },
                                        },
                                },
                        },
                },
        }, nil
}</span>

func (mm *MetadataManager) GetStatistics(ctx context.Context) (*ServerStatistics, error) <span class="cov0" title="0">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        return &amp;ServerStatistics{
                Version:   mm.version,
                Uptime:    time.Since(getStartTime()).String(),
                Timestamp: time.Now(),
                Runtime: RuntimeStats{
                        GoVersion:    runtime.Version(),
                        NumGoroutine: runtime.NumGoroutine(),
                        NumCPU:       runtime.NumCPU(),
                        MemoryStats: MemoryStats{
                                Alloc:        memStats.Alloc,
                                TotalAlloc:   memStats.TotalAlloc,
                                Sys:          memStats.Sys,
                                NumGC:        memStats.NumGC,
                                HeapAlloc:    memStats.HeapAlloc,
                                HeapSys:      memStats.HeapSys,
                                HeapInuse:    memStats.HeapInuse,
                                HeapReleased: memStats.HeapReleased,
                        },
                },
        }, nil
}</span>

var startTime = time.Now()

func getStartTime() time.Time <span class="cov0" title="0">{
        return startTime
}</span>

type DetailedServerInfo struct {
        Name                string       `json:"name"`
        Version             string       `json:"version"`
        Description         string       `json:"description"`
        BuildTime           string       `json:"build_time"`
        GitCommit           string       `json:"git_commit"`
        Environment         string       `json:"environment"`
        GoVersion           string       `json:"go_version"`
        Platform            string       `json:"platform"`
        CompositeKeyFormat  string       `json:"composite_key_format"`
        Capabilities        []string     `json:"capabilities"`
        SupportedOperations []string     `json:"supported_operations"`
        Limits              ServerLimits `json:"limits"`
}

type ServerLimits struct {
        MaxBatchSize            int `json:"max_batch_size"`
        MaxPageSize             int `json:"max_page_size"`
        MaxURLLength            int `json:"max_url_length"`
        MaxTitleLength          int `json:"max_title_length"`
        MaxDescriptionLength    int `json:"max_description_length"`
        MaxDomainNameLength     int `json:"max_domain_name_length"`
        MaxAttributeValueLength int `json:"max_attribute_value_length"`
}

type HealthStatus struct {
        Status    string                 `json:"status"`
        Timestamp time.Time              `json:"timestamp"`
        Version   string                 `json:"version"`
        Uptime    string                 `json:"uptime"`
        Checks    map[string]HealthCheck `json:"checks"`
}

type HealthCheck struct {
        Status  string `json:"status"`
        Message string `json:"message"`
}

type APIDocumentation struct {
        OpenAPI string             `json:"openapi"`
        Info    APIInfo            `json:"info"`
        Servers []APIServer        `json:"servers"`
        Paths   map[string]APIPath `json:"paths"`
}

type APIInfo struct {
        Title       string     `json:"title"`
        Description string     `json:"description"`
        Version     string     `json:"version"`
        Contact     APIContact `json:"contact"`
}

type APIContact struct {
        Name  string `json:"name"`
        Email string `json:"email"`
}

type APIServer struct {
        URL         string `json:"url"`
        Description string `json:"description"`
}

type APIPath struct {
        GET    *APIOperation `json:"get,omitempty"`
        POST   *APIOperation `json:"post,omitempty"`
        PUT    *APIOperation `json:"put,omitempty"`
        DELETE *APIOperation `json:"delete,omitempty"`
}

type APIOperation struct {
        Summary     string          `json:"summary"`
        Description string          `json:"description"`
        Parameters  []APIParameter  `json:"parameters,omitempty"`
        RequestBody *APIRequestBody `json:"requestBody,omitempty"`
}

type APIParameter struct {
        Name        string    `json:"name"`
        In          string    `json:"in"`
        Description string    `json:"description"`
        Required    bool      `json:"required"`
        Schema      APISchema `json:"schema"`
}

type APIRequestBody struct {
        Description string                  `json:"description"`
        Content     map[string]APIMediaType `json:"content"`
}

type APIMediaType struct {
        Schema APISchema `json:"schema"`
}

type APISchema struct {
        Type        string               `json:"type"`
        Properties  map[string]APISchema `json:"properties,omitempty"`
        Required    []string             `json:"required,omitempty"`
        Description string               `json:"description,omitempty"`
        Default     interface{}          `json:"default,omitempty"`
}

type ServerStatistics struct {
        Version   string       `json:"version"`
        Uptime    string       `json:"uptime"`
        Timestamp time.Time    `json:"timestamp"`
        Runtime   RuntimeStats `json:"runtime"`
}

type RuntimeStats struct {
        GoVersion    string      `json:"go_version"`
        NumGoroutine int         `json:"num_goroutine"`
        NumCPU       int         `json:"num_cpu"`
        MemoryStats  MemoryStats `json:"memory_stats"`
}

type MemoryStats struct {
        Alloc        uint64 `json:"alloc"`
        TotalAlloc   uint64 `json:"total_alloc"`
        Sys          uint64 `json:"sys"`
        NumGC        uint32 `json:"num_gc"`
        HeapAlloc    uint64 `json:"heap_alloc"`
        HeapSys      uint64 `json:"heap_sys"`
        HeapInuse    uint64 `json:"heap_inuse"`
        HeapReleased uint64 `json:"heap_released"`
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package mcp

import (
        "context"
        "fmt"

        "url-db/internal/models"
)

// Node operation methods for mcpService

func (s *mcpService) CreateNode(ctx context.Context, req *models.CreateMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        domain, err := s.domainService.GetDomainByName(ctx, req.DomainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(req.DomainName)
        }</span>

        <span class="cov0" title="0">nodeReq := s.converter.CreateMCPNodeRequestToCreateNodeRequest(req)
        node, err := s.nodeService.CreateNode(ctx, domain.ID, nodeReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to create node: %v", err))
        }</span>

        <span class="cov0" title="0">return s.converter.NodeToMCPNode(node, domain)</span>
}

func (s *mcpService) GetNode(ctx context.Context, compositeID string) (*models.MCPNode, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := s.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">node, err := s.nodeService.GetNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewResourceNotFoundError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">return s.converter.NodeToMCPNode(node, domain)</span>
}

func (s *mcpService) UpdateNode(ctx context.Context, compositeID string, req *models.UpdateNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := s.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">node, err := s.nodeService.UpdateNode(ctx, nodeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to update node: %v", err))
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">return s.converter.NodeToMCPNode(node, domain)</span>
}

func (s *mcpService) DeleteNode(ctx context.Context, compositeID string) error <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">if err := s.nodeService.DeleteNode(ctx, nodeID); err != nil </span><span class="cov0" title="0">{
                return NewInternalServerError(fmt.Sprintf("failed to delete node: %v", err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *mcpService) ListNodes(ctx context.Context, domainName string, page, size int, search string) (*models.MCPNodeListResponse, error) <span class="cov0" title="0">{
        var domainID int
        var domain *models.Domain
        var err error

        if domainName != "" </span><span class="cov0" title="0">{
                domain, err = s.domainService.GetDomainByName(ctx, domainName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainName)
                }</span>
                <span class="cov0" title="0">domainID = domain.ID</span>
        }

        <span class="cov0" title="0">response, err := s.nodeService.ListNodes(ctx, domainID, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list nodes: %v", err))
        }</span>

        <span class="cov0" title="0">mcpNodes := make([]models.MCPNode, 0, len(response.Nodes))
        for _, node := range response.Nodes </span><span class="cov0" title="0">{
                if domain == nil </span><span class="cov0" title="0">{
                        domain, err = s.domainService.GetDomain(ctx, node.DomainID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">mcpNode, err := s.converter.NodeToMCPNode(&amp;node, domain)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">mcpNodes = append(mcpNodes, *mcpNode)</span>
        }

        <span class="cov0" title="0">return &amp;models.MCPNodeListResponse{
                Nodes:      mcpNodes,
                TotalCount: response.TotalCount,
                Page:       response.Page,
                Size:       response.Size,
                TotalPages: response.TotalPages,
        }, nil</span>
}

func (s *mcpService) FindNodeByURL(ctx context.Context, req *models.FindMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        domain, err := s.domainService.GetDomainByName(ctx, req.DomainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(req.DomainName)
        }</span>

        <span class="cov0" title="0">findReq := &amp;models.FindNodeByURLRequest{URL: req.URL}
        node, err := s.nodeService.FindNodeByURL(ctx, domain.ID, findReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewNodeNotFoundError(req.DomainName, req.URL)
        }</span>

        <span class="cov0" title="0">return s.converter.NodeToMCPNode(node, domain)</span>
}

func (s *mcpService) BatchGetNodes(ctx context.Context, req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error) <span class="cov0" title="0">{
        nodes := make([]models.MCPNode, 0, len(req.CompositeIDs))
        notFound := make([]string, 0)

        for _, compositeID := range req.CompositeIDs </span><span class="cov0" title="0">{
                node, err := s.GetNode(ctx, compositeID)
                if err != nil </span><span class="cov0" title="0">{
                        notFound = append(notFound, compositeID)
                        continue</span>
                }
                <span class="cov0" title="0">nodes = append(nodes, *node)</span>
        }

        <span class="cov0" title="0">return &amp;models.BatchMCPNodeResponse{
                Nodes:    nodes,
                NotFound: notFound,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package mcp

import (
        "context"
        "fmt"
        "strings"

        "url-db/internal/models"
)

// Query operation methods for mcpService - enhanced query capabilities

func (s *mcpService) FilterNodesByAttributes(ctx context.Context, domainName string, filters []interface{}, page, size int) (*models.MCPNodeListResponse, error) <span class="cov0" title="0">{
        // Get domain
        domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        // Get all nodes in the domain first
        <span class="cov0" title="0">response, err := s.nodeService.ListNodes(ctx, domain.ID, 1, 1000, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list nodes: %v", err))
        }</span>

        // Filter nodes based on attributes
        <span class="cov0" title="0">var filteredNodes []models.MCPNode
        for _, node := range response.Nodes </span><span class="cov0" title="0">{
                // Get node attributes
                nodeAttrs, err := s.attributeService.GetNodeAttributes(ctx, node.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if node matches all filters
                <span class="cov0" title="0">matches := true
                for _, filterInterface := range filters </span><span class="cov0" title="0">{
                        filterMap, ok := filterInterface.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                // Try struct conversion
                                filterStruct, ok := filterInterface.(struct {
                                        Name     string `json:"name"`
                                        Value    string `json:"value"`
                                        Operator string `json:"operator"`
                                })
                                if ok </span><span class="cov0" title="0">{
                                        filterMap = map[string]interface{}{
                                                "name":     filterStruct.Name,
                                                "value":    filterStruct.Value,
                                                "operator": filterStruct.Operator,
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        continue</span>
                                }
                        }

                        <span class="cov0" title="0">filterName, _ := filterMap["name"].(string)
                        filterValue, _ := filterMap["value"].(string)
                        filterOperator, _ := filterMap["operator"].(string)

                        if filterName == "" || filterValue == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check if node has this attribute with matching value
                        <span class="cov0" title="0">attrFound := false
                        for _, attr := range nodeAttrs </span><span class="cov0" title="0">{
                                if attr.Name == filterName </span><span class="cov0" title="0">{
                                        switch filterOperator </span>{
                                        case "equals":<span class="cov0" title="0">
                                                if attr.Value == filterValue </span><span class="cov0" title="0">{
                                                        attrFound = true
                                                }</span>
                                        case "contains":<span class="cov0" title="0">
                                                if strings.Contains(attr.Value, filterValue) </span><span class="cov0" title="0">{
                                                        attrFound = true
                                                }</span>
                                        case "starts_with":<span class="cov0" title="0">
                                                if strings.HasPrefix(attr.Value, filterValue) </span><span class="cov0" title="0">{
                                                        attrFound = true
                                                }</span>
                                        case "ends_with":<span class="cov0" title="0">
                                                if strings.HasSuffix(attr.Value, filterValue) </span><span class="cov0" title="0">{
                                                        attrFound = true
                                                }</span>
                                        }
                                        <span class="cov0" title="0">break</span>
                                }
                        }

                        <span class="cov0" title="0">if !attrFound </span><span class="cov0" title="0">{
                                matches = false
                                break</span>
                        }
                }

                <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
                        mcpNode, err := s.converter.NodeToMCPNode(&amp;node, domain)
                        if err == nil </span><span class="cov0" title="0">{
                                filteredNodes = append(filteredNodes, *mcpNode)
                        }</span>
                }
        }

        // Apply pagination
        <span class="cov0" title="0">start := (page - 1) * size
        end := start + size
        if start &gt; len(filteredNodes) </span><span class="cov0" title="0">{
                start = len(filteredNodes)
        }</span>
        <span class="cov0" title="0">if end &gt; len(filteredNodes) </span><span class="cov0" title="0">{
                end = len(filteredNodes)
        }</span>

        <span class="cov0" title="0">paginatedNodes := filteredNodes[start:end]

        return &amp;models.MCPNodeListResponse{
                Nodes:      paginatedNodes,
                TotalCount: len(filteredNodes),
                Page:       page,
                Size:       size,
                TotalPages: (len(filteredNodes) + size - 1) / size,
        }, nil</span>
}

func (s *mcpService) GetServerInfo(ctx context.Context) (*MCPServerInfo, error) <span class="cov0" title="0">{
        return &amp;MCPServerInfo{
                Name:        "url-db",
                Version:     "1.0.0",
                Description: "URL 데이터베이스 MCP 서버",
                Capabilities: []string{
                        "resources",
                        "tools",
                        "prompts",
                },
                CompositeKeyFormat: "url-db:domain_name:id",
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package mcp

import (
        "context"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

// MCP Resource 정의 및 구현

// ResourceRegistry manages all available MCP resources
type ResourceRegistry struct {
        service MCPService
}

// NewResourceRegistry creates a new resource registry
func NewResourceRegistry(service MCPService) *ResourceRegistry <span class="cov8" title="1">{
        return &amp;ResourceRegistry{
                service: service,
        }
}</span>

// GetResources returns all available resources
func (rr *ResourceRegistry) GetResources(ctx context.Context) (*ResourcesListResult, error) <span class="cov8" title="1">{
        // Get all domains to generate resource URIs
        domainsResponse, err := rr.service.ListDomains(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list domains: %w", err)
        }</span>

        <span class="cov8" title="1">var resources []Resource

        // Add server info resource
        resources = append(resources, Resource{
                URI:         "mcp://server/info",
                Name:        "Server Information",
                Description: "URL Database server information and capabilities",
                MimeType:    "application/json",
        })

        // Add domain resources
        for _, domain := range domainsResponse.Domains </span><span class="cov8" title="1">{
                // Domain resource
                resources = append(resources, Resource{
                        URI:         fmt.Sprintf("mcp://domains/%s", domain.Name),
                        Name:        fmt.Sprintf("Domain: %s", domain.Name),
                        Description: fmt.Sprintf("Domain information for %s", domain.Name),
                        MimeType:    "application/json",
                })

                // Domain nodes resource
                resources = append(resources, Resource{
                        URI:         fmt.Sprintf("mcp://domains/%s/nodes", domain.Name),
                        Name:        fmt.Sprintf("Nodes in %s", domain.Name),
                        Description: fmt.Sprintf("List of all nodes in domain %s", domain.Name),
                        MimeType:    "application/json",
                })
        }</span>

        <span class="cov8" title="1">return &amp;ResourcesListResult{
                Resources: resources,
        }, nil</span>
}

// ReadResource reads a specific resource by URI
func (rr *ResourceRegistry) ReadResource(ctx context.Context, uri string) (*ReadResourceResult, error) <span class="cov8" title="1">{
        // Parse the URI to determine resource type
        if uri == "mcp://server/info" </span><span class="cov8" title="1">{
                return rr.readServerInfo(ctx)
        }</span>

        // Match domain resource pattern: mcp://domains/{domain_name}
        <span class="cov8" title="1">domainPattern := regexp.MustCompile(`^mcp://domains/([^/]+)$`)
        if matches := domainPattern.FindStringSubmatch(uri); len(matches) == 2 </span><span class="cov8" title="1">{
                domainName := matches[1]
                return rr.readDomainInfo(ctx, domainName)
        }</span>

        // Match domain nodes pattern: mcp://domains/{domain_name}/nodes
        <span class="cov8" title="1">domainNodesPattern := regexp.MustCompile(`^mcp://domains/([^/]+)/nodes$`)
        if matches := domainNodesPattern.FindStringSubmatch(uri); len(matches) == 2 </span><span class="cov8" title="1">{
                domainName := matches[1]
                return rr.readDomainNodes(ctx, domainName)
        }</span>

        // Match individual node pattern: mcp://nodes/{composite_id}
        <span class="cov8" title="1">nodePattern := regexp.MustCompile(`^mcp://nodes/(.+)$`)
        if matches := nodePattern.FindStringSubmatch(uri); len(matches) == 2 </span><span class="cov8" title="1">{
                compositeID := matches[1]
                return rr.readNodeInfo(ctx, compositeID)
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("unknown resource URI: %s", uri)</span>
}

// readServerInfo reads server information
func (rr *ResourceRegistry) readServerInfo(ctx context.Context) (*ReadResourceResult, error) <span class="cov8" title="1">{
        info, err := rr.service.GetServerInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get server info: %w", err)
        }</span>

        <span class="cov8" title="1">content, err := json.MarshalIndent(info, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal server info: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ReadResourceResult{
                Contents: []ResourceContent{{
                        URI:      "mcp://server/info",
                        MimeType: "application/json",
                        Text:     string(content),
                }},
        }, nil</span>
}

// readDomainInfo reads domain information
func (rr *ResourceRegistry) readDomainInfo(ctx context.Context, domainName string) (*ReadResourceResult, error) <span class="cov8" title="1">{
        // Get domain info by listing all domains and finding the one we want
        domainsResponse, err := rr.service.ListDomains(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list domains: %w", err)
        }</span>

        <span class="cov8" title="1">var targetDomain *MCPDomain
        for _, domain := range domainsResponse.Domains </span><span class="cov8" title="1">{
                if domain.Name == domainName </span><span class="cov8" title="1">{
                        targetDomain = &amp;domain
                        break</span>
                }
        }

        <span class="cov8" title="1">if targetDomain == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("domain not found: %s", domainName)
        }</span>

        <span class="cov8" title="1">content, err := json.MarshalIndent(targetDomain, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal domain info: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ReadResourceResult{
                Contents: []ResourceContent{{
                        URI:      fmt.Sprintf("mcp://domains/%s", domainName),
                        MimeType: "application/json",
                        Text:     string(content),
                }},
        }, nil</span>
}

// readDomainNodes reads all nodes in a domain
func (rr *ResourceRegistry) readDomainNodes(ctx context.Context, domainName string) (*ReadResourceResult, error) <span class="cov8" title="1">{
        // Get first page of nodes (we might want to implement pagination later)
        nodesResponse, err := rr.service.ListNodes(ctx, domainName, 1, 100, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list nodes for domain %s: %w", domainName, err)
        }</span>

        <span class="cov8" title="1">content, err := json.MarshalIndent(nodesResponse, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal nodes: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ReadResourceResult{
                Contents: []ResourceContent{{
                        URI:      fmt.Sprintf("mcp://domains/%s/nodes", domainName),
                        MimeType: "application/json",
                        Text:     string(content),
                }},
        }, nil</span>
}

// readNodeInfo reads individual node information
func (rr *ResourceRegistry) readNodeInfo(ctx context.Context, compositeID string) (*ReadResourceResult, error) <span class="cov8" title="1">{
        // Get node info
        node, err := rr.service.GetNode(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node %s: %w", compositeID, err)
        }</span>

        // Also get node attributes
        <span class="cov8" title="1">attributes, err := rr.service.GetNodeAttributes(ctx, compositeID)
        if err != nil </span><span class="cov8" title="1">{
                // Don't fail if attributes can't be fetched, just log it
                attributes = nil
        }</span>

        // Combine node info and attributes
        <span class="cov8" title="1">result := map[string]interface{}{
                "node":       node,
                "attributes": attributes,
        }

        content, err := json.MarshalIndent(result, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal node info: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ReadResourceResult{
                Contents: []ResourceContent{{
                        URI:      fmt.Sprintf("mcp://nodes/%s", compositeID),
                        MimeType: "application/json",
                        Text:     string(content),
                }},
        }, nil</span>
}

// Helper function to validate resource URI format
func (rr *ResourceRegistry) validateURI(uri string) error <span class="cov8" title="1">{
        if !strings.HasPrefix(uri, "mcp://") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid URI scheme, must start with 'mcp://'")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package mcp

import (
        "context"

        "url-db/internal/models"
)

type MCPService interface {
        CreateNode(ctx context.Context, req *models.CreateMCPNodeRequest) (*models.MCPNode, error)
        GetNode(ctx context.Context, compositeID string) (*models.MCPNode, error)
        UpdateNode(ctx context.Context, compositeID string, req *models.UpdateNodeRequest) (*models.MCPNode, error)
        DeleteNode(ctx context.Context, compositeID string) error
        ListNodes(ctx context.Context, domainName string, page, size int, search string) (*models.MCPNodeListResponse, error)
        FindNodeByURL(ctx context.Context, req *models.FindMCPNodeRequest) (*models.MCPNode, error)
        BatchGetNodes(ctx context.Context, req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error)

        ListDomains(ctx context.Context) (*MCPDomainListResponse, error)
        CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*MCPDomain, error)

        GetNodeAttributes(ctx context.Context, compositeID string) (*models.MCPNodeAttributeResponse, error)
        SetNodeAttributes(ctx context.Context, compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributeResponse, error)
        FilterNodesByAttributes(ctx context.Context, domainName string, filters []interface{}, page, size int) (*models.MCPNodeListResponse, error)

        // Domain attribute management methods
        ListDomainAttributes(ctx context.Context, domainName string) (*models.MCPDomainAttributeListResponse, error)
        CreateDomainAttribute(ctx context.Context, domainName string, req *models.CreateAttributeRequest) (*models.MCPDomainAttribute, error)
        GetDomainAttribute(ctx context.Context, compositeID string) (*models.MCPDomainAttribute, error)
        UpdateDomainAttribute(ctx context.Context, compositeID string, req *models.UpdateAttributeRequest) (*models.MCPDomainAttribute, error)
        DeleteDomainAttribute(ctx context.Context, compositeID string) error

        GetServerInfo(ctx context.Context) (*MCPServerInfo, error)

        // External dependency management methods
        CreateSubscription(ctx context.Context, req *MCPCreateSubscriptionRequest) (*models.NodeSubscription, error)
        ListSubscriptions(ctx context.Context, serviceName string, page, size int) (*MCPSubscriptionListResponse, error)
        GetNodeSubscriptions(ctx context.Context, compositeID string) ([]*models.NodeSubscription, error)
        DeleteSubscription(ctx context.Context, subscriptionID int64) error

        CreateDependency(ctx context.Context, req *MCPCreateDependencyRequest) (*models.NodeDependency, error)
        ListNodeDependencies(ctx context.Context, compositeID string) ([]*models.NodeDependency, error)
        ListNodeDependents(ctx context.Context, compositeID string) ([]*models.NodeDependency, error)
        DeleteDependency(ctx context.Context, dependencyID int64) error

        GetNodeEvents(ctx context.Context, compositeID string, limit int) ([]*models.NodeEvent, error)
        GetPendingEvents(ctx context.Context, limit int) ([]*models.NodeEvent, error)
        ProcessEvent(ctx context.Context, eventID int64) error
        GetEventStats(ctx context.Context) (map[string]interface{}, error)
}

type NodeService interface {
        CreateNode(ctx context.Context, domainID int, req *models.CreateNodeRequest) (*models.Node, error)
        GetNode(ctx context.Context, nodeID int) (*models.Node, error)
        UpdateNode(ctx context.Context, nodeID int, req *models.UpdateNodeRequest) (*models.Node, error)
        DeleteNode(ctx context.Context, nodeID int) error
        ListNodes(ctx context.Context, domainID int, page, size int, search string) (*models.NodeListResponse, error)
        FindNodeByURL(ctx context.Context, domainID int, req *models.FindNodeByURLRequest) (*models.Node, error)
}

type DomainService interface {
        CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*models.Domain, error)
        GetDomain(ctx context.Context, domainID int) (*models.Domain, error)
        GetDomainByName(ctx context.Context, name string) (*models.Domain, error)
        ListDomains(ctx context.Context, page, size int) (*models.DomainListResponse, error)
        UpdateDomain(ctx context.Context, domainID int, req *models.UpdateDomainRequest) (*models.Domain, error)
        DeleteDomain(ctx context.Context, domainID int) error
}

type AttributeService interface {
        GetNodeAttributes(ctx context.Context, nodeID int) ([]models.NodeAttributeWithInfo, error)
        SetNodeAttribute(ctx context.Context, nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttributeWithInfo, error)
        GetAttributeByName(ctx context.Context, domainID int, name string) (*models.Attribute, error)
        DeleteNodeAttribute(ctx context.Context, nodeID, attributeID int) error

        // Domain attribute management methods
        ListAttributes(ctx context.Context, domainID int) (*models.AttributeListResponse, error)
        CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error)
        GetAttribute(ctx context.Context, id int) (*models.Attribute, error)
        UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error)
        DeleteAttribute(ctx context.Context, id int) error
}

type NodeCountService interface {
        GetNodeCountByDomain(ctx context.Context, domainID int) (int, error)
}

type SubscriptionService interface {
        CreateSubscription(nodeID int64, req *models.CreateNodeSubscriptionRequest) (*models.NodeSubscription, error)
        GetServiceSubscriptions(service string) ([]*models.NodeSubscription, error)
        GetAllSubscriptions(page, pageSize int) ([]*models.NodeSubscription, int, error)
        GetNodeSubscriptions(nodeID int64) ([]*models.NodeSubscription, error)
        DeleteSubscription(id int64) error
}

type DependencyService interface {
        CreateDependency(dependentNodeID int64, req *models.CreateNodeDependencyRequest) (*models.NodeDependency, error)
        GetNodeDependencies(nodeID int64) ([]*models.NodeDependency, error)
        GetNodeDependents(nodeID int64) ([]*models.NodeDependency, error)
        DeleteDependency(id int64) error
}

type EventService interface {
        GetNodeEvents(nodeID int64, limit int) ([]*models.NodeEvent, error)
        GetPendingEvents(limit int) ([]*models.NodeEvent, error)
        ProcessEvent(eventID int64) error
        GetEventStats() (map[string]interface{}, error)
}

type mcpService struct {
        nodeService         NodeService
        domainService       DomainService
        attributeService    AttributeService
        nodeCountService    NodeCountService
        subscriptionService SubscriptionService
        dependencyService   DependencyService
        eventService        EventService
        converter           *Converter
}

func NewMCPService(
        nodeService NodeService,
        domainService DomainService,
        attributeService AttributeService,
        nodeCountService NodeCountService,
        subscriptionService SubscriptionService,
        dependencyService DependencyService,
        eventService EventService,
        converter *Converter,
) MCPService <span class="cov0" title="0">{
        return &amp;mcpService{
                nodeService:         nodeService,
                domainService:       domainService,
                attributeService:    attributeService,
                nodeCountService:    nodeCountService,
                subscriptionService: subscriptionService,
                dependencyService:   dependencyService,
                eventService:        eventService,
                converter:           converter,
        }
}</span>

// Node operations are in node_operations.go
// Domain operations are in domain_operations.go
// Attribute operations are in attribute_operations.go
// Query operations are in query_operations.go
</pre>
		
		<pre class="file" id="file99" style="display: none">package mcp

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        "strings"
        "sync"

        "url-db/internal/constants"
)

// StdioServer implements MCP protocol over stdin/stdout with JSON-RPC 2.0
type StdioServer struct {
        service          MCPService
        reader           *bufio.Reader
        writer           io.Writer
        toolRegistry     *ToolRegistry
        resourceRegistry *ResourceRegistry
        initialized      bool
        shutdownOnce     sync.Once
        shutdown         chan struct{}
}

// NewStdioServer creates a new MCP stdio server
func NewStdioServer(service MCPService) *StdioServer <span class="cov0" title="0">{
        return &amp;StdioServer{
                service:          service,
                reader:           bufio.NewReader(os.Stdin),
                writer:           os.Stdout,
                toolRegistry:     NewToolRegistry(service),
                resourceRegistry: NewResourceRegistry(service),
                initialized:      false,
                shutdown:         make(chan struct{}),
        }
}</span>

// Start begins the stdio MCP session with JSON-RPC 2.0 protocol
func (s *StdioServer) Start() error <span class="cov0" title="0">{
        // log.Println("Starting MCP JSON-RPC 2.0 stdio server...") // Disabled for clean JSON output

        for </span><span class="cov0" title="0">{
                line, err := s.reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // log.Println("EOF received, ending session") // Disabled for clean JSON output
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("error reading input: %w", err)</span>
                }

                <span class="cov0" title="0">line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse JSON-RPC request
                <span class="cov0" title="0">req, err := ParseJSONRPCRequest([]byte(line))
                if err != nil </span><span class="cov0" title="0">{
                        // Send parse error response
                        errorResp := NewJSONRPCError(nil, ParseError, constants.ErrParseError, err.Error())
                        s.sendResponse(errorResp)
                        continue</span>
                }

                // Handle the request
                <span class="cov0" title="0">resp := s.handleJSONRPCRequest(req)
                if resp != nil </span><span class="cov0" title="0">{
                        s.sendResponse(resp)
                }</span>
        }
}

// handleJSONRPCRequest processes a JSON-RPC 2.0 request
func (s *StdioServer) handleJSONRPCRequest(req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        ctx := context.Background()

        switch req.Method </span>{
        case "initialize":<span class="cov0" title="0">
                return s.handleInitialize(ctx, req)</span>
        case "notifications/initialized":<span class="cov0" title="0">
                return s.handleInitialized(ctx, req)</span>
        case "tools/list":<span class="cov0" title="0">
                return s.handleToolsList(ctx, req)</span>
        case "tools/call":<span class="cov0" title="0">
                return s.handleToolsCall(ctx, req)</span>
        case "resources/list":<span class="cov0" title="0">
                return s.handleResourcesList(ctx, req)</span>
        case "resources/read":<span class="cov0" title="0">
                return s.handleResourcesRead(ctx, req)</span>
        default:<span class="cov0" title="0">
                return NewJSONRPCError(req.ID, MethodNotFound, fmt.Sprintf(constants.ErrMethodNotFound, req.Method), nil)</span>
        }
}

// Shutdown gracefully shuts down the server
func (s *StdioServer) Shutdown() <span class="cov0" title="0">{
        s.shutdownOnce.Do(func() </span><span class="cov0" title="0">{
                close(s.shutdown)
        }</span>)
}

// sendResponse sends a JSON-RPC response
func (s *StdioServer) sendResponse(resp *JSONRPCResponse) <span class="cov0" title="0">{
        data, err := resp.ToJSON()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling response: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(s.writer, "%s\n", string(data))</span>
}

// handleInitialize handles the MCP initialize request
func (s *StdioServer) handleInitialize(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        // Parse initialize request
        var initReq InitializeRequest
        if req.Params != nil </span><span class="cov0" title="0">{
                paramsData, _ := json.Marshal(req.Params)
                if err := json.Unmarshal(paramsData, &amp;initReq); err != nil </span><span class="cov0" title="0">{
                        return NewJSONRPCError(req.ID, InvalidParams, constants.ErrInvalidInitParams, err.Error())
                }</span>
        }

        // Create response
        <span class="cov0" title="0">result := InitializeResult{
                ProtocolVersion: constants.MCPProtocolVersion,
                Capabilities: ServerCapabilities{
                        Tools: &amp;ToolsCapability{
                                ListChanged: false,
                        },
                        Resources: &amp;ResourcesCapability{
                                Subscribe:   false,
                                ListChanged: false,
                        },
                },
                ServerInfo: ServerInfo{
                        Name:    constants.MCPServerName,
                        Version: constants.DefaultServerVersion,
                },
        }

        return NewJSONRPCResponse(req.ID, result)</span>
}

// handleInitialized handles the MCP initialized notification
func (s *StdioServer) handleInitialized(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        s.initialized = true
        log.Println("MCP server initialized successfully")

        // Notification - no response needed for initialized
        if req.ID == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return NewJSONRPCResponse(req.ID, nil)</span>
}

// handleToolsList handles the tools/list request
func (s *StdioServer) handleToolsList(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        if !s.initialized </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InvalidRequest, constants.ErrServerNotInitialized, nil)
        }</span>

        <span class="cov0" title="0">tools := s.toolRegistry.GetTools()
        result := ToolsListResult{
                Tools: tools,
        }

        return NewJSONRPCResponse(req.ID, result)</span>
}

// handleToolsCall handles the tools/call request
func (s *StdioServer) handleToolsCall(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        if !s.initialized </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InvalidRequest, constants.ErrServerNotInitialized, nil)
        }</span>

        // Parse tool call request
        <span class="cov0" title="0">var callReq CallToolRequest
        if req.Params != nil </span><span class="cov0" title="0">{
                paramsData, _ := json.Marshal(req.Params)
                if err := json.Unmarshal(paramsData, &amp;callReq); err != nil </span><span class="cov0" title="0">{
                        return NewJSONRPCError(req.ID, InvalidParams, constants.ErrInvalidToolCallParams, err.Error())
                }</span>
        }

        // Call the tool
        <span class="cov0" title="0">result, err := s.toolRegistry.CallTool(ctx, callReq.Name, callReq.Arguments)
        if err != nil </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InternalError, constants.ErrToolExecutionFailed, err.Error())
        }</span>

        <span class="cov0" title="0">return NewJSONRPCResponse(req.ID, result)</span>
}

// handleResourcesList handles the resources/list request
func (s *StdioServer) handleResourcesList(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        if !s.initialized </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InvalidRequest, constants.ErrServerNotInitialized, nil)
        }</span>

        <span class="cov0" title="0">result, err := s.resourceRegistry.GetResources(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InternalError, constants.ErrFailedToGetResources, err.Error())
        }</span>

        <span class="cov0" title="0">return NewJSONRPCResponse(req.ID, result)</span>
}

// handleResourcesRead handles the resources/read request
func (s *StdioServer) handleResourcesRead(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        if !s.initialized </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InvalidRequest, constants.ErrServerNotInitialized, nil)
        }</span>

        // Parse resource read request
        <span class="cov0" title="0">var readReq ReadResourceRequest
        if req.Params != nil </span><span class="cov0" title="0">{
                paramsData, _ := json.Marshal(req.Params)
                if err := json.Unmarshal(paramsData, &amp;readReq); err != nil </span><span class="cov0" title="0">{
                        return NewJSONRPCError(req.ID, InvalidParams, constants.ErrInvalidResourceParams, err.Error())
                }</span>
        }

        // Read the resource
        <span class="cov0" title="0">result, err := s.resourceRegistry.ReadResource(ctx, readReq.URI)
        if err != nil </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InternalError, constants.ErrFailedToReadResource, err.Error())
        }</span>

        <span class="cov0" title="0">return NewJSONRPCResponse(req.ID, result)</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">// Code generated from mcp-tools.yaml. DO NOT EDIT.
// Generated by scripts/generate-tool-constants.py

package mcp

// MCP Tool Names - Single source of truth
const (
        // Server Information
        ServerName         = "url-db-mcp-server"
        ServerVersion      = "1.0.0"
        CompositeKeyFormat = "url-db:domain:id"

        // Tool Names

        // Domain management operations
        ListDomainsTool  = "list_domains"
        CreateDomainTool = "create_domain"

        // Node/URL CRUD operations
        ListNodesTool     = "list_nodes"
        CreateNodeTool    = "create_node"
        GetNodeTool       = "get_node"
        UpdateNodeTool    = "update_node"
        DeleteNodeTool    = "delete_node"
        FindNodeByUrlTool = "find_node_by_url"

        // Node attribute management
        GetNodeAttributesTool = "get_node_attributes"
        SetNodeAttributesTool = "set_node_attributes"

        // Domain schema management
        ListDomainAttributesTool  = "list_domain_attributes"
        CreateDomainAttributeTool = "create_domain_attribute"
        GetDomainAttributeTool    = "get_domain_attribute"
        UpdateDomainAttributeTool = "update_domain_attribute"
        DeleteDomainAttributeTool = "delete_domain_attribute"

        // Advanced query operations
        GetNodeWithAttributesTool   = "get_node_with_attributes"
        FilterNodesByAttributesTool = "filter_nodes_by_attributes"

        // Event subscription management
        CreateSubscriptionTool   = "create_subscription"
        ListSubscriptionsTool    = "list_subscriptions"
        GetNodeSubscriptionsTool = "get_node_subscriptions"
        DeleteSubscriptionTool   = "delete_subscription"

        // Node dependency management
        CreateDependencyTool     = "create_dependency"
        ListNodeDependenciesTool = "list_node_dependencies"
        ListNodeDependentsTool   = "list_node_dependents"
        DeleteDependencyTool     = "delete_dependency"

        // Event tracking and processing
        GetNodeEventsTool    = "get_node_events"
        GetPendingEventsTool = "get_pending_events"
        ProcessEventTool     = "process_event"
        GetEventStatsTool    = "get_event_stats"

        // Server metadata and information
        GetServerInfoTool = "get_server_info"
)

// GetAllToolNames returns all tool names
func GetAllToolNames() []string <span class="cov0" title="0">{
        return []string{
                ListDomainsTool,
                CreateDomainTool,
                ListNodesTool,
                CreateNodeTool,
                GetNodeTool,
                UpdateNodeTool,
                DeleteNodeTool,
                FindNodeByUrlTool,
                GetNodeAttributesTool,
                SetNodeAttributesTool,
                ListDomainAttributesTool,
                CreateDomainAttributeTool,
                GetDomainAttributeTool,
                UpdateDomainAttributeTool,
                DeleteDomainAttributeTool,
                GetNodeWithAttributesTool,
                FilterNodesByAttributesTool,
                CreateSubscriptionTool,
                ListSubscriptionsTool,
                GetNodeSubscriptionsTool,
                DeleteSubscriptionTool,
                CreateDependencyTool,
                ListNodeDependenciesTool,
                ListNodeDependentsTool,
                DeleteDependencyTool,
                GetNodeEventsTool,
                GetPendingEventsTool,
                ProcessEventTool,
                GetEventStatsTool,
                GetServerInfoTool,
        }
}</span>

// ToolCategories maps tool names to categories
var ToolCategories = map[string]string{
        ListDomainsTool:             "domain",
        CreateDomainTool:            "domain",
        ListNodesTool:               "node",
        CreateNodeTool:              "node",
        GetNodeTool:                 "node",
        UpdateNodeTool:              "node",
        DeleteNodeTool:              "node",
        FindNodeByUrlTool:           "node",
        GetNodeAttributesTool:       "attribute",
        SetNodeAttributesTool:       "attribute",
        ListDomainAttributesTool:    "schema",
        CreateDomainAttributeTool:   "schema",
        GetDomainAttributeTool:      "schema",
        UpdateDomainAttributeTool:   "schema",
        DeleteDomainAttributeTool:   "schema",
        GetNodeWithAttributesTool:   "query",
        FilterNodesByAttributesTool: "query",
        CreateSubscriptionTool:      "subscription",
        ListSubscriptionsTool:       "subscription",
        GetNodeSubscriptionsTool:    "subscription",
        DeleteSubscriptionTool:      "subscription",
        CreateDependencyTool:        "dependency",
        ListNodeDependenciesTool:    "dependency",
        ListNodeDependentsTool:      "dependency",
        DeleteDependencyTool:        "dependency",
        GetNodeEventsTool:           "event",
        GetPendingEventsTool:        "event",
        ProcessEventTool:            "event",
        GetEventStatsTool:           "event",
        GetServerInfoTool:           "meta",
}

// ToolDescriptions maps tool names to descriptions
var ToolDescriptions = map[string]string{
        ListDomainsTool:             "Get all domains",
        CreateDomainTool:            "Create new domain for organizing URLs",
        ListNodesTool:               "List URLs in domain",
        CreateNodeTool:              "Add URL to domain",
        GetNodeTool:                 "Get URL details",
        UpdateNodeTool:              "Update URL title or description",
        DeleteNodeTool:              "Remove URL",
        FindNodeByUrlTool:           "Search by exact URL",
        GetNodeAttributesTool:       "Get URL tags and attributes",
        SetNodeAttributesTool:       "Add or update URL tags",
        ListDomainAttributesTool:    "Get available tag types for domain",
        CreateDomainAttributeTool:   "Define new tag type for domain",
        GetDomainAttributeTool:      "Get tag type details",
        UpdateDomainAttributeTool:   "Update tag type description",
        DeleteDomainAttributeTool:   "Remove unused tag type",
        GetNodeWithAttributesTool:   "Get URL with all tags at once",
        FilterNodesByAttributesTool: "Search URLs by tag values",
        CreateSubscriptionTool:      "Subscribe to node events",
        ListSubscriptionsTool:       "List all subscriptions for a service",
        GetNodeSubscriptionsTool:    "Get all subscriptions for a specific node",
        DeleteSubscriptionTool:      "Cancel a subscription",
        CreateDependencyTool:        "Create dependency relationship between nodes",
        ListNodeDependenciesTool:    "Get all dependencies for a node",
        ListNodeDependentsTool:      "Get all nodes that depend on this node",
        DeleteDependencyTool:        "Remove dependency relationship",
        GetNodeEventsTool:           "Get event history for a node",
        GetPendingEventsTool:        "Get unprocessed events for processing",
        ProcessEventTool:            "Mark an event as processed",
        GetEventStatsTool:           "Get system event statistics",
        GetServerInfoTool:           "Get server info",
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package mcp

import (
        "context"
        "encoding/json"
        "fmt"
        "url-db/internal/models"
)

// MCP Tool 정의 및 구현

// ToolRegistry manages all available MCP tools
type ToolRegistry struct {
        service MCPService
        tools   []Tool
}

// NewToolRegistry creates a new tool registry
func NewToolRegistry(service MCPService) *ToolRegistry <span class="cov8" title="1">{
        registry := &amp;ToolRegistry{
                service: service,
        }
        registry.registerTools()
        return registry
}</span>

// GetTools returns all available tools
func (tr *ToolRegistry) GetTools() []Tool <span class="cov8" title="1">{
        return tr.tools
}</span>

// CallTool executes a tool by name
func (tr *ToolRegistry) CallTool(ctx context.Context, name string, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        switch name </span>{
        case ListDomainsTool:<span class="cov8" title="1">
                return tr.callListDomains(ctx, arguments)</span>
        case CreateDomainTool:<span class="cov8" title="1">
                return tr.callCreateDomain(ctx, arguments)</span>
        case ListNodesTool:<span class="cov8" title="1">
                return tr.callListNodes(ctx, arguments)</span>
        case CreateNodeTool:<span class="cov8" title="1">
                return tr.callCreateNode(ctx, arguments)</span>
        case GetNodeTool:<span class="cov8" title="1">
                return tr.callGetNode(ctx, arguments)</span>
        case UpdateNodeTool:<span class="cov8" title="1">
                return tr.callUpdateNode(ctx, arguments)</span>
        case DeleteNodeTool:<span class="cov8" title="1">
                return tr.callDeleteNode(ctx, arguments)</span>
        case FindNodeByUrlTool:<span class="cov8" title="1">
                return tr.callFindNodeByURL(ctx, arguments)</span>
        case GetNodeAttributesTool:<span class="cov8" title="1">
                return tr.callGetNodeAttributes(ctx, arguments)</span>
        case SetNodeAttributesTool:<span class="cov8" title="1">
                return tr.callSetNodeAttributes(ctx, arguments)</span>
        case ListDomainAttributesTool:<span class="cov8" title="1">
                return tr.callListDomainAttributes(ctx, arguments)</span>
        case CreateDomainAttributeTool:<span class="cov8" title="1">
                return tr.callCreateDomainAttribute(ctx, arguments)</span>
        case GetDomainAttributeTool:<span class="cov8" title="1">
                return tr.callGetDomainAttribute(ctx, arguments)</span>
        case UpdateDomainAttributeTool:<span class="cov8" title="1">
                return tr.callUpdateDomainAttribute(ctx, arguments)</span>
        case DeleteDomainAttributeTool:<span class="cov8" title="1">
                return tr.callDeleteDomainAttribute(ctx, arguments)</span>
        case GetNodeWithAttributesTool:<span class="cov0" title="0">
                return tr.callGetNodeWithAttributes(ctx, arguments)</span>
        case FilterNodesByAttributesTool:<span class="cov0" title="0">
                return tr.callFilterNodesByAttributes(ctx, arguments)</span>
        case GetServerInfoTool:<span class="cov8" title="1">
                return tr.callGetServerInfo(ctx, arguments)</span>
        // External dependency management tools
        case CreateSubscriptionTool:<span class="cov0" title="0">
                return tr.callCreateSubscription(ctx, arguments)</span>
        case ListSubscriptionsTool:<span class="cov0" title="0">
                return tr.callListSubscriptions(ctx, arguments)</span>
        case GetNodeSubscriptionsTool:<span class="cov0" title="0">
                return tr.callGetNodeSubscriptions(ctx, arguments)</span>
        case DeleteSubscriptionTool:<span class="cov0" title="0">
                return tr.callDeleteSubscription(ctx, arguments)</span>
        case CreateDependencyTool:<span class="cov0" title="0">
                return tr.callCreateDependency(ctx, arguments)</span>
        case ListNodeDependenciesTool:<span class="cov0" title="0">
                return tr.callListNodeDependencies(ctx, arguments)</span>
        case ListNodeDependentsTool:<span class="cov0" title="0">
                return tr.callListNodeDependents(ctx, arguments)</span>
        case DeleteDependencyTool:<span class="cov0" title="0">
                return tr.callDeleteDependency(ctx, arguments)</span>
        case GetNodeEventsTool:<span class="cov0" title="0">
                return tr.callGetNodeEvents(ctx, arguments)</span>
        case GetPendingEventsTool:<span class="cov0" title="0">
                return tr.callGetPendingEvents(ctx, arguments)</span>
        case ProcessEventTool:<span class="cov0" title="0">
                return tr.callProcessEvent(ctx, arguments)</span>
        case GetEventStatsTool:<span class="cov0" title="0">
                return tr.callGetEventStats(ctx, arguments)</span>
        default:<span class="cov8" title="1">
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Unknown tool: %s", name)}},
                        IsError: true,
                }, nil</span>
        }
}

// registerTools registers all available tools
func (tr *ToolRegistry) registerTools() <span class="cov8" title="1">{
        tr.tools = []Tool{
                {
                        Name:        ListDomainsTool,
                        Description: ToolDescriptions[ListDomainsTool],
                        InputSchema: map[string]interface{}{
                                "type":       "object",
                                "properties": map[string]interface{}{},
                        },
                },
                {
                        Name:        CreateDomainTool,
                        Description: ToolDescriptions[CreateDomainTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name",
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain description",
                                        },
                                },
                                "required": []string{"name", "description"},
                        },
                },
                {
                        Name:        ListNodesTool,
                        Description: ToolDescriptions[ListNodesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name to list nodes from",
                                        },
                                        "page": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Page number (default: 1)",
                                                "default":     1,
                                        },
                                        "size": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Page size (default: 20)",
                                                "default":     20,
                                        },
                                        "search": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Search query (optional)",
                                        },
                                },
                                "required": []string{"domain_name"},
                        },
                },
                {
                        Name:        CreateNodeTool,
                        Description: ToolDescriptions[CreateNodeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name",
                                        },
                                        "url": map[string]interface{}{
                                                "type":        "string",
                                                "description": "URL to store",
                                        },
                                        "title": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Node title (optional)",
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Node description (optional)",
                                        },
                                },
                                "required": []string{"domain_name", "url"},
                        },
                },
                {
                        Name:        GetNodeTool,
                        Description: ToolDescriptions[GetNodeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        UpdateNodeTool,
                        Description: ToolDescriptions[UpdateNodeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                        "title": map[string]interface{}{
                                                "type":        "string",
                                                "description": "New title (optional)",
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "New description (optional)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        DeleteNodeTool,
                        Description: ToolDescriptions[DeleteNodeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        FindNodeByUrlTool,
                        Description: ToolDescriptions[FindNodeByUrlTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name",
                                        },
                                        "url": map[string]interface{}{
                                                "type":        "string",
                                                "description": "URL to find",
                                        },
                                },
                                "required": []string{"domain_name", "url"},
                        },
                },
                {
                        Name:        GetNodeAttributesTool,
                        Description: ToolDescriptions[GetNodeAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        SetNodeAttributesTool,
                        Description: ToolDescriptions[SetNodeAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                        "attributes": map[string]interface{}{
                                                "type": "array",
                                                "items": map[string]interface{}{
                                                        "type": "object",
                                                        "properties": map[string]interface{}{
                                                                "name": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Attribute name",
                                                                },
                                                                "value": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Attribute value",
                                                                },
                                                                "order_index": map[string]interface{}{
                                                                        "type":        "integer",
                                                                        "description": "Order index (required for ordered_tag type)",
                                                                },
                                                        },
                                                        "required": []string{"name", "value"},
                                                },
                                                "description": "Array of attributes to set",
                                        },
                                },
                                "required": []string{"composite_id", "attributes"},
                        },
                },
                {
                        Name:        GetServerInfoTool,
                        Description: ToolDescriptions[GetServerInfoTool],
                        InputSchema: map[string]interface{}{
                                "type":       "object",
                                "properties": map[string]interface{}{},
                        },
                },
                {
                        Name:        ListDomainAttributesTool,
                        Description: ToolDescriptions[ListDomainAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "The domain to list attributes for",
                                        },
                                },
                                "required": []string{"domain_name"},
                        },
                },
                {
                        Name:        CreateDomainAttributeTool,
                        Description: ToolDescriptions[CreateDomainAttributeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "The domain to add attribute to",
                                        },
                                        "name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Attribute name",
                                        },
                                        "type": map[string]interface{}{
                                                "type":        "string",
                                                "description": "One of: tag, ordered_tag, number, string, markdown, image",
                                                "enum":        []string{"tag", "ordered_tag", "number", "string", "markdown", "image"},
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Human-readable description (optional)",
                                        },
                                },
                                "required": []string{"domain_name", "name", "type"},
                        },
                },
                {
                        Name:        GetDomainAttributeTool,
                        Description: ToolDescriptions[GetDomainAttributeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool-name:domain:attr-{id})",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        UpdateDomainAttributeTool,
                        Description: ToolDescriptions[UpdateDomainAttributeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool-name:domain:attr-{id})",
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "New description",
                                        },
                                },
                                "required": []string{"composite_id", "description"},
                        },
                },
                {
                        Name:        DeleteDomainAttributeTool,
                        Description: ToolDescriptions[DeleteDomainAttributeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool-name:domain:attr-{id})",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        GetNodeWithAttributesTool,
                        Description: ToolDescriptions[GetNodeWithAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool-name:domain:id)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        FilterNodesByAttributesTool,
                        Description: ToolDescriptions[FilterNodesByAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name to search in",
                                        },
                                        "filters": map[string]interface{}{
                                                "type":        "array",
                                                "description": "Array of attribute filters",
                                                "items": map[string]interface{}{
                                                        "type": "object",
                                                        "properties": map[string]interface{}{
                                                                "name": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Attribute name",
                                                                },
                                                                "value": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Attribute value to match",
                                                                },
                                                                "operator": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Comparison operator: equals, contains, starts_with, ends_with",
                                                                        "enum":        []string{"equals", "contains", "starts_with", "ends_with"},
                                                                        "default":     "equals",
                                                                },
                                                        },
                                                        "required": []string{"name", "value"},
                                                },
                                        },
                                        "page": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Page number (default: 1)",
                                                "default":     1,
                                        },
                                        "size": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Page size (default: 20)",
                                                "default":     20,
                                        },
                                },
                                "required": []string{"domain_name", "filters"},
                        },
                },
        }
}</span>

// Tool implementation methods

func (tr *ToolRegistry) callListDomains(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        response, err := tr.service.ListDomains(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing domains: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callCreateDomain(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.CreateDomainRequest{
                Name:        argsMap["name"].(string),
                Description: argsMap["description"].(string),
        }

        domain, err := tr.service.CreateDomain(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating domain: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(domain, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callListNodes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">domainName := argsMap["domain_name"].(string)
        page := 1
        size := 20
        search := ""

        if p, exists := argsMap["page"]; exists </span><span class="cov8" title="1">{
                if pFloat, ok := p.(float64); ok </span><span class="cov8" title="1">{
                        page = int(pFloat)
                }</span>
        }
        <span class="cov8" title="1">if s, exists := argsMap["size"]; exists </span><span class="cov8" title="1">{
                if sFloat, ok := s.(float64); ok </span><span class="cov8" title="1">{
                        size = int(sFloat)
                }</span>
        }
        <span class="cov8" title="1">if s, exists := argsMap["search"]; exists </span><span class="cov8" title="1">{
                search = s.(string)
        }</span>

        <span class="cov8" title="1">response, err := tr.service.ListNodes(ctx, domainName, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing nodes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callCreateNode(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.CreateMCPNodeRequest{
                DomainName:  argsMap["domain_name"].(string),
                URL:         argsMap["url"].(string),
                Title:       getStringArg(argsMap, "title"),
                Description: getStringArg(argsMap, "description"),
        }

        node, err := tr.service.CreateNode(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(node, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNode(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)
        node, err := tr.service.GetNode(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(node, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callUpdateNode(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)
        req := &amp;models.UpdateNodeRequest{
                Title:       getStringArg(argsMap, "title"),
                Description: getStringArg(argsMap, "description"),
        }

        node, err := tr.service.UpdateNode(ctx, compositeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error updating node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(node, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callDeleteNode(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)
        err := tr.service.DeleteNode(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error deleting node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: fmt.Sprintf("Node %s deleted successfully", compositeID)}},
        }, nil</span>
}

func (tr *ToolRegistry) callFindNodeByURL(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.FindMCPNodeRequest{
                DomainName: argsMap["domain_name"].(string),
                URL:        argsMap["url"].(string),
        }

        node, err := tr.service.FindNodeByURL(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error finding node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(node, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNodeAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)
        response, err := tr.service.GetNodeAttributes(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node attributes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callSetNodeAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)

        // Parse attributes array
        attributesRaw, exists := argsMap["attributes"]
        if !exists </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing attributes parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">attributesArray, ok := attributesRaw.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid attributes format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">var attributes []struct {
                Name       string `json:"name" binding:"required"`
                Value      string `json:"value" binding:"required"`
                OrderIndex *int   `json:"order_index"`
        }
        for _, attrRaw := range attributesArray </span><span class="cov8" title="1">{
                attrMap, ok := attrRaw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">var orderIndex *int
                if orderIndexRaw, exists := attrMap["order_index"]; exists </span><span class="cov0" title="0">{
                        if orderIndexFloat, ok := orderIndexRaw.(float64); ok </span><span class="cov0" title="0">{
                                orderIndexInt := int(orderIndexFloat)
                                orderIndex = &amp;orderIndexInt
                        }</span>
                }

                <span class="cov8" title="1">attributes = append(attributes, struct {
                        Name       string `json:"name" binding:"required"`
                        Value      string `json:"value" binding:"required"`
                        OrderIndex *int   `json:"order_index"`
                }{
                        Name:       attrMap["name"].(string),
                        Value:      attrMap["value"].(string),
                        OrderIndex: orderIndex,
                })</span>
        }

        <span class="cov8" title="1">req := &amp;models.SetMCPNodeAttributesRequest{
                Attributes: attributes,
        }

        response, err := tr.service.SetNodeAttributes(ctx, compositeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error setting node attributes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetServerInfo(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        info, err := tr.service.GetServerInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting server info: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(info, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

// Helper function to safely get string arguments
func getStringArg(args map[string]interface{}, key string) string <span class="cov8" title="1">{
        if val, exists := args[key]; exists </span><span class="cov8" title="1">{
                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func getIntArg(args map[string]interface{}, key string, defaultValue int) int <span class="cov0" title="0">{
        if val, exists := args[key]; exists </span><span class="cov0" title="0">{
                if intVal, ok := val.(int); ok </span><span class="cov0" title="0">{
                        return intVal
                }</span>
                <span class="cov0" title="0">if floatVal, ok := val.(float64); ok </span><span class="cov0" title="0">{
                        return int(floatVal)
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// Domain attribute management methods
func (tr *ToolRegistry) callListDomainAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">domainName := getStringArg(argsMap, "domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing domain_name parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">response, err := tr.service.ListDomainAttributes(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing domain attributes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callCreateDomainAttribute(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">domainName := getStringArg(argsMap, "domain_name")
        name := getStringArg(argsMap, "name")
        typeStr := getStringArg(argsMap, "type")
        description := getStringArg(argsMap, "description")

        if domainName == "" || name == "" || typeStr == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing required parameters: domain_name, name, type"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.CreateAttributeRequest{
                Name:        name,
                Type:        models.AttributeType(typeStr),
                Description: description,
        }

        response, err := tr.service.CreateDomainAttribute(ctx, domainName, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating domain attribute: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetDomainAttribute(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">response, err := tr.service.GetDomainAttribute(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting domain attribute: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callUpdateDomainAttribute(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := getStringArg(argsMap, "composite_id")
        description := getStringArg(argsMap, "description")

        if compositeID == "" || description == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing required parameters: composite_id, description"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.UpdateAttributeRequest{
                Description: description,
        }

        response, err := tr.service.UpdateDomainAttribute(ctx, compositeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error updating domain attribute: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callDeleteDomainAttribute(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">err := tr.service.DeleteDomainAttribute(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error deleting domain attribute: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: "Domain attribute deleted successfully"}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNodeWithAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        // Get node information
        <span class="cov0" title="0">node, err := tr.service.GetNode(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        // Get node attributes
        <span class="cov0" title="0">attributes, err := tr.service.GetNodeAttributes(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node attributes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        // Combine node and attributes into a single response
        <span class="cov0" title="0">response := map[string]interface{}{
                "node":       node,
                "attributes": attributes.Attributes,
        }

        result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callFilterNodesByAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">domainName := getStringArg(argsMap, "domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing domain_name parameter"}},
                        IsError: true,
                }, nil
        }</span>

        // Parse filters
        <span class="cov0" title="0">filtersRaw, exists := argsMap["filters"]
        if !exists </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing filters parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">filtersArray, ok := filtersRaw.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid filters format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">type attributeFilter struct {
                Name     string `json:"name"`
                Value    string `json:"value"`
                Operator string `json:"operator"`
        }

        var filters []attributeFilter
        for _, filterRaw := range filtersArray </span><span class="cov0" title="0">{
                filterMap, ok := filterRaw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">operator := getStringArg(filterMap, "operator")
                if operator == "" </span><span class="cov0" title="0">{
                        operator = "equals"
                }</span>

                <span class="cov0" title="0">filter := attributeFilter{
                        Name:     getStringArg(filterMap, "name"),
                        Value:    getStringArg(filterMap, "value"),
                        Operator: operator,
                }

                filters = append(filters, filter)</span>
        }

        // Parse pagination
        <span class="cov0" title="0">page := 1
        size := 20
        if p, exists := argsMap["page"]; exists </span><span class="cov0" title="0">{
                if pFloat, ok := p.(float64); ok </span><span class="cov0" title="0">{
                        page = int(pFloat)
                }</span>
        }
        <span class="cov0" title="0">if s, exists := argsMap["size"]; exists </span><span class="cov0" title="0">{
                if sFloat, ok := s.(float64); ok </span><span class="cov0" title="0">{
                        size = int(sFloat)
                }</span>
        }

        // Convert filters to interface slice as maps
        <span class="cov0" title="0">var filterInterfaces []interface{}
        for _, f := range filters </span><span class="cov0" title="0">{
                filterMap := map[string]interface{}{
                        "name":     f.Name,
                        "value":    f.Value,
                        "operator": f.Operator,
                }
                filterInterfaces = append(filterInterfaces, filterMap)
        }</span>

        // Call service method to filter nodes
        <span class="cov0" title="0">response, err := tr.service.FilterNodesByAttributes(ctx, domainName, filterInterfaces, page, size)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error filtering nodes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

// External Dependency Management Tool Calls

func (tr *ToolRegistry) callCreateSubscription(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        subscriberService := getStringArg(argsMap, "subscriber_service")

        if compositeID == "" || subscriberService == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing required parameters: composite_id and subscriber_service"}},
                        IsError: true,
                }, nil
        }</span>

        // Parse event types
        <span class="cov0" title="0">eventTypesRaw, exists := argsMap["event_types"]
        if !exists </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing event_types parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">eventTypesArray, ok := eventTypesRaw.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid event_types format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">eventTypes := make([]string, len(eventTypesArray))
        for i, et := range eventTypesArray </span><span class="cov0" title="0">{
                eventTypes[i] = fmt.Sprintf("%v", et)
        }</span>

        <span class="cov0" title="0">req := &amp;MCPCreateSubscriptionRequest{
                CompositeID:        compositeID,
                SubscriberService:  subscriberService,
                SubscriberEndpoint: getStringPtr(argsMap, "subscriber_endpoint"),
                EventTypes:         eventTypes,
        }

        subscription, err := tr.service.CreateSubscription(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating subscription: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(subscription, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callListSubscriptions(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                argsMap = make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">serviceName := getStringArg(argsMap, "service_name")
        page := getIntArg(argsMap, "page", 1)
        size := getIntArg(argsMap, "size", 20)

        response, err := tr.service.ListSubscriptions(ctx, serviceName, page, size)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing subscriptions: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNodeSubscriptions(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">subscriptions, err := tr.service.GetNodeSubscriptions(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node subscriptions: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(subscriptions, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callDeleteSubscription(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">subscriptionID := getIntArg(argsMap, "subscription_id", 0)
        if subscriptionID == 0 </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing or invalid subscription_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">err := tr.service.DeleteSubscription(ctx, int64(subscriptionID))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error deleting subscription: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: "Subscription deleted successfully"}},
        }, nil</span>
}

func (tr *ToolRegistry) callCreateDependency(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">dependentNodeID := getStringArg(argsMap, "dependent_node_id")
        dependencyNodeID := getStringArg(argsMap, "dependency_node_id")
        dependencyType := getStringArg(argsMap, "dependency_type")

        if dependentNodeID == "" || dependencyNodeID == "" || dependencyType == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing required parameters: dependent_node_id, dependency_node_id, dependency_type"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">req := &amp;MCPCreateDependencyRequest{
                DependentNodeID:  dependentNodeID,
                DependencyNodeID: dependencyNodeID,
                DependencyType:   dependencyType,
                CascadeDelete:    getBoolArg(argsMap, "cascade_delete", false),
                CascadeUpdate:    getBoolArg(argsMap, "cascade_update", false),
        }

        dependency, err := tr.service.CreateDependency(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating dependency: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(dependency, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callListNodeDependencies(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">dependencies, err := tr.service.ListNodeDependencies(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing node dependencies: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(dependencies, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callListNodeDependents(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">dependents, err := tr.service.ListNodeDependents(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing node dependents: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(dependents, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callDeleteDependency(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">dependencyID := getIntArg(argsMap, "dependency_id", 0)
        if dependencyID == 0 </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing or invalid dependency_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">err := tr.service.DeleteDependency(ctx, int64(dependencyID))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error deleting dependency: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: "Dependency deleted successfully"}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNodeEvents(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">limit := getIntArg(argsMap, "limit", 50)

        events, err := tr.service.GetNodeEvents(ctx, compositeID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node events: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(events, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetPendingEvents(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                argsMap = make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">limit := getIntArg(argsMap, "limit", 100)

        events, err := tr.service.GetPendingEvents(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting pending events: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(events, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callProcessEvent(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">eventID := getIntArg(argsMap, "event_id", 0)
        if eventID == 0 </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing or invalid event_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">err := tr.service.ProcessEvent(ctx, int64(eventID))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error processing event: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: "Event processed successfully"}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetEventStats(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        stats, err := tr.service.GetEventStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting event stats: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(stats, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

// Helper functions
func getStringPtr(argsMap map[string]interface{}, key string) *string <span class="cov0" title="0">{
        if val, exists := argsMap[key]; exists </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok &amp;&amp; str != "" </span><span class="cov0" title="0">{
                        return &amp;str
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getBoolArg(argsMap map[string]interface{}, key string, defaultValue bool) bool <span class="cov0" title="0">{
        if val, exists := argsMap[key]; exists </span><span class="cov0" title="0">{
                if b, ok := val.(bool); ok </span><span class="cov0" title="0">{
                        return b
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package mcp

import (
        "context"
        "fmt"
        "strings"

        "url-db/internal/models"
)

type AttributeManager struct {
        attributeService AttributeService
        domainService    DomainService
        converter        *Converter
}

func NewAttributeManager(attributeService AttributeService, domainService DomainService, converter *Converter) *AttributeManager <span class="cov0" title="0">{
        return &amp;AttributeManager{
                attributeService: attributeService,
                domainService:    domainService,
                converter:        converter,
        }
}</span>

func (am *AttributeManager) GetNodeAttributes(ctx context.Context, compositeID string) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributes, err := am.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get node attributes: %v", err))
        }</span>

        <span class="cov0" title="0">mcpAttributes := am.converter.NodeAttributesToMCPAttributes(attributes)

        return &amp;models.MCPNodeAttributeResponse{
                CompositeID: compositeID,
                Attributes:  mcpAttributes,
        }, nil</span>
}

func (am *AttributeManager) SetNodeAttributes(ctx context.Context, compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := am.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := am.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">if err := am.validateAttributeRequests(req.Attributes); err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(err.Error())
        }</span>

        <span class="cov0" title="0">existingAttributes, err := am.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get existing attributes: %v", err))
        }</span>

        <span class="cov0" title="0">existingAttrMap := make(map[string]models.NodeAttributeWithInfo)
        for _, attr := range existingAttributes </span><span class="cov0" title="0">{
                existingAttrMap[attr.Name] = attr
        }</span>

        <span class="cov0" title="0">requestedAttrMap := make(map[string]string)
        for _, attrReq := range req.Attributes </span><span class="cov0" title="0">{
                requestedAttrMap[attrReq.Name] = attrReq.Value
        }</span>

        <span class="cov0" title="0">for _, existingAttr := range existingAttributes </span><span class="cov0" title="0">{
                if _, exists := requestedAttrMap[existingAttr.Name]; !exists </span><span class="cov0" title="0">{
                        if err := am.attributeService.DeleteNodeAttribute(ctx, nodeID, existingAttr.AttributeID); err != nil </span><span class="cov0" title="0">{
                                return nil, NewInternalServerError(fmt.Sprintf("failed to delete attribute: %v", err))
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, attrReq := range req.Attributes </span><span class="cov0" title="0">{
                attribute, err := am.attributeService.GetAttributeByName(ctx, domain.ID, attrReq.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, NewValidationError(fmt.Sprintf("attribute '%s' not found in domain '%s'", attrReq.Name, domainName))
                }</span>

                <span class="cov0" title="0">if err := am.validateAttributeValue(attribute.Type, attrReq.Value); err != nil </span><span class="cov0" title="0">{
                        return nil, NewValidationError(fmt.Sprintf("invalid value for attribute '%s': %v", attrReq.Name, err))
                }</span>

                <span class="cov0" title="0">if existingAttr, exists := existingAttrMap[attrReq.Name]; exists </span><span class="cov0" title="0">{
                        if err := am.attributeService.DeleteNodeAttribute(ctx, nodeID, existingAttr.AttributeID); err != nil </span><span class="cov0" title="0">{
                                return nil, NewInternalServerError(fmt.Sprintf("failed to delete existing attribute: %v", err))
                        }</span>
                }

                <span class="cov0" title="0">createReq := &amp;models.CreateNodeAttributeRequest{
                        AttributeID: attribute.ID,
                        Value:       attrReq.Value,
                        OrderIndex:  attrReq.OrderIndex,
                }

                if _, err := am.attributeService.SetNodeAttribute(ctx, nodeID, createReq); err != nil </span><span class="cov0" title="0">{
                        return nil, NewInternalServerError(fmt.Sprintf("failed to set attribute: %v", err))
                }</span>
        }

        <span class="cov0" title="0">return am.GetNodeAttributes(ctx, compositeID)</span>
}

func (am *AttributeManager) AddNodeAttribute(ctx context.Context, compositeID string, req *AddAttributeRequest) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := am.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := am.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">attribute, err := am.attributeService.GetAttributeByName(ctx, domain.ID, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(fmt.Sprintf("attribute '%s' not found in domain '%s'", req.Name, domainName))
        }</span>

        <span class="cov0" title="0">if err := am.validateAttributeValue(attribute.Type, req.Value); err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(fmt.Sprintf("invalid value for attribute '%s': %v", req.Name, err))
        }</span>

        <span class="cov0" title="0">createReq := &amp;models.CreateNodeAttributeRequest{
                AttributeID: attribute.ID,
                Value:       req.Value,
                OrderIndex:  req.OrderIndex,
        }

        if _, err := am.attributeService.SetNodeAttribute(ctx, nodeID, createReq); err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to add attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return am.GetNodeAttributes(ctx, compositeID)</span>
}

func (am *AttributeManager) RemoveNodeAttribute(ctx context.Context, compositeID string, attributeName string) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := am.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := am.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">attribute, err := am.attributeService.GetAttributeByName(ctx, domain.ID, attributeName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(fmt.Sprintf("attribute '%s' not found in domain '%s'", attributeName, domainName))
        }</span>

        <span class="cov0" title="0">if err := am.attributeService.DeleteNodeAttribute(ctx, nodeID, attribute.ID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to remove attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return am.GetNodeAttributes(ctx, compositeID)</span>
}

func (am *AttributeManager) GetNodeAttributesByType(ctx context.Context, compositeID string, attributeType models.AttributeType) ([]models.MCPAttribute, error) <span class="cov0" title="0">{
        if err := am.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := am.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributes, err := am.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get node attributes: %v", err))
        }</span>

        <span class="cov0" title="0">var filteredAttributes []models.MCPAttribute
        for _, attr := range attributes </span><span class="cov0" title="0">{
                if attr.Type == attributeType </span><span class="cov0" title="0">{
                        mcpAttr := am.converter.NodeAttributeToMCPAttribute(&amp;attr)
                        if mcpAttr != nil </span><span class="cov0" title="0">{
                                filteredAttributes = append(filteredAttributes, *mcpAttr)
                        }</span>
                }
        }

        <span class="cov0" title="0">return filteredAttributes, nil</span>
}

func (am *AttributeManager) validateAttributeRequests(attributes []struct {
        Name       string `json:"name" binding:"required"`
        Value      string `json:"value" binding:"required"`
        OrderIndex *int   `json:"order_index"`
}) error <span class="cov0" title="0">{
        if len(attributes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("attributes cannot be empty")
        }</span>

        <span class="cov0" title="0">nameSet := make(map[string]bool)
        for _, attr := range attributes </span><span class="cov0" title="0">{
                if attr.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("attribute name cannot be empty")
                }</span>

                <span class="cov0" title="0">if attr.Value == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("attribute value cannot be empty")
                }</span>

                <span class="cov0" title="0">if nameSet[attr.Name] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate attribute name: %s", attr.Name)
                }</span>
                <span class="cov0" title="0">nameSet[attr.Name] = true</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateAttributeValue(attributeType models.AttributeType, value string) error <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("value cannot be empty")
        }</span>

        <span class="cov0" title="0">switch attributeType </span>{
        case models.AttributeTypeTag:<span class="cov0" title="0">
                return am.validateTagValue(value)</span>
        case models.AttributeTypeOrderedTag:<span class="cov0" title="0">
                return am.validateOrderedTagValue(value)</span>
        case models.AttributeTypeNumber:<span class="cov0" title="0">
                return am.validateNumberValue(value)</span>
        case models.AttributeTypeString:<span class="cov0" title="0">
                return am.validateStringValue(value)</span>
        case models.AttributeTypeMarkdown:<span class="cov0" title="0">
                return am.validateMarkdownValue(value)</span>
        case models.AttributeTypeImage:<span class="cov0" title="0">
                return am.validateImageValue(value)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown attribute type: %s", attributeType)</span>
        }
}

func (am *AttributeManager) validateTagValue(value string) error <span class="cov0" title="0">{
        if len(value) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("tag value cannot exceed 50 characters")
        }</span>

        <span class="cov0" title="0">value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("tag value cannot be empty after trimming")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateOrderedTagValue(value string) error <span class="cov0" title="0">{
        if len(value) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("ordered tag value cannot exceed 50 characters")
        }</span>

        <span class="cov0" title="0">value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ordered tag value cannot be empty after trimming")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateNumberValue(value string) error <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("number value cannot be empty")
        }</span>

        <span class="cov0" title="0">if _, err := fmt.Sscanf(value, "%f", new(float64)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid number format: %s", value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateStringValue(value string) error <span class="cov0" title="0">{
        if len(value) &gt; 2048 </span><span class="cov0" title="0">{
                return fmt.Errorf("string value cannot exceed 2048 characters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateMarkdownValue(value string) error <span class="cov0" title="0">{
        if len(value) &gt; 10000 </span><span class="cov0" title="0">{
                return fmt.Errorf("markdown value cannot exceed 10000 characters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) validateImageValue(value string) error <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("image value cannot be empty")
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(value, "http://") &amp;&amp; !strings.HasPrefix(value, "https://") &amp;&amp; !strings.HasPrefix(value, "data:image/") </span><span class="cov0" title="0">{
                return fmt.Errorf("image value must be a valid URL or data URI")
        }</span>

        <span class="cov0" title="0">if len(value) &gt; 2048 </span><span class="cov0" title="0">{
                return fmt.Errorf("image value cannot exceed 2048 characters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AttributeManager) BatchSetNodeAttributes(ctx context.Context, requests []BatchAttributeRequest) (*BatchAttributeResponse, error) <span class="cov0" title="0">{
        if len(requests) == 0 </span><span class="cov0" title="0">{
                return &amp;BatchAttributeResponse{
                        Success: []BatchAttributeSuccess{},
                        Failed:  []BatchAttributeFailure{},
                }, nil
        }</span>

        <span class="cov0" title="0">var successes []BatchAttributeSuccess
        var failures []BatchAttributeFailure

        for _, req := range requests </span><span class="cov0" title="0">{
                response, err := am.SetNodeAttributes(ctx, req.CompositeID, &amp;req.AttributesRequest)
                if err != nil </span><span class="cov0" title="0">{
                        failures = append(failures, BatchAttributeFailure{
                                CompositeID: req.CompositeID,
                                Error:       err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        successes = append(successes, BatchAttributeSuccess{
                                CompositeID: req.CompositeID,
                                Attributes:  response.Attributes,
                        })
                }</span>
        }

        <span class="cov0" title="0">return &amp;BatchAttributeResponse{
                Success: successes,
                Failed:  failures,
        }, nil</span>
}

type AddAttributeRequest struct {
        Name       string `json:"name" binding:"required"`
        Value      string `json:"value" binding:"required"`
        OrderIndex *int   `json:"order_index"`
}

type BatchAttributeRequest struct {
        CompositeID       string                             `json:"composite_id"`
        AttributesRequest models.SetMCPNodeAttributesRequest `json:"attributes_request"`
}

type BatchAttributeResponse struct {
        Success []BatchAttributeSuccess `json:"success"`
        Failed  []BatchAttributeFailure `json:"failed"`
}

type BatchAttributeSuccess struct {
        CompositeID string                `json:"composite_id"`
        Attributes  []models.MCPAttribute `json:"attributes"`
}

type BatchAttributeFailure struct {
        CompositeID string `json:"composite_id"`
        Error       string `json:"error"`
}

type AttributeFilter struct {
        Name  string               `json:"name,omitempty"`
        Type  models.AttributeType `json:"type,omitempty"`
        Value string               `json:"value,omitempty"`
}

type AttributeStats struct {
        AttributeName string `json:"attribute_name"`
        TotalCount    int    `json:"total_count"`
        UniqueValues  int    `json:"unique_values"`
        MostCommon    string `json:"most_common"`
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package mcp

import (
        "context"
        "fmt"

        "url-db/internal/models"
)

// Attribute operation methods for mcpService

func (s *mcpService) GetNodeAttributes(ctx context.Context, compositeID string) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributes, err := s.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get node attributes: %v", err))
        }</span>

        <span class="cov0" title="0">mcpAttributes := s.converter.NodeAttributesToMCPAttributes(attributes)

        return &amp;models.MCPNodeAttributeResponse{
                CompositeID: compositeID,
                Attributes:  mcpAttributes,
        }, nil</span>
}

func (s *mcpService) SetNodeAttributes(ctx context.Context, compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := s.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">existingAttributes, err := s.attributeService.GetNodeAttributes(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get existing attributes: %v", err))
        }</span>

        <span class="cov0" title="0">existingAttrMap := make(map[string]int)
        for _, attr := range existingAttributes </span><span class="cov0" title="0">{
                existingAttrMap[attr.Name] = attr.AttributeID
        }</span>

        <span class="cov0" title="0">for _, attrReq := range req.Attributes </span><span class="cov0" title="0">{
                attribute, err := s.attributeService.GetAttributeByName(ctx, domain.ID, attrReq.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, NewValidationError(fmt.Sprintf("attribute '%s' not found", attrReq.Name))
                }</span>

                <span class="cov0" title="0">if existingAttrID, exists := existingAttrMap[attrReq.Name]; exists </span><span class="cov0" title="0">{
                        if err := s.attributeService.DeleteNodeAttribute(ctx, nodeID, existingAttrID); err != nil </span><span class="cov0" title="0">{
                                return nil, NewInternalServerError(fmt.Sprintf("failed to delete existing attribute: %v", err))
                        }</span>
                }

                <span class="cov0" title="0">createReq := &amp;models.CreateNodeAttributeRequest{
                        AttributeID: attribute.ID,
                        Value:       attrReq.Value,
                        OrderIndex:  attrReq.OrderIndex,
                }

                if _, err := s.attributeService.SetNodeAttribute(ctx, nodeID, createReq); err != nil </span><span class="cov0" title="0">{
                        return nil, NewInternalServerError(fmt.Sprintf("failed to set attribute: %v", err))
                }</span>
        }

        <span class="cov0" title="0">return s.GetNodeAttributes(ctx, compositeID)</span>
}

// Domain attribute management methods
func (s *mcpService) ListDomainAttributes(ctx context.Context, domainName string) (*models.MCPDomainAttributeListResponse, error) <span class="cov0" title="0">{
        domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">response, err := s.attributeService.ListAttributes(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list attributes: %v", err))
        }</span>

        <span class="cov0" title="0">mcpAttributes := make([]models.MCPDomainAttribute, len(response.Attributes))
        for i, attr := range response.Attributes </span><span class="cov0" title="0">{
                compositeID := s.converter.CreateAttributeCompositeID(domain.Name, attr.ID)
                mcpAttributes[i] = models.MCPDomainAttribute{
                        CompositeID: compositeID,
                        Name:        attr.Name,
                        Type:        attr.Type,
                        Description: attr.Description,
                        CreatedAt:   attr.CreatedAt,
                        UpdatedAt:   attr.CreatedAt, // Assuming no updated_at field in Attribute model
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomainAttributeListResponse{
                DomainName: domainName,
                Attributes: mcpAttributes,
                TotalCount: len(mcpAttributes),
        }, nil</span>
}

func (s *mcpService) CreateDomainAttribute(ctx context.Context, domainName string, req *models.CreateAttributeRequest) (*models.MCPDomainAttribute, error) <span class="cov0" title="0">{
        domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeService.CreateAttribute(ctx, domain.ID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to create attribute: %v", err))
        }</span>

        <span class="cov0" title="0">compositeID := s.converter.CreateAttributeCompositeID(domain.Name, attribute.ID)
        return &amp;models.MCPDomainAttribute{
                CompositeID: compositeID,
                Name:        attribute.Name,
                Type:        attribute.Type,
                Description: attribute.Description,
                CreatedAt:   attribute.CreatedAt,
                UpdatedAt:   attribute.CreatedAt,
        }, nil</span>
}

func (s *mcpService) GetDomainAttribute(ctx context.Context, compositeID string) (*models.MCPDomainAttribute, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateAttributeCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributeID, err := s.converter.ExtractAttributeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeService.GetAttribute(ctx, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomainAttribute{
                CompositeID: compositeID,
                Name:        attribute.Name,
                Type:        attribute.Type,
                Description: attribute.Description,
                CreatedAt:   attribute.CreatedAt,
                UpdatedAt:   attribute.CreatedAt,
        }, nil</span>
}

func (s *mcpService) UpdateDomainAttribute(ctx context.Context, compositeID string, req *models.UpdateAttributeRequest) (*models.MCPDomainAttribute, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateAttributeCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributeID, err := s.converter.ExtractAttributeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeService.UpdateAttribute(ctx, attributeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to update attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomainAttribute{
                CompositeID: compositeID,
                Name:        attribute.Name,
                Type:        attribute.Type,
                Description: attribute.Description,
                CreatedAt:   attribute.CreatedAt,
                UpdatedAt:   attribute.CreatedAt,
        }, nil</span>
}

func (s *mcpService) DeleteDomainAttribute(ctx context.Context, compositeID string) error <span class="cov0" title="0">{
        if err := s.converter.ValidateAttributeCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">attributeID, err := s.converter.ExtractAttributeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">if err := s.attributeService.DeleteAttribute(ctx, attributeID); err != nil </span><span class="cov0" title="0">{
                return NewInternalServerError(fmt.Sprintf("failed to delete attribute: %v", err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package mcp

import (
        "context"
        "sync"
        "time"

        "url-db/internal/models"
)

type BatchProcessor struct {
        mcpService MCPService
        maxWorkers int
        timeout    time.Duration
}

type BatchResult struct {
        CompositeID string
        Node        *models.MCPNode
        Error       error
}

func NewBatchProcessor(mcpService MCPService, maxWorkers int, timeout time.Duration) *BatchProcessor <span class="cov0" title="0">{
        if maxWorkers &lt;= 0 </span><span class="cov0" title="0">{
                maxWorkers = 10
        }</span>
        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;BatchProcessor{
                mcpService: mcpService,
                maxWorkers: maxWorkers,
                timeout:    timeout,
        }</span>
}

func (bp *BatchProcessor) BatchGetNodes(ctx context.Context, compositeIDs []string) (*models.BatchMCPNodeResponse, error) <span class="cov0" title="0">{
        if len(compositeIDs) == 0 </span><span class="cov0" title="0">{
                return &amp;models.BatchMCPNodeResponse{
                        Nodes:    []models.MCPNode{},
                        NotFound: []string{},
                }, nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, bp.timeout)
        defer cancel()

        jobs := make(chan string, len(compositeIDs))
        results := make(chan BatchResult, len(compositeIDs))

        var wg sync.WaitGroup
        workerCount := min(bp.maxWorkers, len(compositeIDs))

        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go bp.worker(ctx, jobs, results, &amp;wg)
        }</span>

        <span class="cov0" title="0">for _, compositeID := range compositeIDs </span><span class="cov0" title="0">{
                jobs &lt;- compositeID
        }</span>
        <span class="cov0" title="0">close(jobs)

        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov0" title="0">return bp.collectResults(results, len(compositeIDs))</span>
}

func (bp *BatchProcessor) worker(ctx context.Context, jobs &lt;-chan string, results chan&lt;- BatchResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for compositeID := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        results &lt;- BatchResult{
                                CompositeID: compositeID,
                                Error:       ctx.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0">
                        node, err := bp.mcpService.GetNode(ctx, compositeID)
                        results &lt;- BatchResult{
                                CompositeID: compositeID,
                                Node:        node,
                                Error:       err,
                        }</span>
                }
        }
}

func (bp *BatchProcessor) collectResults(results &lt;-chan BatchResult, expectedCount int) (*models.BatchMCPNodeResponse, error) <span class="cov0" title="0">{
        nodes := make([]models.MCPNode, 0, expectedCount)
        notFound := make([]string, 0)

        for result := range results </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        notFound = append(notFound, result.CompositeID)
                }</span> else<span class="cov0" title="0"> if result.Node != nil </span><span class="cov0" title="0">{
                        nodes = append(nodes, *result.Node)
                }</span>
        }

        <span class="cov0" title="0">return &amp;models.BatchMCPNodeResponse{
                Nodes:    nodes,
                NotFound: notFound,
        }, nil</span>
}

func (bp *BatchProcessor) BatchCreateNodes(ctx context.Context, requests []models.CreateMCPNodeRequest) (*BatchCreateResponse, error) <span class="cov0" title="0">{
        if len(requests) == 0 </span><span class="cov0" title="0">{
                return &amp;BatchCreateResponse{
                        Nodes:  []models.MCPNode{},
                        Failed: []BatchCreateFailure{},
                }, nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, bp.timeout)
        defer cancel()

        jobs := make(chan models.CreateMCPNodeRequest, len(requests))
        results := make(chan BatchCreateResult, len(requests))

        var wg sync.WaitGroup
        workerCount := min(bp.maxWorkers, len(requests))

        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go bp.createWorker(ctx, jobs, results, &amp;wg)
        }</span>

        <span class="cov0" title="0">for _, request := range requests </span><span class="cov0" title="0">{
                jobs &lt;- request
        }</span>
        <span class="cov0" title="0">close(jobs)

        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov0" title="0">return bp.collectCreateResults(results, len(requests))</span>
}

func (bp *BatchProcessor) createWorker(ctx context.Context, jobs &lt;-chan models.CreateMCPNodeRequest, results chan&lt;- BatchCreateResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for request := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        results &lt;- BatchCreateResult{
                                Request: request,
                                Error:   ctx.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0">
                        node, err := bp.mcpService.CreateNode(ctx, &amp;request)
                        results &lt;- BatchCreateResult{
                                Request: request,
                                Node:    node,
                                Error:   err,
                        }</span>
                }
        }
}

func (bp *BatchProcessor) collectCreateResults(results &lt;-chan BatchCreateResult, expectedCount int) (*BatchCreateResponse, error) <span class="cov0" title="0">{
        nodes := make([]models.MCPNode, 0, expectedCount)
        failed := make([]BatchCreateFailure, 0)

        for result := range results </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        failed = append(failed, BatchCreateFailure{
                                Request: result.Request,
                                Error:   result.Error.Error(),
                        })
                }</span> else<span class="cov0" title="0"> if result.Node != nil </span><span class="cov0" title="0">{
                        nodes = append(nodes, *result.Node)
                }</span>
        }

        <span class="cov0" title="0">return &amp;BatchCreateResponse{
                Nodes:  nodes,
                Failed: failed,
        }, nil</span>
}

func (bp *BatchProcessor) BatchUpdateNodes(ctx context.Context, updates []BatchUpdateRequest) (*BatchUpdateResponse, error) <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return &amp;BatchUpdateResponse{
                        Nodes:  []models.MCPNode{},
                        Failed: []BatchUpdateFailure{},
                }, nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, bp.timeout)
        defer cancel()

        jobs := make(chan BatchUpdateRequest, len(updates))
        results := make(chan BatchUpdateResult, len(updates))

        var wg sync.WaitGroup
        workerCount := min(bp.maxWorkers, len(updates))

        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go bp.updateWorker(ctx, jobs, results, &amp;wg)
        }</span>

        <span class="cov0" title="0">for _, update := range updates </span><span class="cov0" title="0">{
                jobs &lt;- update
        }</span>
        <span class="cov0" title="0">close(jobs)

        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov0" title="0">return bp.collectUpdateResults(results, len(updates))</span>
}

func (bp *BatchProcessor) updateWorker(ctx context.Context, jobs &lt;-chan BatchUpdateRequest, results chan&lt;- BatchUpdateResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for request := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        results &lt;- BatchUpdateResult{
                                CompositeID: request.CompositeID,
                                Error:       ctx.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0">
                        node, err := bp.mcpService.UpdateNode(ctx, request.CompositeID, &amp;request.UpdateRequest)
                        results &lt;- BatchUpdateResult{
                                CompositeID: request.CompositeID,
                                Node:        node,
                                Error:       err,
                        }</span>
                }
        }
}

func (bp *BatchProcessor) collectUpdateResults(results &lt;-chan BatchUpdateResult, expectedCount int) (*BatchUpdateResponse, error) <span class="cov0" title="0">{
        nodes := make([]models.MCPNode, 0, expectedCount)
        failed := make([]BatchUpdateFailure, 0)

        for result := range results </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        failed = append(failed, BatchUpdateFailure{
                                CompositeID: result.CompositeID,
                                Error:       result.Error.Error(),
                        })
                }</span> else<span class="cov0" title="0"> if result.Node != nil </span><span class="cov0" title="0">{
                        nodes = append(nodes, *result.Node)
                }</span>
        }

        <span class="cov0" title="0">return &amp;BatchUpdateResponse{
                Nodes:  nodes,
                Failed: failed,
        }, nil</span>
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

type BatchCreateResult struct {
        Request models.CreateMCPNodeRequest
        Node    *models.MCPNode
        Error   error
}

type BatchCreateResponse struct {
        Nodes  []models.MCPNode     `json:"nodes"`
        Failed []BatchCreateFailure `json:"failed"`
}

type BatchCreateFailure struct {
        Request models.CreateMCPNodeRequest `json:"request"`
        Error   string                      `json:"error"`
}

type BatchUpdateRequest struct {
        CompositeID   string                   `json:"composite_id"`
        UpdateRequest models.UpdateNodeRequest `json:"update_request"`
}

type BatchUpdateResult struct {
        CompositeID string
        Node        *models.MCPNode
        Error       error
}

type BatchUpdateResponse struct {
        Nodes  []models.MCPNode     `json:"nodes"`
        Failed []BatchUpdateFailure `json:"failed"`
}

type BatchUpdateFailure struct {
        CompositeID string `json:"composite_id"`
        Error       string `json:"error"`
}

type BatchDeleteRequest struct {
        CompositeIDs []string `json:"composite_ids"`
}

type BatchDeleteResponse struct {
        Deleted []string             `json:"deleted"`
        Failed  []BatchDeleteFailure `json:"failed"`
}

type BatchDeleteFailure struct {
        CompositeID string `json:"composite_id"`
        Error       string `json:"error"`
}

func (bp *BatchProcessor) BatchDeleteNodes(ctx context.Context, compositeIDs []string) (*BatchDeleteResponse, error) <span class="cov0" title="0">{
        if len(compositeIDs) == 0 </span><span class="cov0" title="0">{
                return &amp;BatchDeleteResponse{
                        Deleted: []string{},
                        Failed:  []BatchDeleteFailure{},
                }, nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, bp.timeout)
        defer cancel()

        jobs := make(chan string, len(compositeIDs))
        results := make(chan BatchDeleteResult, len(compositeIDs))

        var wg sync.WaitGroup
        workerCount := min(bp.maxWorkers, len(compositeIDs))

        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go bp.deleteWorker(ctx, jobs, results, &amp;wg)
        }</span>

        <span class="cov0" title="0">for _, compositeID := range compositeIDs </span><span class="cov0" title="0">{
                jobs &lt;- compositeID
        }</span>
        <span class="cov0" title="0">close(jobs)

        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov0" title="0">return bp.collectDeleteResults(results, len(compositeIDs))</span>
}

func (bp *BatchProcessor) deleteWorker(ctx context.Context, jobs &lt;-chan string, results chan&lt;- BatchDeleteResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for compositeID := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        results &lt;- BatchDeleteResult{
                                CompositeID: compositeID,
                                Error:       ctx.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0">
                        err := bp.mcpService.DeleteNode(ctx, compositeID)
                        results &lt;- BatchDeleteResult{
                                CompositeID: compositeID,
                                Error:       err,
                        }</span>
                }
        }
}

func (bp *BatchProcessor) collectDeleteResults(results &lt;-chan BatchDeleteResult, expectedCount int) (*BatchDeleteResponse, error) <span class="cov0" title="0">{
        deleted := make([]string, 0, expectedCount)
        failed := make([]BatchDeleteFailure, 0)

        for result := range results </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        failed = append(failed, BatchDeleteFailure{
                                CompositeID: result.CompositeID,
                                Error:       result.Error.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        deleted = append(deleted, result.CompositeID)
                }</span>
        }

        <span class="cov0" title="0">return &amp;BatchDeleteResponse{
                Deleted: deleted,
                Failed:  failed,
        }, nil</span>
}

type BatchDeleteResult struct {
        CompositeID string
        Error       error
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package mcp

import (
        "strconv"
        "strings"

        "url-db/internal/compositekey"
)

// CompositeKeyAdapter adapts the compositekey.Service to the CompositeKeyService interface
type CompositeKeyAdapter struct {
        service *compositekey.Service
}

// NewCompositeKeyAdapter creates a new adapter
func NewCompositeKeyAdapter(service *compositekey.Service) *CompositeKeyAdapter <span class="cov8" title="1">{
        return &amp;CompositeKeyAdapter{
                service: service,
        }
}</span>

// Create creates a composite key from domain name and node ID
func (a *CompositeKeyAdapter) Create(domainName string, nodeID int) string <span class="cov8" title="1">{
        compositeKey, err := a.service.Create(domainName, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                // Return empty string if creation fails
                return ""
        }</span>
        <span class="cov8" title="1">return compositeKey</span>
}

// Parse parses a composite key string and returns a CompositeKey
func (a *CompositeKeyAdapter) Parse(compositeID string) (*CompositeKey, error) <span class="cov8" title="1">{
        toolName, domainName, id, err := a.service.ParseComponents(compositeID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;CompositeKey{
                ToolName:   toolName,
                DomainName: domainName,
                ID:         id,
        }, nil</span>
}

// Validate validates a composite key
func (a *CompositeKeyAdapter) Validate(compositeID string) error <span class="cov8" title="1">{
        if !a.service.Validate(compositeID) </span><span class="cov8" title="1">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Additional helper methods for compatibility
func (a *CompositeKeyAdapter) ExtractDomainName(compositeID string) (string, error) <span class="cov8" title="1">{
        return a.service.GetDomainName(compositeID)
}</span>

func (a *CompositeKeyAdapter) ExtractNodeID(compositeID string) (int, error) <span class="cov8" title="1">{
        return a.service.GetID(compositeID)
}</span>

func (a *CompositeKeyAdapter) ExtractToolName(compositeID string) (string, error) <span class="cov8" title="1">{
        return a.service.GetToolName(compositeID)
}</span>

// Simple parsing fallback for basic format validation
func parseCompositeID(compositeID string) (string, string, int, error) <span class="cov0" title="0">{
        parts := strings.Split(compositeID, ":")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return "", "", 0, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return "", "", 0, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">return parts[0], parts[1], id, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package mcp

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "url-db/internal/models"
)

type Converter struct {
        compositeKeyService CompositeKeyService
        toolName            string
}

type CompositeKeyService interface {
        Create(domainName string, nodeID int) string
        Parse(compositeID string) (*CompositeKey, error)
        Validate(compositeID string) error
}

type CompositeKey struct {
        ToolName   string
        DomainName string
        ID         int
}

func NewConverter(compositeKeyService CompositeKeyService, toolName string) *Converter <span class="cov0" title="0">{
        return &amp;Converter{
                compositeKeyService: compositeKeyService,
                toolName:            toolName,
        }
}</span>

// ParseCompositeID parses a composite ID and returns tool name, domain name, and node ID
func (c *Converter) ParseCompositeID(compositeID string) (string, string, string, error) <span class="cov0" title="0">{
        compositeKey, err := c.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", err
        }</span>

        <span class="cov0" title="0">return compositeKey.ToolName, compositeKey.DomainName, strconv.Itoa(compositeKey.ID), nil</span>
}

func (c *Converter) NodeToMCPNode(node *models.Node, domain *models.Domain) (*models.MCPNode, error) <span class="cov0" title="0">{
        if node == nil || domain == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node and domain cannot be nil")
        }</span>

        <span class="cov0" title="0">compositeID := c.compositeKeyService.Create(domain.Name, node.ID)

        return &amp;models.MCPNode{
                CompositeID: compositeID,
                URL:         node.Content,
                DomainName:  domain.Name,
                Title:       node.Title,
                Description: node.Description,
                CreatedAt:   node.CreatedAt,
                UpdatedAt:   node.UpdatedAt,
        }, nil</span>
}

func (c *Converter) MCPNodeToNode(mcpNode *models.MCPNode) (*models.Node, int, error) <span class="cov0" title="0">{
        if mcpNode == nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("mcpNode cannot be nil")
        }</span>

        <span class="cov0" title="0">compositeKey, err := c.compositeKeyService.Parse(mcpNode.CompositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">node := &amp;models.Node{
                ID:          compositeKey.ID,
                Content:     mcpNode.URL,
                Title:       mcpNode.Title,
                Description: mcpNode.Description,
                CreatedAt:   mcpNode.CreatedAt,
                UpdatedAt:   mcpNode.UpdatedAt,
        }

        return node, compositeKey.ID, nil</span>
}

func (c *Converter) CreateMCPNodeRequestToCreateNodeRequest(req *models.CreateMCPNodeRequest) *models.CreateNodeRequest <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;models.CreateNodeRequest{
                URL:         req.URL,
                Title:       req.Title,
                Description: req.Description,
        }</span>
}

func (c *Converter) UpdateMCPNodeRequestToUpdateNodeRequest(req *models.UpdateNodeRequest) *models.UpdateNodeRequest <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;models.UpdateNodeRequest{
                Title:       req.Title,
                Description: req.Description,
        }</span>
}

func (c *Converter) DomainToMCPDomain(domain *models.Domain, nodeCount int) *MCPDomain <span class="cov0" title="0">{
        if domain == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;MCPDomain{
                Name:        domain.Name,
                Description: domain.Description,
                NodeCount:   nodeCount,
                CreatedAt:   domain.CreatedAt,
                UpdatedAt:   domain.UpdatedAt,
        }</span>
}

func (c *Converter) NodeAttributeToMCPAttribute(attr *models.NodeAttributeWithInfo) *models.MCPAttribute <span class="cov0" title="0">{
        if attr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPAttribute{
                Name:  attr.Name,
                Type:  string(attr.Type),
                Value: attr.Value,
        }</span>
}

func (c *Converter) NodeAttributesToMCPAttributes(attrs []models.NodeAttributeWithInfo) []models.MCPAttribute <span class="cov0" title="0">{
        if attrs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mcpAttrs := make([]models.MCPAttribute, 0, len(attrs))
        for _, attr := range attrs </span><span class="cov0" title="0">{
                if mcpAttr := c.NodeAttributeToMCPAttribute(&amp;attr); mcpAttr != nil </span><span class="cov0" title="0">{
                        mcpAttrs = append(mcpAttrs, *mcpAttr)
                }</span>
        }

        <span class="cov0" title="0">return mcpAttrs</span>
}

func (c *Converter) ExtractDomainNameFromCompositeID(compositeID string) (string, error) <span class="cov0" title="0">{
        compositeKey, err := c.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return compositeKey.DomainName, nil</span>
}

func (c *Converter) ExtractNodeIDFromCompositeID(compositeID string) (int, error) <span class="cov0" title="0">{
        compositeKey, err := c.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return compositeKey.ID, nil</span>
}

func (c *Converter) ValidateCompositeID(compositeID string) error <span class="cov0" title="0">{
        return c.compositeKeyService.Validate(compositeID)
}</span>

// Attribute composite key methods
func (c *Converter) CreateAttributeCompositeID(domainName string, attributeID int) string <span class="cov0" title="0">{
        // Use a different format for attributes: tool-name:domain:attr-{id}
        return fmt.Sprintf("%s:%s:attr-%d", c.toolName, domainName, attributeID)
}</span>

func (c *Converter) ExtractAttributeIDFromCompositeID(compositeID string) (int, error) <span class="cov0" title="0">{
        // Don't use the standard validation because it expects numeric IDs
        parts := strings.Split(compositeID, ":")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid composite ID format")
        }</span>

        // Validate tool name
        <span class="cov0" title="0">if parts[0] != c.toolName </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid tool name in composite ID")
        }</span>

        // Check if this is an attribute ID (has "attr-" prefix)
        <span class="cov0" title="0">if !strings.HasPrefix(parts[2], "attr-") </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("not an attribute composite ID")
        }</span>

        // Extract the numeric ID after "attr-"
        <span class="cov0" title="0">idStr := strings.TrimPrefix(parts[2], "attr-")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid attribute ID: %v", err)
        }</span>

        <span class="cov0" title="0">if id &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("attribute ID must be positive")
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

func (c *Converter) ValidateAttributeCompositeID(compositeID string) error <span class="cov0" title="0">{
        parts := strings.Split(compositeID, ":")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid composite ID format")
        }</span>

        <span class="cov0" title="0">if parts[0] != c.toolName </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid tool name in composite ID")
        }</span>

        <span class="cov0" title="0">if parts[1] == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("domain name is empty")
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(parts[2], "attr-") </span><span class="cov0" title="0">{
                return fmt.Errorf("not an attribute composite ID")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type MCPDomain struct {
        Name        string    `json:"name"`
        Description string    `json:"description"`
        NodeCount   int       `json:"node_count"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

type MCPDomainListResponse struct {
        Domains []MCPDomain `json:"domains"`
}

type MCPServerInfo struct {
        Name               string   `json:"name"`
        Version            string   `json:"version"`
        Description        string   `json:"description"`
        Capabilities       []string `json:"capabilities"`
        CompositeKeyFormat string   `json:"composite_key_format"`
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package mcp

import (
        "context"
        "fmt"
        "regexp"
        "strings"
        "time"

        "url-db/internal/models"
)

type DomainManager struct {
        domainService    DomainService
        nodeCountService NodeCountService
        converter        *Converter
}

func NewDomainManager(domainService DomainService, nodeCountService NodeCountService, converter *Converter) *DomainManager <span class="cov0" title="0">{
        return &amp;DomainManager{
                domainService:    domainService,
                nodeCountService: nodeCountService,
                converter:        converter,
        }
}</span>

func (dm *DomainManager) ListDomains(ctx context.Context) (*MCPDomainListResponse, error) <span class="cov0" title="0">{
        response, err := dm.domainService.ListDomains(ctx, 1, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list domains: %v", err))
        }</span>

        <span class="cov0" title="0">mcpDomains := make([]MCPDomain, 0, len(response.Domains))
        for _, domain := range response.Domains </span><span class="cov0" title="0">{
                nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
                if err != nil </span><span class="cov0" title="0">{
                        nodeCount = 0
                }</span>

                <span class="cov0" title="0">mcpDomain := dm.converter.DomainToMCPDomain(&amp;domain, nodeCount)
                if mcpDomain != nil </span><span class="cov0" title="0">{
                        mcpDomains = append(mcpDomains, *mcpDomain)
                }</span>
        }

        <span class="cov0" title="0">return &amp;MCPDomainListResponse{
                Domains: mcpDomains,
        }, nil</span>
}

func (dm *DomainManager) CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*MCPDomain, error) <span class="cov0" title="0">{
        if err := dm.validateDomainName(req.Name); err != nil </span><span class="cov0" title="0">{
                return nil, NewValidationError(err.Error())
        }</span>

        <span class="cov0" title="0">normalizedName := dm.normalizeDomainName(req.Name)

        normalizedReq := &amp;models.CreateDomainRequest{
                Name:        normalizedName,
                Description: req.Description,
        }

        domain, err := dm.domainService.CreateDomain(ctx, normalizedReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to create domain: %v", err))
        }</span>

        <span class="cov0" title="0">return dm.converter.DomainToMCPDomain(domain, 0), nil</span>
}

func (dm *DomainManager) GetDomain(ctx context.Context, domainName string) (*MCPDomain, error) <span class="cov0" title="0">{
        domain, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                nodeCount = 0
        }</span>

        <span class="cov0" title="0">return dm.converter.DomainToMCPDomain(domain, nodeCount), nil</span>
}

func (dm *DomainManager) UpdateDomain(ctx context.Context, domainName string, req *models.UpdateDomainRequest) (*MCPDomain, error) <span class="cov0" title="0">{
        domain, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">updatedDomain, err := dm.domainService.UpdateDomain(ctx, domain.ID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to update domain: %v", err))
        }</span>

        <span class="cov0" title="0">nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                nodeCount = 0
        }</span>

        <span class="cov0" title="0">return dm.converter.DomainToMCPDomain(updatedDomain, nodeCount), nil</span>
}

func (dm *DomainManager) DeleteDomain(ctx context.Context, domainName string) error <span class="cov0" title="0">{
        domain, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                return NewInternalServerError(fmt.Sprintf("failed to get node count: %v", err))
        }</span>

        <span class="cov0" title="0">if nodeCount &gt; 0 </span><span class="cov0" title="0">{
                return NewValidationError("도메인에 노드가 존재하므로 삭제할 수 없습니다")
        }</span>

        <span class="cov0" title="0">if err := dm.domainService.DeleteDomain(ctx, domain.ID); err != nil </span><span class="cov0" title="0">{
                return NewInternalServerError(fmt.Sprintf("failed to delete domain: %v", err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (dm *DomainManager) GetDomainStats(ctx context.Context, domainName string) (*DomainStats, error) <span class="cov0" title="0">{
        domain, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to get node count: %v", err))
        }</span>

        <span class="cov0" title="0">return &amp;DomainStats{
                DomainName:  domain.Name,
                Description: domain.Description,
                NodeCount:   nodeCount,
                CreatedAt:   domain.CreatedAt,
                UpdatedAt:   domain.UpdatedAt,
        }, nil</span>
}

func (dm *DomainManager) validateDomainName(name string) error <span class="cov0" title="0">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름은 필수입니다")
        }</span>

        <span class="cov0" title="0">if len(name) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름은 50자를 초과할 수 없습니다")
        }</span>

        <span class="cov0" title="0">matched, err := regexp.MatchString(`^[a-zA-Z0-9-]+$`, name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름 검증 중 오류가 발생했습니다")
        }</span>

        <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름은 영문자, 숫자, 하이픈만 사용할 수 있습니다")
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(name, "-") || strings.HasSuffix(name, "-") </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름은 하이픈으로 시작하거나 끝날 수 없습니다")
        }</span>

        <span class="cov0" title="0">if strings.Contains(name, "--") </span><span class="cov0" title="0">{
                return fmt.Errorf("도메인 이름에 연속된 하이픈은 사용할 수 없습니다")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (dm *DomainManager) normalizeDomainName(name string) string <span class="cov0" title="0">{
        name = strings.ToLower(name)
        name = strings.TrimSpace(name)

        re := regexp.MustCompile(`[^a-z0-9-]`)
        name = re.ReplaceAllString(name, "-")

        re = regexp.MustCompile(`-+`)
        name = re.ReplaceAllString(name, "-")

        name = strings.Trim(name, "-")

        return name
}</span>

func (dm *DomainManager) CheckDomainExists(ctx context.Context, domainName string) (bool, error) <span class="cov0" title="0">{
        _, err := dm.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (dm *DomainManager) GetDomainByPartialName(ctx context.Context, partialName string) ([]MCPDomain, error) <span class="cov0" title="0">{
        response, err := dm.domainService.ListDomains(ctx, 1, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list domains: %v", err))
        }</span>

        <span class="cov0" title="0">var matchedDomains []MCPDomain
        partialNameLower := strings.ToLower(partialName)

        for _, domain := range response.Domains </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(domain.Name), partialNameLower) ||
                        strings.Contains(strings.ToLower(domain.Description), partialNameLower) </span><span class="cov0" title="0">{

                        nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                nodeCount = 0
                        }</span>

                        <span class="cov0" title="0">mcpDomain := dm.converter.DomainToMCPDomain(&amp;domain, nodeCount)
                        if mcpDomain != nil </span><span class="cov0" title="0">{
                                matchedDomains = append(matchedDomains, *mcpDomain)
                        }</span>
                }
        }

        <span class="cov0" title="0">return matchedDomains, nil</span>
}

func (dm *DomainManager) GetPopularDomains(ctx context.Context, limit int) ([]MCPDomain, error) <span class="cov0" title="0">{
        response, err := dm.domainService.ListDomains(ctx, 1, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list domains: %v", err))
        }</span>

        <span class="cov0" title="0">type domainWithCount struct {
                domain    models.Domain
                nodeCount int
        }

        var domainsWithCounts []domainWithCount

        for _, domain := range response.Domains </span><span class="cov0" title="0">{
                nodeCount, err := dm.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
                if err != nil </span><span class="cov0" title="0">{
                        nodeCount = 0
                }</span>

                <span class="cov0" title="0">domainsWithCounts = append(domainsWithCounts, domainWithCount{
                        domain:    domain,
                        nodeCount: nodeCount,
                })</span>
        }

        <span class="cov0" title="0">for i := 0; i &lt; len(domainsWithCounts)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(domainsWithCounts); j++ </span><span class="cov0" title="0">{
                        if domainsWithCounts[i].nodeCount &lt; domainsWithCounts[j].nodeCount </span><span class="cov0" title="0">{
                                domainsWithCounts[i], domainsWithCounts[j] = domainsWithCounts[j], domainsWithCounts[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">if limit &gt; 0 &amp;&amp; limit &lt; len(domainsWithCounts) </span><span class="cov0" title="0">{
                domainsWithCounts = domainsWithCounts[:limit]
        }</span>

        <span class="cov0" title="0">var popularDomains []MCPDomain
        for _, dwc := range domainsWithCounts </span><span class="cov0" title="0">{
                mcpDomain := dm.converter.DomainToMCPDomain(&amp;dwc.domain, dwc.nodeCount)
                if mcpDomain != nil </span><span class="cov0" title="0">{
                        popularDomains = append(popularDomains, *mcpDomain)
                }</span>
        }

        <span class="cov0" title="0">return popularDomains, nil</span>
}

type DomainStats struct {
        DomainName  string    `json:"domain_name"`
        Description string    `json:"description"`
        NodeCount   int       `json:"node_count"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package mcp

import (
        "context"
        "fmt"

        "url-db/internal/models"
)

// Domain operation methods for mcpService

func (s *mcpService) ListDomains(ctx context.Context) (*MCPDomainListResponse, error) <span class="cov0" title="0">{
        response, err := s.domainService.ListDomains(ctx, 1, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list domains: %v", err))
        }</span>

        <span class="cov0" title="0">mcpDomains := make([]MCPDomain, 0, len(response.Domains))
        for _, domain := range response.Domains </span><span class="cov0" title="0">{
                nodeCount, err := s.nodeCountService.GetNodeCountByDomain(ctx, domain.ID)
                if err != nil </span><span class="cov0" title="0">{
                        nodeCount = 0
                }</span>

                <span class="cov0" title="0">mcpDomain := s.converter.DomainToMCPDomain(&amp;domain, nodeCount)
                if mcpDomain != nil </span><span class="cov0" title="0">{
                        mcpDomains = append(mcpDomains, *mcpDomain)
                }</span>
        }

        <span class="cov0" title="0">return &amp;MCPDomainListResponse{
                Domains: mcpDomains,
        }, nil</span>
}

func (s *mcpService) CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*MCPDomain, error) <span class="cov0" title="0">{
        domain, err := s.domainService.CreateDomain(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to create domain: %v", err))
        }</span>

        <span class="cov0" title="0">return s.converter.DomainToMCPDomain(domain, 0), nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package mcp

import (
        "errors"
        "fmt"
)

var (
        ErrInvalidCompositeKey = errors.New("invalid composite key format")
        ErrDomainNotFound      = errors.New("domain not found")
        ErrResourceNotFound    = errors.New("resource not found")
        ErrAccessDenied        = errors.New("access denied")
        ErrBatchPartialFailure = errors.New("batch partial failure")
)

type MCPError struct {
        Code     string      `json:"error"`
        Message  string      `json:"message"`
        Details  interface{} `json:"details,omitempty"`
        HTTPCode int         `json:"-"`
}

func (e MCPError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s: %s", e.Code, e.Message)
}</span>

func NewInvalidCompositeKeyError(provided string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "INVALID_COMPOSITE_KEY",
                Message:  "합성키 형식이 올바르지 않습니다",
                HTTPCode: 400,
                Details: map[string]interface{}{
                        "expected_format": "tool_name:domain_name:id",
                        "provided":        provided,
                },
        }
}</span>

func NewDomainNotFoundError(domainName string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "DOMAIN_NOT_FOUND",
                Message:  "지정된 도메인을 찾을 수 없습니다",
                HTTPCode: 404,
                Details: map[string]interface{}{
                        "domain_name": domainName,
                },
        }
}</span>

func NewResourceNotFoundError(compositeID string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "RESOURCE_NOT_FOUND",
                Message:  "리소스를 찾을 수 없습니다",
                HTTPCode: 404,
                Details: map[string]interface{}{
                        "composite_id": compositeID,
                },
        }
}</span>

func NewNodeNotFoundError(domainName, url string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "NODE_NOT_FOUND",
                Message:  "노드를 찾을 수 없습니다",
                HTTPCode: 404,
                Details: map[string]interface{}{
                        "domain_name": domainName,
                        "url":         url,
                },
        }
}</span>

func NewAccessDeniedError(resource string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "ACCESS_DENIED",
                Message:  "해당 리소스에 대한 접근 권한이 없습니다",
                HTTPCode: 403,
                Details: map[string]interface{}{
                        "resource": resource,
                },
        }
}</span>

func NewBatchPartialFailureError(failed []string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "BATCH_PARTIAL_FAILURE",
                Message:  "배치 처리 중 일부 항목에서 오류가 발생했습니다",
                HTTPCode: 207,
                Details: map[string]interface{}{
                        "failed_items": failed,
                },
        }
}</span>

func NewValidationError(message string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "VALIDATION_ERROR",
                Message:  message,
                HTTPCode: 400,
        }
}</span>

func NewInternalServerError(message string) *MCPError <span class="cov8" title="1">{
        return &amp;MCPError{
                Code:     "INTERNAL_SERVER_ERROR",
                Message:  message,
                HTTPCode: 500,
        }
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">package mcp

import (
        "context"
        "fmt"
        "strconv"

        "url-db/internal/models"
)

// External Dependency Management Operations

// CreateSubscription creates a new subscription for node events
func (s *mcpService) CreateSubscription(ctx context.Context, req *MCPCreateSubscriptionRequest) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(req.CompositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        // Create subscription request
        <span class="cov0" title="0">subscriptionReq := &amp;models.CreateNodeSubscriptionRequest{
                SubscriberService:  req.SubscriberService,
                SubscriberEndpoint: req.SubscriberEndpoint,
                EventTypes:         req.EventTypes,
                FilterConditions:   req.FilterConditions,
        }

        return s.subscriptionService.CreateSubscription(nodeID, subscriptionReq)</span>
}

// ListSubscriptions lists subscriptions with optional service filter
func (s *mcpService) ListSubscriptions(ctx context.Context, serviceName string, page, size int) (*MCPSubscriptionListResponse, error) <span class="cov0" title="0">{
        var subscriptions []*models.NodeSubscription
        var total int
        var err error

        if serviceName != "" </span><span class="cov0" title="0">{
                subscriptions, err = s.subscriptionService.GetServiceSubscriptions(serviceName)
                total = len(subscriptions)

                // Apply pagination manually
                start := (page - 1) * size
                end := start + size
                if start &gt;= total </span><span class="cov0" title="0">{
                        subscriptions = []*models.NodeSubscription{}
                }</span> else<span class="cov0" title="0"> {
                        if end &gt; total </span><span class="cov0" title="0">{
                                end = total
                        }</span>
                        <span class="cov0" title="0">subscriptions = subscriptions[start:end]</span>
                }
        } else<span class="cov0" title="0"> {
                subscriptions, total, err = s.subscriptionService.GetAllSubscriptions(page, size)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;MCPSubscriptionListResponse{
                Subscriptions: subscriptions,
                Total:         total,
                Page:          page,
                Size:          size,
        }, nil</span>
}

// GetNodeSubscriptions gets all subscriptions for a specific node
func (s *mcpService) GetNodeSubscriptions(ctx context.Context, compositeID string) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        <span class="cov0" title="0">return s.subscriptionService.GetNodeSubscriptions(nodeID)</span>
}

// DeleteSubscription deletes a subscription
func (s *mcpService) DeleteSubscription(ctx context.Context, subscriptionID int64) error <span class="cov0" title="0">{
        return s.subscriptionService.DeleteSubscription(subscriptionID)
}</span>

// CreateDependency creates a new dependency relationship
func (s *mcpService) CreateDependency(ctx context.Context, req *MCPCreateDependencyRequest) (*models.NodeDependency, error) <span class="cov0" title="0">{
        // Parse dependent node composite ID
        _, _, dependentNodeIDStr, err := s.converter.ParseCompositeID(req.DependentNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid dependent node composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">dependentNodeID, err := strconv.ParseInt(dependentNodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid dependent node ID: %w", err)
        }</span>

        // Parse dependency node composite ID
        <span class="cov0" title="0">_, _, dependencyNodeIDStr, err := s.converter.ParseCompositeID(req.DependencyNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid dependency node composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">dependencyNodeID, err := strconv.ParseInt(dependencyNodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid dependency node ID: %w", err)
        }</span>

        // Create dependency request
        <span class="cov0" title="0">dependencyReq := &amp;models.CreateNodeDependencyRequest{
                DependencyNodeID: dependencyNodeID,
                DependencyType:   req.DependencyType,
                CascadeDelete:    req.CascadeDelete,
                CascadeUpdate:    req.CascadeUpdate,
                Metadata:         req.Metadata,
        }

        return s.dependencyService.CreateDependency(dependentNodeID, dependencyReq)</span>
}

// ListNodeDependencies gets all dependencies for a node
func (s *mcpService) ListNodeDependencies(ctx context.Context, compositeID string) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        <span class="cov0" title="0">return s.dependencyService.GetNodeDependencies(nodeID)</span>
}

// ListNodeDependents gets all nodes that depend on this node
func (s *mcpService) ListNodeDependents(ctx context.Context, compositeID string) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        <span class="cov0" title="0">return s.dependencyService.GetNodeDependents(nodeID)</span>
}

// DeleteDependency deletes a dependency relationship
func (s *mcpService) DeleteDependency(ctx context.Context, dependencyID int64) error <span class="cov0" title="0">{
        return s.dependencyService.DeleteDependency(dependencyID)
}</span>

// GetNodeEvents gets event history for a node
func (s *mcpService) GetNodeEvents(ctx context.Context, compositeID string, limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        // Parse composite ID to get node ID
        _, _, nodeIDStr, err := s.converter.ParseCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid composite ID: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node ID: %w", err)
        }</span>

        <span class="cov0" title="0">return s.eventService.GetNodeEvents(nodeID, limit)</span>
}

// GetPendingEvents gets unprocessed events
func (s *mcpService) GetPendingEvents(ctx context.Context, limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        return s.eventService.GetPendingEvents(limit)
}</span>

// ProcessEvent marks an event as processed
func (s *mcpService) ProcessEvent(ctx context.Context, eventID int64) error <span class="cov0" title="0">{
        return s.eventService.ProcessEvent(eventID)
}</span>

// GetEventStats gets system event statistics
func (s *mcpService) GetEventStats(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        return s.eventService.GetEventStats()
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package mcp

import (
        "log"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type MCPHandler struct {
        mcpService       MCPService
        batchProcessor   *BatchProcessor
        domainManager    *DomainManager
        attributeManager *AttributeManager
        metadataManager  *MetadataManager
}

func NewMCPHandler(
        mcpService MCPService,
        batchProcessor *BatchProcessor,
        domainManager *DomainManager,
        attributeManager *AttributeManager,
        metadataManager *MetadataManager,
) *MCPHandler <span class="cov0" title="0">{
        return &amp;MCPHandler{
                mcpService:       mcpService,
                batchProcessor:   batchProcessor,
                domainManager:    domainManager,
                attributeManager: attributeManager,
                metadataManager:  metadataManager,
        }
}</span>

func (h *MCPHandler) CreateNode(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateMCPNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.CreateNode(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, node)</span>
}

func (h *MCPHandler) GetNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.GetNode(c.Request.Context(), compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *MCPHandler) UpdateNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.UpdateNode(c.Request.Context(), compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *MCPHandler) DeleteNode(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.mcpService.DeleteNode(c.Request.Context(), compositeID); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *MCPHandler) ListNodes(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Query("domain_name")
        search := c.Query("search")

        page, err := h.parseIntQuery(c, "page", 1)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">size, err := h.parseIntQuery(c, "size", 20)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if size &gt; 100 </span><span class="cov0" title="0">{
                size = 100
        }</span>

        <span class="cov0" title="0">response, err := h.mcpService.ListNodes(c.Request.Context(), domainName, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) FindNodeByURL(c *gin.Context) <span class="cov0" title="0">{
        var req models.FindMCPNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">node, err := h.mcpService.FindNodeByURL(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *MCPHandler) BatchGetNodes(c *gin.Context) <span class="cov0" title="0">{
        var req models.BatchMCPNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(req.CompositeIDs) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.batchProcessor.BatchGetNodes(c.Request.Context(), req.CompositeIDs)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) ListDomains(c *gin.Context) <span class="cov0" title="0">{
        response, err := h.domainManager.ListDomains(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) CreateDomain(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateDomainRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.domainManager.CreateDomain(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, domain)</span>
}

func (h *MCPHandler) GetDomain(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("domain_name is required"))
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.domainManager.GetDomain(c.Request.Context(), domainName)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, domain)</span>
}

func (h *MCPHandler) UpdateDomain(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("domain_name is required"))
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateDomainRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">domain, err := h.domainManager.UpdateDomain(c.Request.Context(), domainName, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, domain)</span>
}

func (h *MCPHandler) DeleteDomain(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("domain_name is required"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.domainManager.DeleteDomain(c.Request.Context(), domainName); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *MCPHandler) GetNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.GetNodeAttributes(c.Request.Context(), compositeID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) SetNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">var req models.SetMCPNodeAttributesRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.SetNodeAttributes(c.Request.Context(), compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) AddNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">var req AddAttributeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.AddNodeAttribute(c.Request.Context(), compositeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) RemoveNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        compositeID := c.Param("composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("composite_id is required"))
                return
        }</span>

        <span class="cov0" title="0">attributeName := c.Param("attribute_name")
        if attributeName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("attribute_name is required"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.RemoveNodeAttribute(c.Request.Context(), compositeID, attributeName)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *MCPHandler) GetServerInfo(c *gin.Context) <span class="cov0" title="0">{
        info, err := h.metadataManager.GetServerInfo(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, info)</span>
}

func (h *MCPHandler) GetDetailedServerInfo(c *gin.Context) <span class="cov0" title="0">{
        info, err := h.metadataManager.GetDetailedServerInfo(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, info)</span>
}

func (h *MCPHandler) GetHealthStatus(c *gin.Context) <span class="cov0" title="0">{
        status, err := h.metadataManager.GetHealthStatus(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, status)</span>
}

func (h *MCPHandler) GetStatistics(c *gin.Context) <span class="cov0" title="0">{
        stats, err := h.metadataManager.GetStatistics(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

func (h *MCPHandler) GetAPIDocumentation(c *gin.Context) <span class="cov0" title="0">{
        docs, err := h.metadataManager.GetAPIDocumentation(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, docs)</span>
}

func (h *MCPHandler) BatchCreateNodes(c *gin.Context) <span class="cov0" title="0">{
        var requests []models.CreateMCPNodeRequest
        if err := c.ShouldBindJSON(&amp;requests); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(requests) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.batchProcessor.BatchCreateNodes(c.Request.Context(), requests)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">statusCode := http.StatusCreated
        if len(response.Failed) &gt; 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusMultiStatus
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

func (h *MCPHandler) BatchUpdateNodes(c *gin.Context) <span class="cov0" title="0">{
        var requests []BatchUpdateRequest
        if err := c.ShouldBindJSON(&amp;requests); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(requests) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.batchProcessor.BatchUpdateNodes(c.Request.Context(), requests)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">statusCode := http.StatusOK
        if len(response.Failed) &gt; 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusMultiStatus
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

func (h *MCPHandler) BatchDeleteNodes(c *gin.Context) <span class="cov0" title="0">{
        var req BatchDeleteRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(req.CompositeIDs) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.batchProcessor.BatchDeleteNodes(c.Request.Context(), req.CompositeIDs)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">statusCode := http.StatusOK
        if len(response.Failed) &gt; 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusMultiStatus
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

func (h *MCPHandler) BatchSetNodeAttributes(c *gin.Context) <span class="cov0" title="0">{
        var requests []BatchAttributeRequest
        if err := c.ShouldBindJSON(&amp;requests); err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if len(requests) &gt; 100 </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("batch size cannot exceed 100"))
                return
        }</span>

        <span class="cov0" title="0">response, err := h.attributeManager.BatchSetNodeAttributes(c.Request.Context(), requests)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">statusCode := http.StatusOK
        if len(response.Failed) &gt; 0 </span><span class="cov0" title="0">{
                statusCode = http.StatusMultiStatus
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

func (h *MCPHandler) SearchDomains(c *gin.Context) <span class="cov0" title="0">{
        query := c.Query("q")
        if query == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("query parameter 'q' is required"))
                return
        }</span>

        <span class="cov0" title="0">domains, err := h.domainManager.GetDomainByPartialName(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, MCPDomainListResponse{
                Domains: domains,
        })</span>
}

func (h *MCPHandler) GetPopularDomains(c *gin.Context) <span class="cov0" title="0">{
        limit, err := h.parseIntQuery(c, "limit", 10)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">domains, err := h.domainManager.GetPopularDomains(c.Request.Context(), limit)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, MCPDomainListResponse{
                Domains: domains,
        })</span>
}

func (h *MCPHandler) GetDomainStats(c *gin.Context) <span class="cov0" title="0">{
        domainName := c.Param("domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                h.handleError(c, NewValidationError("domain_name is required"))
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.domainManager.GetDomainStats(c.Request.Context(), domainName)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

func (h *MCPHandler) parseIntQuery(c *gin.Context, key string, defaultValue int) (int, error) <span class="cov0" title="0">{
        valueStr := c.Query(key)
        if valueStr == "" </span><span class="cov0" title="0">{
                return defaultValue, nil
        }</span>

        <span class="cov0" title="0">value, err := strconv.Atoi(valueStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return value, nil</span>
}

func (h *MCPHandler) handleError(c *gin.Context, err error) <span class="cov0" title="0">{
        if mcpErr, ok := err.(*MCPError); ok </span><span class="cov0" title="0">{
                c.JSON(mcpErr.HTTPCode, mcpErr)
                return
        }</span>

        <span class="cov0" title="0">internalErr := NewInternalServerError(err.Error())
        c.JSON(internalErr.HTTPCode, internalErr)</span>
}

func (h *MCPHandler) RegisterRoutes(r *gin.RouterGroup) <span class="cov0" title="0">{
        api := r.Group("/mcp")
        </span><span class="cov0" title="0">{
                nodes := api.Group("/nodes")
                </span><span class="cov0" title="0">{
                        nodes.GET("", h.ListNodes)
                        nodes.POST("", h.CreateNode)
                        nodes.POST("/find", h.FindNodeByURL)
                        nodes.POST("/batch", h.BatchGetNodes)
                        nodes.POST("/batch/create", h.BatchCreateNodes)
                        nodes.PUT("/batch/update", h.BatchUpdateNodes)
                        nodes.DELETE("/batch/delete", h.BatchDeleteNodes)
                        nodes.GET("/:composite_id", h.GetNode)
                        nodes.PUT("/:composite_id", h.UpdateNode)
                        nodes.DELETE("/:composite_id", h.DeleteNode)

                        nodes.GET("/:composite_id/attributes", h.GetNodeAttributes)
                        nodes.PUT("/:composite_id/attributes", h.SetNodeAttributes)
                        nodes.POST("/:composite_id/attributes", h.AddNodeAttribute)
                        nodes.DELETE("/:composite_id/attributes/:attribute_name", h.RemoveNodeAttribute)
                        nodes.PUT("/attributes/batch", h.BatchSetNodeAttributes)
                }</span>

                <span class="cov0" title="0">domains := api.Group("/domains")
                </span><span class="cov0" title="0">{
                        domains.GET("", h.ListDomains)
                        domains.POST("", h.CreateDomain)
                        domains.GET("/search", h.SearchDomains)
                        domains.GET("/popular", h.GetPopularDomains)
                        domains.GET("/:domain_name", h.GetDomain)
                        domains.PUT("/:domain_name", h.UpdateDomain)
                        domains.DELETE("/:domain_name", h.DeleteDomain)
                        domains.GET("/:domain_name/stats", h.GetDomainStats)
                }</span>

                <span class="cov0" title="0">server := api.Group("/server")
                </span><span class="cov0" title="0">{
                        server.GET("/info", h.GetServerInfo)
                        server.GET("/info/detailed", h.GetDetailedServerInfo)
                        server.GET("/health", h.GetHealthStatus)
                        server.GET("/stats", h.GetStatistics)
                        server.GET("/docs", h.GetAPIDocumentation)
                }</span>
        }
}

func (h *MCPHandler) corsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func (h *MCPHandler) loggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery

                c.Next()

                latency := time.Since(start)
                clientIP := c.ClientIP()
                method := c.Request.Method
                statusCode := c.Writer.Status()

                if raw != "" </span><span class="cov0" title="0">{
                        path = path + "?" + raw
                }</span>

                <span class="cov0" title="0">log.Printf("[%s] %s %s %d %v",
                        clientIP,
                        method,
                        path,
                        statusCode,
                        latency,
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package mcp

import (
        "encoding/json"
        "fmt"
)

// JSON-RPC 2.0 프로토콜 구조체 정의

// JSONRPCRequest represents a JSON-RPC 2.0 request
type JSONRPCRequest struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id,omitempty"`
        Method  string      `json:"method"`
        Params  interface{} `json:"params,omitempty"`
}

// JSONRPCResponse represents a JSON-RPC 2.0 response
type JSONRPCResponse struct {
        JSONRPC string        `json:"jsonrpc"`
        ID      interface{}   `json:"id,omitempty"`
        Result  interface{}   `json:"result,omitempty"`
        Error   *JSONRPCError `json:"error,omitempty"`
}

// JSONRPCError represents a JSON-RPC 2.0 error
type JSONRPCError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// JSON-RPC 2.0 error codes
const (
        ParseError     = -32700
        InvalidRequest = -32600
        MethodNotFound = -32601
        InvalidParams  = -32602
        InternalError  = -32603
)

// MCP Protocol Structures

// InitializeRequest represents the MCP initialize request
type InitializeRequest struct {
        ProtocolVersion string             `json:"protocolVersion"`
        Capabilities    ClientCapabilities `json:"capabilities"`
        ClientInfo      ClientInfo         `json:"clientInfo"`
}

// ClientCapabilities represents client capabilities
type ClientCapabilities struct {
        Experimental map[string]interface{} `json:"experimental,omitempty"`
        Sampling     map[string]interface{} `json:"sampling,omitempty"`
}

// ClientInfo represents client information
type ClientInfo struct {
        Name    string `json:"name"`
        Version string `json:"version"`
}

// InitializeResult represents the MCP initialize response
type InitializeResult struct {
        ProtocolVersion string             `json:"protocolVersion"`
        Capabilities    ServerCapabilities `json:"capabilities"`
        ServerInfo      ServerInfo         `json:"serverInfo"`
}

// ServerCapabilities represents server capabilities
type ServerCapabilities struct {
        Experimental map[string]interface{} `json:"experimental,omitempty"`
        Logging      map[string]interface{} `json:"logging,omitempty"`
        Prompts      *PromptsCapability     `json:"prompts,omitempty"`
        Resources    *ResourcesCapability   `json:"resources,omitempty"`
        Tools        *ToolsCapability       `json:"tools,omitempty"`
}

// PromptsCapability represents prompts capability
type PromptsCapability struct {
        ListChanged bool `json:"listChanged,omitempty"`
}

// ResourcesCapability represents resources capability
type ResourcesCapability struct {
        Subscribe   bool `json:"subscribe,omitempty"`
        ListChanged bool `json:"listChanged,omitempty"`
}

// ToolsCapability represents tools capability
type ToolsCapability struct {
        ListChanged bool `json:"listChanged,omitempty"`
}

// ServerInfo represents server information
type ServerInfo struct {
        Name    string `json:"name"`
        Version string `json:"version"`
}

// Tool represents an MCP tool
type Tool struct {
        Name        string      `json:"name"`
        Description string      `json:"description"`
        InputSchema interface{} `json:"inputSchema"`
}

// ToolsListResult represents the tools/list response
type ToolsListResult struct {
        Tools []Tool `json:"tools"`
}

// CallToolRequest represents a tools/call request
type CallToolRequest struct {
        Name      string      `json:"name"`
        Arguments interface{} `json:"arguments,omitempty"`
}

// CallToolResult represents a tools/call response
type CallToolResult struct {
        Content []Content `json:"content"`
        IsError bool      `json:"isError,omitempty"`
}

// Content represents tool result content
type Content struct {
        Type string `json:"type"`
        Text string `json:"text,omitempty"`
}

// Resource represents an MCP resource
type Resource struct {
        URI         string `json:"uri"`
        Name        string `json:"name"`
        Description string `json:"description,omitempty"`
        MimeType    string `json:"mimeType,omitempty"`
}

// ResourcesListResult represents the resources/list response
type ResourcesListResult struct {
        Resources []Resource `json:"resources"`
}

// ReadResourceRequest represents a resources/read request
type ReadResourceRequest struct {
        URI string `json:"uri"`
}

// ReadResourceResult represents a resources/read response
type ReadResourceResult struct {
        Contents []ResourceContent `json:"contents"`
}

// ResourceContent represents resource content
type ResourceContent struct {
        URI      string `json:"uri"`
        MimeType string `json:"mimeType,omitempty"`
        Text     string `json:"text,omitempty"`
        Blob     string `json:"blob,omitempty"`
}

// Helper functions

// NewJSONRPCRequest creates a new JSON-RPC request
func NewJSONRPCRequest(id interface{}, method string, params interface{}) *JSONRPCRequest <span class="cov8" title="1">{
        return &amp;JSONRPCRequest{
                JSONRPC: "2.0",
                ID:      id,
                Method:  method,
                Params:  params,
        }
}</span>

// NewJSONRPCResponse creates a new JSON-RPC response
func NewJSONRPCResponse(id interface{}, result interface{}) *JSONRPCResponse <span class="cov8" title="1">{
        return &amp;JSONRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Result:  result,
        }
}</span>

// NewJSONRPCError creates a new JSON-RPC error response
func NewJSONRPCError(id interface{}, code int, message string, data interface{}) *JSONRPCResponse <span class="cov8" title="1">{
        return &amp;JSONRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error: &amp;JSONRPCError{
                        Code:    code,
                        Message: message,
                        Data:    data,
                },
        }
}</span>

// ParseJSONRPCRequest parses a JSON-RPC request from bytes
func ParseJSONRPCRequest(data []byte) (*JSONRPCRequest, error) <span class="cov8" title="1">{
        var req JSONRPCRequest
        if err := json.Unmarshal(data, &amp;req); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JSON-RPC request: %w", err)
        }</span>

        <span class="cov8" title="1">if req.JSONRPC != "2.0" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid JSON-RPC version: %s", req.JSONRPC)
        }</span>

        <span class="cov8" title="1">return &amp;req, nil</span>
}

// ToJSON converts a JSON-RPC response to JSON bytes
func (r *JSONRPCResponse) ToJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(r)
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package mcp

import (
        "context"
        "runtime"
        "time"
)

type MetadataManager struct {
        version     string
        buildTime   string
        gitCommit   string
        environment string
}

func NewMetadataManager(version, buildTime, gitCommit, environment string) *MetadataManager <span class="cov0" title="0">{
        if version == "" </span><span class="cov0" title="0">{
                version = "1.0.0"
        }</span>
        <span class="cov0" title="0">if buildTime == "" </span><span class="cov0" title="0">{
                buildTime = time.Now().Format(time.RFC3339)
        }</span>
        <span class="cov0" title="0">if gitCommit == "" </span><span class="cov0" title="0">{
                gitCommit = "unknown"
        }</span>
        <span class="cov0" title="0">if environment == "" </span><span class="cov0" title="0">{
                environment = "development"
        }</span>

        <span class="cov0" title="0">return &amp;MetadataManager{
                version:     version,
                buildTime:   buildTime,
                gitCommit:   gitCommit,
                environment: environment,
        }</span>
}

func (mm *MetadataManager) GetServerInfo(ctx context.Context) (*MCPServerInfo, error) <span class="cov0" title="0">{
        return &amp;MCPServerInfo{
                Name:        "url-db",
                Version:     mm.version,
                Description: "URL 데이터베이스 MCP 서버",
                Capabilities: []string{
                        "resources",
                        "tools",
                        "prompts",
                        "sampling",
                },
                CompositeKeyFormat: "url-db:domain_name:id",
        }, nil
}</span>

func (mm *MetadataManager) GetDetailedServerInfo(ctx context.Context) (*DetailedServerInfo, error) <span class="cov0" title="0">{
        return &amp;DetailedServerInfo{
                Name:               "url-db",
                Version:            mm.version,
                Description:        "URL 데이터베이스 MCP 서버",
                BuildTime:          mm.buildTime,
                GitCommit:          mm.gitCommit,
                Environment:        mm.environment,
                GoVersion:          runtime.Version(),
                Platform:           runtime.GOOS + "/" + runtime.GOARCH,
                CompositeKeyFormat: "url-db:domain_name:id",
                Capabilities: []string{
                        "resources",
                        "tools",
                        "prompts",
                        "sampling",
                },
                SupportedOperations: []string{
                        "create_node",
                        "get_node",
                        "update_node",
                        "delete_node",
                        "list_nodes",
                        "find_node_by_url",
                        "batch_get_nodes",
                        "list_domains",
                        "create_domain",
                        "get_node_attributes",
                        "set_node_attributes",
                },
                Limits: ServerLimits{
                        MaxBatchSize:            100,
                        MaxPageSize:             100,
                        MaxURLLength:            2048,
                        MaxTitleLength:          255,
                        MaxDescriptionLength:    1000,
                        MaxDomainNameLength:     50,
                        MaxAttributeValueLength: 2048,
                },
        }, nil
}</span>

func (mm *MetadataManager) GetHealthStatus(ctx context.Context) (*HealthStatus, error) <span class="cov0" title="0">{
        return &amp;HealthStatus{
                Status:    "healthy",
                Timestamp: time.Now(),
                Version:   mm.version,
                Uptime:    time.Since(getStartTime()).String(),
                Checks: map[string]HealthCheck{
                        "database": {
                                Status:  "healthy",
                                Message: "Database connection is healthy",
                        },
                        "memory": {
                                Status:  "healthy",
                                Message: "Memory usage is within normal limits",
                        },
                        "goroutines": {
                                Status:  "healthy",
                                Message: "Goroutine count is normal",
                        },
                },
        }, nil
}</span>

func (mm *MetadataManager) GetAPIDocumentation(ctx context.Context) (*APIDocumentation, error) <span class="cov0" title="0">{
        return &amp;APIDocumentation{
                OpenAPI: "3.0.0",
                Info: APIInfo{
                        Title:       "URL Database MCP API",
                        Description: "MCP (Model Context Protocol) API for URL Database",
                        Version:     mm.version,
                        Contact: APIContact{
                                Name:  "URL Database Team",
                                Email: "support@url-db.com",
                        },
                },
                Servers: []APIServer{
                        {
                                URL:         "/api/mcp",
                                Description: "MCP API Server",
                        },
                },
                Paths: map[string]APIPath{
                        "/nodes": {
                                GET: &amp;APIOperation{
                                        Summary:     "List nodes",
                                        Description: "Get a list of nodes with optional filtering",
                                        Parameters: []APIParameter{
                                                {
                                                        Name:        "domain_name",
                                                        In:          "query",
                                                        Description: "Filter by domain name",
                                                        Required:    false,
                                                        Schema:      APISchema{Type: "string"},
                                                },
                                                {
                                                        Name:        "page",
                                                        In:          "query",
                                                        Description: "Page number",
                                                        Required:    false,
                                                        Schema:      APISchema{Type: "integer", Default: 1},
                                                },
                                                {
                                                        Name:        "size",
                                                        In:          "query",
                                                        Description: "Page size",
                                                        Required:    false,
                                                        Schema:      APISchema{Type: "integer", Default: 20},
                                                },
                                        },
                                },
                                POST: &amp;APIOperation{
                                        Summary:     "Create node",
                                        Description: "Create a new node",
                                        RequestBody: &amp;APIRequestBody{
                                                Description: "Node creation request",
                                                Content: map[string]APIMediaType{
                                                        "application/json": {
                                                                Schema: APISchema{
                                                                        Type: "object",
                                                                        Properties: map[string]APISchema{
                                                                                "domain_name": {Type: "string", Description: "Domain name"},
                                                                                "url":         {Type: "string", Description: "URL"},
                                                                                "title":       {Type: "string", Description: "Title"},
                                                                                "description": {Type: "string", Description: "Description"},
                                                                        },
                                                                        Required: []string{"domain_name", "url"},
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "/nodes/{composite_id}": {
                                GET: &amp;APIOperation{
                                        Summary:     "Get node",
                                        Description: "Get a node by composite ID",
                                        Parameters: []APIParameter{
                                                {
                                                        Name:        "composite_id",
                                                        In:          "path",
                                                        Description: "Composite ID in format 'url-db:domain_name:id'",
                                                        Required:    true,
                                                        Schema:      APISchema{Type: "string"},
                                                },
                                        },
                                },
                                PUT: &amp;APIOperation{
                                        Summary:     "Update node",
                                        Description: "Update a node by composite ID",
                                        Parameters: []APIParameter{
                                                {
                                                        Name:        "composite_id",
                                                        In:          "path",
                                                        Description: "Composite ID in format 'url-db:domain_name:id'",
                                                        Required:    true,
                                                        Schema:      APISchema{Type: "string"},
                                                },
                                        },
                                },
                                DELETE: &amp;APIOperation{
                                        Summary:     "Delete node",
                                        Description: "Delete a node by composite ID",
                                        Parameters: []APIParameter{
                                                {
                                                        Name:        "composite_id",
                                                        In:          "path",
                                                        Description: "Composite ID in format 'url-db:domain_name:id'",
                                                        Required:    true,
                                                        Schema:      APISchema{Type: "string"},
                                                },
                                        },
                                },
                        },
                },
        }, nil
}</span>

func (mm *MetadataManager) GetStatistics(ctx context.Context) (*ServerStatistics, error) <span class="cov0" title="0">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        return &amp;ServerStatistics{
                Version:   mm.version,
                Uptime:    time.Since(getStartTime()).String(),
                Timestamp: time.Now(),
                Runtime: RuntimeStats{
                        GoVersion:    runtime.Version(),
                        NumGoroutine: runtime.NumGoroutine(),
                        NumCPU:       runtime.NumCPU(),
                        MemoryStats: MemoryStats{
                                Alloc:        memStats.Alloc,
                                TotalAlloc:   memStats.TotalAlloc,
                                Sys:          memStats.Sys,
                                NumGC:        memStats.NumGC,
                                HeapAlloc:    memStats.HeapAlloc,
                                HeapSys:      memStats.HeapSys,
                                HeapInuse:    memStats.HeapInuse,
                                HeapReleased: memStats.HeapReleased,
                        },
                },
        }, nil
}</span>

var startTime = time.Now()

func getStartTime() time.Time <span class="cov0" title="0">{
        return startTime
}</span>

type DetailedServerInfo struct {
        Name                string       `json:"name"`
        Version             string       `json:"version"`
        Description         string       `json:"description"`
        BuildTime           string       `json:"build_time"`
        GitCommit           string       `json:"git_commit"`
        Environment         string       `json:"environment"`
        GoVersion           string       `json:"go_version"`
        Platform            string       `json:"platform"`
        CompositeKeyFormat  string       `json:"composite_key_format"`
        Capabilities        []string     `json:"capabilities"`
        SupportedOperations []string     `json:"supported_operations"`
        Limits              ServerLimits `json:"limits"`
}

type ServerLimits struct {
        MaxBatchSize            int `json:"max_batch_size"`
        MaxPageSize             int `json:"max_page_size"`
        MaxURLLength            int `json:"max_url_length"`
        MaxTitleLength          int `json:"max_title_length"`
        MaxDescriptionLength    int `json:"max_description_length"`
        MaxDomainNameLength     int `json:"max_domain_name_length"`
        MaxAttributeValueLength int `json:"max_attribute_value_length"`
}

type HealthStatus struct {
        Status    string                 `json:"status"`
        Timestamp time.Time              `json:"timestamp"`
        Version   string                 `json:"version"`
        Uptime    string                 `json:"uptime"`
        Checks    map[string]HealthCheck `json:"checks"`
}

type HealthCheck struct {
        Status  string `json:"status"`
        Message string `json:"message"`
}

type APIDocumentation struct {
        OpenAPI string             `json:"openapi"`
        Info    APIInfo            `json:"info"`
        Servers []APIServer        `json:"servers"`
        Paths   map[string]APIPath `json:"paths"`
}

type APIInfo struct {
        Title       string     `json:"title"`
        Description string     `json:"description"`
        Version     string     `json:"version"`
        Contact     APIContact `json:"contact"`
}

type APIContact struct {
        Name  string `json:"name"`
        Email string `json:"email"`
}

type APIServer struct {
        URL         string `json:"url"`
        Description string `json:"description"`
}

type APIPath struct {
        GET    *APIOperation `json:"get,omitempty"`
        POST   *APIOperation `json:"post,omitempty"`
        PUT    *APIOperation `json:"put,omitempty"`
        DELETE *APIOperation `json:"delete,omitempty"`
}

type APIOperation struct {
        Summary     string          `json:"summary"`
        Description string          `json:"description"`
        Parameters  []APIParameter  `json:"parameters,omitempty"`
        RequestBody *APIRequestBody `json:"requestBody,omitempty"`
}

type APIParameter struct {
        Name        string    `json:"name"`
        In          string    `json:"in"`
        Description string    `json:"description"`
        Required    bool      `json:"required"`
        Schema      APISchema `json:"schema"`
}

type APIRequestBody struct {
        Description string                  `json:"description"`
        Content     map[string]APIMediaType `json:"content"`
}

type APIMediaType struct {
        Schema APISchema `json:"schema"`
}

type APISchema struct {
        Type        string               `json:"type"`
        Properties  map[string]APISchema `json:"properties,omitempty"`
        Required    []string             `json:"required,omitempty"`
        Description string               `json:"description,omitempty"`
        Default     interface{}          `json:"default,omitempty"`
}

type ServerStatistics struct {
        Version   string       `json:"version"`
        Uptime    string       `json:"uptime"`
        Timestamp time.Time    `json:"timestamp"`
        Runtime   RuntimeStats `json:"runtime"`
}

type RuntimeStats struct {
        GoVersion    string      `json:"go_version"`
        NumGoroutine int         `json:"num_goroutine"`
        NumCPU       int         `json:"num_cpu"`
        MemoryStats  MemoryStats `json:"memory_stats"`
}

type MemoryStats struct {
        Alloc        uint64 `json:"alloc"`
        TotalAlloc   uint64 `json:"total_alloc"`
        Sys          uint64 `json:"sys"`
        NumGC        uint32 `json:"num_gc"`
        HeapAlloc    uint64 `json:"heap_alloc"`
        HeapSys      uint64 `json:"heap_sys"`
        HeapInuse    uint64 `json:"heap_inuse"`
        HeapReleased uint64 `json:"heap_released"`
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package mcp

import (
        "context"
        "fmt"

        "url-db/internal/models"
)

// Node operation methods for mcpService

func (s *mcpService) CreateNode(ctx context.Context, req *models.CreateMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        domain, err := s.domainService.GetDomainByName(ctx, req.DomainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(req.DomainName)
        }</span>

        <span class="cov0" title="0">nodeReq := s.converter.CreateMCPNodeRequestToCreateNodeRequest(req)
        node, err := s.nodeService.CreateNode(ctx, domain.ID, nodeReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to create node: %v", err))
        }</span>

        <span class="cov0" title="0">return s.converter.NodeToMCPNode(node, domain)</span>
}

func (s *mcpService) GetNode(ctx context.Context, compositeID string) (*models.MCPNode, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := s.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">node, err := s.nodeService.GetNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewResourceNotFoundError(compositeID)
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">return s.converter.NodeToMCPNode(node, domain)</span>
}

func (s *mcpService) UpdateNode(ctx context.Context, compositeID string, req *models.UpdateNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">domainName, err := s.converter.ExtractDomainNameFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">node, err := s.nodeService.UpdateNode(ctx, nodeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to update node: %v", err))
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        <span class="cov0" title="0">return s.converter.NodeToMCPNode(node, domain)</span>
}

func (s *mcpService) DeleteNode(ctx context.Context, compositeID string) error <span class="cov0" title="0">{
        if err := s.converter.ValidateCompositeID(compositeID); err != nil </span><span class="cov0" title="0">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">nodeID, err := s.converter.ExtractNodeIDFromCompositeID(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return NewInvalidCompositeKeyError(compositeID)
        }</span>

        <span class="cov0" title="0">if err := s.nodeService.DeleteNode(ctx, nodeID); err != nil </span><span class="cov0" title="0">{
                return NewInternalServerError(fmt.Sprintf("failed to delete node: %v", err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *mcpService) ListNodes(ctx context.Context, domainName string, page, size int, search string) (*models.MCPNodeListResponse, error) <span class="cov0" title="0">{
        var domainID int
        var domain *models.Domain
        var err error

        if domainName != "" </span><span class="cov0" title="0">{
                domain, err = s.domainService.GetDomainByName(ctx, domainName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainName)
                }</span>
                <span class="cov0" title="0">domainID = domain.ID</span>
        }

        <span class="cov0" title="0">response, err := s.nodeService.ListNodes(ctx, domainID, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list nodes: %v", err))
        }</span>

        <span class="cov0" title="0">mcpNodes := make([]models.MCPNode, 0, len(response.Nodes))
        for _, node := range response.Nodes </span><span class="cov0" title="0">{
                if domain == nil </span><span class="cov0" title="0">{
                        domain, err = s.domainService.GetDomain(ctx, node.DomainID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">mcpNode, err := s.converter.NodeToMCPNode(&amp;node, domain)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">mcpNodes = append(mcpNodes, *mcpNode)</span>
        }

        <span class="cov0" title="0">return &amp;models.MCPNodeListResponse{
                Nodes:      mcpNodes,
                TotalCount: response.TotalCount,
                Page:       response.Page,
                Size:       response.Size,
                TotalPages: response.TotalPages,
        }, nil</span>
}

func (s *mcpService) FindNodeByURL(ctx context.Context, req *models.FindMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        domain, err := s.domainService.GetDomainByName(ctx, req.DomainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(req.DomainName)
        }</span>

        <span class="cov0" title="0">findReq := &amp;models.FindNodeByURLRequest{URL: req.URL}
        node, err := s.nodeService.FindNodeByURL(ctx, domain.ID, findReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewNodeNotFoundError(req.DomainName, req.URL)
        }</span>

        <span class="cov0" title="0">return s.converter.NodeToMCPNode(node, domain)</span>
}

func (s *mcpService) BatchGetNodes(ctx context.Context, req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error) <span class="cov0" title="0">{
        nodes := make([]models.MCPNode, 0, len(req.CompositeIDs))
        notFound := make([]string, 0)

        for _, compositeID := range req.CompositeIDs </span><span class="cov0" title="0">{
                node, err := s.GetNode(ctx, compositeID)
                if err != nil </span><span class="cov0" title="0">{
                        notFound = append(notFound, compositeID)
                        continue</span>
                }
                <span class="cov0" title="0">nodes = append(nodes, *node)</span>
        }

        <span class="cov0" title="0">return &amp;models.BatchMCPNodeResponse{
                Nodes:    nodes,
                NotFound: notFound,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package mcp

import (
        "context"
        "fmt"
        "strings"

        "url-db/internal/models"
)

// Query operation methods for mcpService - enhanced query capabilities

func (s *mcpService) FilterNodesByAttributes(ctx context.Context, domainName string, filters []interface{}, page, size int) (*models.MCPNodeListResponse, error) <span class="cov0" title="0">{
        // Get domain
        domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewDomainNotFoundError(domainName)
        }</span>

        // Get all nodes in the domain first
        <span class="cov0" title="0">response, err := s.nodeService.ListNodes(ctx, domain.ID, 1, 1000, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInternalServerError(fmt.Sprintf("failed to list nodes: %v", err))
        }</span>

        // Filter nodes based on attributes
        <span class="cov0" title="0">var filteredNodes []models.MCPNode
        for _, node := range response.Nodes </span><span class="cov0" title="0">{
                // Get node attributes
                nodeAttrs, err := s.attributeService.GetNodeAttributes(ctx, node.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if node matches all filters
                <span class="cov0" title="0">matches := true
                for _, filterInterface := range filters </span><span class="cov0" title="0">{
                        filterMap, ok := filterInterface.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                // Try struct conversion
                                filterStruct, ok := filterInterface.(struct {
                                        Name     string `json:"name"`
                                        Value    string `json:"value"`
                                        Operator string `json:"operator"`
                                })
                                if ok </span><span class="cov0" title="0">{
                                        filterMap = map[string]interface{}{
                                                "name":     filterStruct.Name,
                                                "value":    filterStruct.Value,
                                                "operator": filterStruct.Operator,
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        continue</span>
                                }
                        }

                        <span class="cov0" title="0">filterName, _ := filterMap["name"].(string)
                        filterValue, _ := filterMap["value"].(string)
                        filterOperator, _ := filterMap["operator"].(string)

                        if filterName == "" || filterValue == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check if node has this attribute with matching value
                        <span class="cov0" title="0">attrFound := false
                        for _, attr := range nodeAttrs </span><span class="cov0" title="0">{
                                if attr.Name == filterName </span><span class="cov0" title="0">{
                                        switch filterOperator </span>{
                                        case "equals":<span class="cov0" title="0">
                                                if attr.Value == filterValue </span><span class="cov0" title="0">{
                                                        attrFound = true
                                                }</span>
                                        case "contains":<span class="cov0" title="0">
                                                if strings.Contains(attr.Value, filterValue) </span><span class="cov0" title="0">{
                                                        attrFound = true
                                                }</span>
                                        case "starts_with":<span class="cov0" title="0">
                                                if strings.HasPrefix(attr.Value, filterValue) </span><span class="cov0" title="0">{
                                                        attrFound = true
                                                }</span>
                                        case "ends_with":<span class="cov0" title="0">
                                                if strings.HasSuffix(attr.Value, filterValue) </span><span class="cov0" title="0">{
                                                        attrFound = true
                                                }</span>
                                        }
                                        <span class="cov0" title="0">break</span>
                                }
                        }

                        <span class="cov0" title="0">if !attrFound </span><span class="cov0" title="0">{
                                matches = false
                                break</span>
                        }
                }

                <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
                        mcpNode, err := s.converter.NodeToMCPNode(&amp;node, domain)
                        if err == nil </span><span class="cov0" title="0">{
                                filteredNodes = append(filteredNodes, *mcpNode)
                        }</span>
                }
        }

        // Apply pagination
        <span class="cov0" title="0">start := (page - 1) * size
        end := start + size
        if start &gt; len(filteredNodes) </span><span class="cov0" title="0">{
                start = len(filteredNodes)
        }</span>
        <span class="cov0" title="0">if end &gt; len(filteredNodes) </span><span class="cov0" title="0">{
                end = len(filteredNodes)
        }</span>

        <span class="cov0" title="0">paginatedNodes := filteredNodes[start:end]

        return &amp;models.MCPNodeListResponse{
                Nodes:      paginatedNodes,
                TotalCount: len(filteredNodes),
                Page:       page,
                Size:       size,
                TotalPages: (len(filteredNodes) + size - 1) / size,
        }, nil</span>
}

func (s *mcpService) GetServerInfo(ctx context.Context) (*MCPServerInfo, error) <span class="cov0" title="0">{
        return &amp;MCPServerInfo{
                Name:        "url-db",
                Version:     "1.0.0",
                Description: "URL 데이터베이스 MCP 서버",
                Capabilities: []string{
                        "resources",
                        "tools",
                        "prompts",
                },
                CompositeKeyFormat: "url-db:domain_name:id",
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">package mcp

import (
        "context"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

// MCP Resource 정의 및 구현

// ResourceRegistry manages all available MCP resources
type ResourceRegistry struct {
        service MCPService
}

// NewResourceRegistry creates a new resource registry
func NewResourceRegistry(service MCPService) *ResourceRegistry <span class="cov8" title="1">{
        return &amp;ResourceRegistry{
                service: service,
        }
}</span>

// GetResources returns all available resources
func (rr *ResourceRegistry) GetResources(ctx context.Context) (*ResourcesListResult, error) <span class="cov8" title="1">{
        // Get all domains to generate resource URIs
        domainsResponse, err := rr.service.ListDomains(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list domains: %w", err)
        }</span>

        <span class="cov8" title="1">var resources []Resource

        // Add server info resource
        resources = append(resources, Resource{
                URI:         "mcp://server/info",
                Name:        "Server Information",
                Description: "URL Database server information and capabilities",
                MimeType:    "application/json",
        })

        // Add domain resources
        for _, domain := range domainsResponse.Domains </span><span class="cov8" title="1">{
                // Domain resource
                resources = append(resources, Resource{
                        URI:         fmt.Sprintf("mcp://domains/%s", domain.Name),
                        Name:        fmt.Sprintf("Domain: %s", domain.Name),
                        Description: fmt.Sprintf("Domain information for %s", domain.Name),
                        MimeType:    "application/json",
                })

                // Domain nodes resource
                resources = append(resources, Resource{
                        URI:         fmt.Sprintf("mcp://domains/%s/nodes", domain.Name),
                        Name:        fmt.Sprintf("Nodes in %s", domain.Name),
                        Description: fmt.Sprintf("List of all nodes in domain %s", domain.Name),
                        MimeType:    "application/json",
                })
        }</span>

        <span class="cov8" title="1">return &amp;ResourcesListResult{
                Resources: resources,
        }, nil</span>
}

// ReadResource reads a specific resource by URI
func (rr *ResourceRegistry) ReadResource(ctx context.Context, uri string) (*ReadResourceResult, error) <span class="cov8" title="1">{
        // Parse the URI to determine resource type
        if uri == "mcp://server/info" </span><span class="cov8" title="1">{
                return rr.readServerInfo(ctx)
        }</span>

        // Match domain resource pattern: mcp://domains/{domain_name}
        <span class="cov8" title="1">domainPattern := regexp.MustCompile(`^mcp://domains/([^/]+)$`)
        if matches := domainPattern.FindStringSubmatch(uri); len(matches) == 2 </span><span class="cov8" title="1">{
                domainName := matches[1]
                return rr.readDomainInfo(ctx, domainName)
        }</span>

        // Match domain nodes pattern: mcp://domains/{domain_name}/nodes
        <span class="cov8" title="1">domainNodesPattern := regexp.MustCompile(`^mcp://domains/([^/]+)/nodes$`)
        if matches := domainNodesPattern.FindStringSubmatch(uri); len(matches) == 2 </span><span class="cov8" title="1">{
                domainName := matches[1]
                return rr.readDomainNodes(ctx, domainName)
        }</span>

        // Match individual node pattern: mcp://nodes/{composite_id}
        <span class="cov8" title="1">nodePattern := regexp.MustCompile(`^mcp://nodes/(.+)$`)
        if matches := nodePattern.FindStringSubmatch(uri); len(matches) == 2 </span><span class="cov8" title="1">{
                compositeID := matches[1]
                return rr.readNodeInfo(ctx, compositeID)
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("unknown resource URI: %s", uri)</span>
}

// readServerInfo reads server information
func (rr *ResourceRegistry) readServerInfo(ctx context.Context) (*ReadResourceResult, error) <span class="cov8" title="1">{
        info, err := rr.service.GetServerInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get server info: %w", err)
        }</span>

        <span class="cov8" title="1">content, err := json.MarshalIndent(info, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal server info: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ReadResourceResult{
                Contents: []ResourceContent{{
                        URI:      "mcp://server/info",
                        MimeType: "application/json",
                        Text:     string(content),
                }},
        }, nil</span>
}

// readDomainInfo reads domain information
func (rr *ResourceRegistry) readDomainInfo(ctx context.Context, domainName string) (*ReadResourceResult, error) <span class="cov8" title="1">{
        // Get domain info by listing all domains and finding the one we want
        domainsResponse, err := rr.service.ListDomains(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list domains: %w", err)
        }</span>

        <span class="cov8" title="1">var targetDomain *MCPDomain
        for _, domain := range domainsResponse.Domains </span><span class="cov8" title="1">{
                if domain.Name == domainName </span><span class="cov8" title="1">{
                        targetDomain = &amp;domain
                        break</span>
                }
        }

        <span class="cov8" title="1">if targetDomain == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("domain not found: %s", domainName)
        }</span>

        <span class="cov8" title="1">content, err := json.MarshalIndent(targetDomain, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal domain info: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ReadResourceResult{
                Contents: []ResourceContent{{
                        URI:      fmt.Sprintf("mcp://domains/%s", domainName),
                        MimeType: "application/json",
                        Text:     string(content),
                }},
        }, nil</span>
}

// readDomainNodes reads all nodes in a domain
func (rr *ResourceRegistry) readDomainNodes(ctx context.Context, domainName string) (*ReadResourceResult, error) <span class="cov8" title="1">{
        // Get first page of nodes (we might want to implement pagination later)
        nodesResponse, err := rr.service.ListNodes(ctx, domainName, 1, 100, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list nodes for domain %s: %w", domainName, err)
        }</span>

        <span class="cov8" title="1">content, err := json.MarshalIndent(nodesResponse, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal nodes: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ReadResourceResult{
                Contents: []ResourceContent{{
                        URI:      fmt.Sprintf("mcp://domains/%s/nodes", domainName),
                        MimeType: "application/json",
                        Text:     string(content),
                }},
        }, nil</span>
}

// readNodeInfo reads individual node information
func (rr *ResourceRegistry) readNodeInfo(ctx context.Context, compositeID string) (*ReadResourceResult, error) <span class="cov8" title="1">{
        // Get node info
        node, err := rr.service.GetNode(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node %s: %w", compositeID, err)
        }</span>

        // Also get node attributes
        <span class="cov8" title="1">attributes, err := rr.service.GetNodeAttributes(ctx, compositeID)
        if err != nil </span><span class="cov8" title="1">{
                // Don't fail if attributes can't be fetched, just log it
                attributes = nil
        }</span>

        // Combine node info and attributes
        <span class="cov8" title="1">result := map[string]interface{}{
                "node":       node,
                "attributes": attributes,
        }

        content, err := json.MarshalIndent(result, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal node info: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ReadResourceResult{
                Contents: []ResourceContent{{
                        URI:      fmt.Sprintf("mcp://nodes/%s", compositeID),
                        MimeType: "application/json",
                        Text:     string(content),
                }},
        }, nil</span>
}

// Helper function to validate resource URI format
func (rr *ResourceRegistry) validateURI(uri string) error <span class="cov8" title="1">{
        if !strings.HasPrefix(uri, "mcp://") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid URI scheme, must start with 'mcp://'")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package mcp

import (
        "context"

        "url-db/internal/models"
)

type MCPService interface {
        CreateNode(ctx context.Context, req *models.CreateMCPNodeRequest) (*models.MCPNode, error)
        GetNode(ctx context.Context, compositeID string) (*models.MCPNode, error)
        UpdateNode(ctx context.Context, compositeID string, req *models.UpdateNodeRequest) (*models.MCPNode, error)
        DeleteNode(ctx context.Context, compositeID string) error
        ListNodes(ctx context.Context, domainName string, page, size int, search string) (*models.MCPNodeListResponse, error)
        FindNodeByURL(ctx context.Context, req *models.FindMCPNodeRequest) (*models.MCPNode, error)
        BatchGetNodes(ctx context.Context, req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error)

        ListDomains(ctx context.Context) (*MCPDomainListResponse, error)
        CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*MCPDomain, error)

        GetNodeAttributes(ctx context.Context, compositeID string) (*models.MCPNodeAttributeResponse, error)
        SetNodeAttributes(ctx context.Context, compositeID string, req *models.SetMCPNodeAttributesRequest) (*models.MCPNodeAttributeResponse, error)
        FilterNodesByAttributes(ctx context.Context, domainName string, filters []interface{}, page, size int) (*models.MCPNodeListResponse, error)

        // Domain attribute management methods
        ListDomainAttributes(ctx context.Context, domainName string) (*models.MCPDomainAttributeListResponse, error)
        CreateDomainAttribute(ctx context.Context, domainName string, req *models.CreateAttributeRequest) (*models.MCPDomainAttribute, error)
        GetDomainAttribute(ctx context.Context, compositeID string) (*models.MCPDomainAttribute, error)
        UpdateDomainAttribute(ctx context.Context, compositeID string, req *models.UpdateAttributeRequest) (*models.MCPDomainAttribute, error)
        DeleteDomainAttribute(ctx context.Context, compositeID string) error

        GetServerInfo(ctx context.Context) (*MCPServerInfo, error)

        // External dependency management methods
        CreateSubscription(ctx context.Context, req *MCPCreateSubscriptionRequest) (*models.NodeSubscription, error)
        ListSubscriptions(ctx context.Context, serviceName string, page, size int) (*MCPSubscriptionListResponse, error)
        GetNodeSubscriptions(ctx context.Context, compositeID string) ([]*models.NodeSubscription, error)
        DeleteSubscription(ctx context.Context, subscriptionID int64) error

        CreateDependency(ctx context.Context, req *MCPCreateDependencyRequest) (*models.NodeDependency, error)
        ListNodeDependencies(ctx context.Context, compositeID string) ([]*models.NodeDependency, error)
        ListNodeDependents(ctx context.Context, compositeID string) ([]*models.NodeDependency, error)
        DeleteDependency(ctx context.Context, dependencyID int64) error

        GetNodeEvents(ctx context.Context, compositeID string, limit int) ([]*models.NodeEvent, error)
        GetPendingEvents(ctx context.Context, limit int) ([]*models.NodeEvent, error)
        ProcessEvent(ctx context.Context, eventID int64) error
        GetEventStats(ctx context.Context) (map[string]interface{}, error)
}

type NodeService interface {
        CreateNode(ctx context.Context, domainID int, req *models.CreateNodeRequest) (*models.Node, error)
        GetNode(ctx context.Context, nodeID int) (*models.Node, error)
        UpdateNode(ctx context.Context, nodeID int, req *models.UpdateNodeRequest) (*models.Node, error)
        DeleteNode(ctx context.Context, nodeID int) error
        ListNodes(ctx context.Context, domainID int, page, size int, search string) (*models.NodeListResponse, error)
        FindNodeByURL(ctx context.Context, domainID int, req *models.FindNodeByURLRequest) (*models.Node, error)
}

type DomainService interface {
        CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*models.Domain, error)
        GetDomain(ctx context.Context, domainID int) (*models.Domain, error)
        GetDomainByName(ctx context.Context, name string) (*models.Domain, error)
        ListDomains(ctx context.Context, page, size int) (*models.DomainListResponse, error)
        UpdateDomain(ctx context.Context, domainID int, req *models.UpdateDomainRequest) (*models.Domain, error)
        DeleteDomain(ctx context.Context, domainID int) error
}

type AttributeService interface {
        GetNodeAttributes(ctx context.Context, nodeID int) ([]models.NodeAttributeWithInfo, error)
        SetNodeAttribute(ctx context.Context, nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttributeWithInfo, error)
        GetAttributeByName(ctx context.Context, domainID int, name string) (*models.Attribute, error)
        DeleteNodeAttribute(ctx context.Context, nodeID, attributeID int) error

        // Domain attribute management methods
        ListAttributes(ctx context.Context, domainID int) (*models.AttributeListResponse, error)
        CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error)
        GetAttribute(ctx context.Context, id int) (*models.Attribute, error)
        UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error)
        DeleteAttribute(ctx context.Context, id int) error
}

type NodeCountService interface {
        GetNodeCountByDomain(ctx context.Context, domainID int) (int, error)
}

type SubscriptionService interface {
        CreateSubscription(nodeID int64, req *models.CreateNodeSubscriptionRequest) (*models.NodeSubscription, error)
        GetServiceSubscriptions(service string) ([]*models.NodeSubscription, error)
        GetAllSubscriptions(page, pageSize int) ([]*models.NodeSubscription, int, error)
        GetNodeSubscriptions(nodeID int64) ([]*models.NodeSubscription, error)
        DeleteSubscription(id int64) error
}

type DependencyService interface {
        CreateDependency(dependentNodeID int64, req *models.CreateNodeDependencyRequest) (*models.NodeDependency, error)
        GetNodeDependencies(nodeID int64) ([]*models.NodeDependency, error)
        GetNodeDependents(nodeID int64) ([]*models.NodeDependency, error)
        DeleteDependency(id int64) error
}

type EventService interface {
        GetNodeEvents(nodeID int64, limit int) ([]*models.NodeEvent, error)
        GetPendingEvents(limit int) ([]*models.NodeEvent, error)
        ProcessEvent(eventID int64) error
        GetEventStats() (map[string]interface{}, error)
}

type mcpService struct {
        nodeService         NodeService
        domainService       DomainService
        attributeService    AttributeService
        nodeCountService    NodeCountService
        subscriptionService SubscriptionService
        dependencyService   DependencyService
        eventService        EventService
        converter           *Converter
}

func NewMCPService(
        nodeService NodeService,
        domainService DomainService,
        attributeService AttributeService,
        nodeCountService NodeCountService,
        subscriptionService SubscriptionService,
        dependencyService DependencyService,
        eventService EventService,
        converter *Converter,
) MCPService <span class="cov0" title="0">{
        return &amp;mcpService{
                nodeService:         nodeService,
                domainService:       domainService,
                attributeService:    attributeService,
                nodeCountService:    nodeCountService,
                subscriptionService: subscriptionService,
                dependencyService:   dependencyService,
                eventService:        eventService,
                converter:           converter,
        }
}</span>

// Node operations are in node_operations.go
// Domain operations are in domain_operations.go
// Attribute operations are in attribute_operations.go
// Query operations are in query_operations.go
</pre>
		
		<pre class="file" id="file118" style="display: none">package mcp

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        "strings"
        "sync"

        "url-db/internal/constants"
)

// StdioServer implements MCP protocol over stdin/stdout with JSON-RPC 2.0
type StdioServer struct {
        service          MCPService
        reader           *bufio.Reader
        writer           io.Writer
        toolRegistry     *ToolRegistry
        resourceRegistry *ResourceRegistry
        initialized      bool
        shutdownOnce     sync.Once
        shutdown         chan struct{}
}

// NewStdioServer creates a new MCP stdio server
func NewStdioServer(service MCPService) *StdioServer <span class="cov0" title="0">{
        return &amp;StdioServer{
                service:          service,
                reader:           bufio.NewReader(os.Stdin),
                writer:           os.Stdout,
                toolRegistry:     NewToolRegistry(service),
                resourceRegistry: NewResourceRegistry(service),
                initialized:      false,
                shutdown:         make(chan struct{}),
        }
}</span>

// Start begins the stdio MCP session with JSON-RPC 2.0 protocol
func (s *StdioServer) Start() error <span class="cov0" title="0">{
        // log.Println("Starting MCP JSON-RPC 2.0 stdio server...") // Disabled for clean JSON output

        for </span><span class="cov0" title="0">{
                line, err := s.reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // log.Println("EOF received, ending session") // Disabled for clean JSON output
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("error reading input: %w", err)</span>
                }

                <span class="cov0" title="0">line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse JSON-RPC request
                <span class="cov0" title="0">req, err := ParseJSONRPCRequest([]byte(line))
                if err != nil </span><span class="cov0" title="0">{
                        // Send parse error response
                        errorResp := NewJSONRPCError(nil, ParseError, constants.ErrParseError, err.Error())
                        s.sendResponse(errorResp)
                        continue</span>
                }

                // Handle the request
                <span class="cov0" title="0">resp := s.handleJSONRPCRequest(req)
                if resp != nil </span><span class="cov0" title="0">{
                        s.sendResponse(resp)
                }</span>
        }
}

// handleJSONRPCRequest processes a JSON-RPC 2.0 request
func (s *StdioServer) handleJSONRPCRequest(req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        ctx := context.Background()

        switch req.Method </span>{
        case "initialize":<span class="cov0" title="0">
                return s.handleInitialize(ctx, req)</span>
        case "notifications/initialized":<span class="cov0" title="0">
                return s.handleInitialized(ctx, req)</span>
        case "tools/list":<span class="cov0" title="0">
                return s.handleToolsList(ctx, req)</span>
        case "tools/call":<span class="cov0" title="0">
                return s.handleToolsCall(ctx, req)</span>
        case "resources/list":<span class="cov0" title="0">
                return s.handleResourcesList(ctx, req)</span>
        case "resources/read":<span class="cov0" title="0">
                return s.handleResourcesRead(ctx, req)</span>
        default:<span class="cov0" title="0">
                return NewJSONRPCError(req.ID, MethodNotFound, fmt.Sprintf(constants.ErrMethodNotFound, req.Method), nil)</span>
        }
}

// Shutdown gracefully shuts down the server
func (s *StdioServer) Shutdown() <span class="cov0" title="0">{
        s.shutdownOnce.Do(func() </span><span class="cov0" title="0">{
                close(s.shutdown)
        }</span>)
}

// sendResponse sends a JSON-RPC response
func (s *StdioServer) sendResponse(resp *JSONRPCResponse) <span class="cov0" title="0">{
        data, err := resp.ToJSON()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling response: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(s.writer, "%s\n", string(data))</span>
}

// handleInitialize handles the MCP initialize request
func (s *StdioServer) handleInitialize(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        // Parse initialize request
        var initReq InitializeRequest
        if req.Params != nil </span><span class="cov0" title="0">{
                paramsData, _ := json.Marshal(req.Params)
                if err := json.Unmarshal(paramsData, &amp;initReq); err != nil </span><span class="cov0" title="0">{
                        return NewJSONRPCError(req.ID, InvalidParams, constants.ErrInvalidInitParams, err.Error())
                }</span>
        }

        // Create response
        <span class="cov0" title="0">result := InitializeResult{
                ProtocolVersion: constants.MCPProtocolVersion,
                Capabilities: ServerCapabilities{
                        Tools: &amp;ToolsCapability{
                                ListChanged: false,
                        },
                        Resources: &amp;ResourcesCapability{
                                Subscribe:   false,
                                ListChanged: false,
                        },
                },
                ServerInfo: ServerInfo{
                        Name:    constants.MCPServerName,
                        Version: constants.DefaultServerVersion,
                },
        }

        return NewJSONRPCResponse(req.ID, result)</span>
}

// handleInitialized handles the MCP initialized notification
func (s *StdioServer) handleInitialized(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        s.initialized = true
        log.Println("MCP server initialized successfully")

        // Notification - no response needed for initialized
        if req.ID == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return NewJSONRPCResponse(req.ID, nil)</span>
}

// handleToolsList handles the tools/list request
func (s *StdioServer) handleToolsList(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        if !s.initialized </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InvalidRequest, constants.ErrServerNotInitialized, nil)
        }</span>

        <span class="cov0" title="0">tools := s.toolRegistry.GetTools()
        result := ToolsListResult{
                Tools: tools,
        }

        return NewJSONRPCResponse(req.ID, result)</span>
}

// handleToolsCall handles the tools/call request
func (s *StdioServer) handleToolsCall(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        if !s.initialized </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InvalidRequest, constants.ErrServerNotInitialized, nil)
        }</span>

        // Parse tool call request
        <span class="cov0" title="0">var callReq CallToolRequest
        if req.Params != nil </span><span class="cov0" title="0">{
                paramsData, _ := json.Marshal(req.Params)
                if err := json.Unmarshal(paramsData, &amp;callReq); err != nil </span><span class="cov0" title="0">{
                        return NewJSONRPCError(req.ID, InvalidParams, constants.ErrInvalidToolCallParams, err.Error())
                }</span>
        }

        // Call the tool
        <span class="cov0" title="0">result, err := s.toolRegistry.CallTool(ctx, callReq.Name, callReq.Arguments)
        if err != nil </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InternalError, constants.ErrToolExecutionFailed, err.Error())
        }</span>

        <span class="cov0" title="0">return NewJSONRPCResponse(req.ID, result)</span>
}

// handleResourcesList handles the resources/list request
func (s *StdioServer) handleResourcesList(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        if !s.initialized </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InvalidRequest, constants.ErrServerNotInitialized, nil)
        }</span>

        <span class="cov0" title="0">result, err := s.resourceRegistry.GetResources(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InternalError, constants.ErrFailedToGetResources, err.Error())
        }</span>

        <span class="cov0" title="0">return NewJSONRPCResponse(req.ID, result)</span>
}

// handleResourcesRead handles the resources/read request
func (s *StdioServer) handleResourcesRead(ctx context.Context, req *JSONRPCRequest) *JSONRPCResponse <span class="cov0" title="0">{
        if !s.initialized </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InvalidRequest, constants.ErrServerNotInitialized, nil)
        }</span>

        // Parse resource read request
        <span class="cov0" title="0">var readReq ReadResourceRequest
        if req.Params != nil </span><span class="cov0" title="0">{
                paramsData, _ := json.Marshal(req.Params)
                if err := json.Unmarshal(paramsData, &amp;readReq); err != nil </span><span class="cov0" title="0">{
                        return NewJSONRPCError(req.ID, InvalidParams, constants.ErrInvalidResourceParams, err.Error())
                }</span>
        }

        // Read the resource
        <span class="cov0" title="0">result, err := s.resourceRegistry.ReadResource(ctx, readReq.URI)
        if err != nil </span><span class="cov0" title="0">{
                return NewJSONRPCError(req.ID, InternalError, constants.ErrFailedToReadResource, err.Error())
        }</span>

        <span class="cov0" title="0">return NewJSONRPCResponse(req.ID, result)</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">// Code generated from mcp-tools.yaml. DO NOT EDIT.
// Generated by scripts/generate-tool-constants.py

package mcp

// MCP Tool Names - Single source of truth
const (
        // Server Information
        ServerName         = "url-db-mcp-server"
        ServerVersion      = "1.0.0"
        CompositeKeyFormat = "url-db:domain:id"

        // Tool Names

        // Domain management operations
        ListDomainsTool  = "list_domains"
        CreateDomainTool = "create_domain"

        // Node/URL CRUD operations
        ListNodesTool     = "list_nodes"
        CreateNodeTool    = "create_node"
        GetNodeTool       = "get_node"
        UpdateNodeTool    = "update_node"
        DeleteNodeTool    = "delete_node"
        FindNodeByUrlTool = "find_node_by_url"

        // Node attribute management
        GetNodeAttributesTool = "get_node_attributes"
        SetNodeAttributesTool = "set_node_attributes"

        // Domain schema management
        ListDomainAttributesTool  = "list_domain_attributes"
        CreateDomainAttributeTool = "create_domain_attribute"
        GetDomainAttributeTool    = "get_domain_attribute"
        UpdateDomainAttributeTool = "update_domain_attribute"
        DeleteDomainAttributeTool = "delete_domain_attribute"

        // Advanced query operations
        GetNodeWithAttributesTool   = "get_node_with_attributes"
        FilterNodesByAttributesTool = "filter_nodes_by_attributes"

        // Event subscription management
        CreateSubscriptionTool   = "create_subscription"
        ListSubscriptionsTool    = "list_subscriptions"
        GetNodeSubscriptionsTool = "get_node_subscriptions"
        DeleteSubscriptionTool   = "delete_subscription"

        // Node dependency management
        CreateDependencyTool     = "create_dependency"
        ListNodeDependenciesTool = "list_node_dependencies"
        ListNodeDependentsTool   = "list_node_dependents"
        DeleteDependencyTool     = "delete_dependency"

        // Event tracking and processing
        GetNodeEventsTool    = "get_node_events"
        GetPendingEventsTool = "get_pending_events"
        ProcessEventTool     = "process_event"
        GetEventStatsTool    = "get_event_stats"

        // Server metadata and information
        GetServerInfoTool = "get_server_info"
)

// GetAllToolNames returns all tool names
func GetAllToolNames() []string <span class="cov0" title="0">{
        return []string{
                ListDomainsTool,
                CreateDomainTool,
                ListNodesTool,
                CreateNodeTool,
                GetNodeTool,
                UpdateNodeTool,
                DeleteNodeTool,
                FindNodeByUrlTool,
                GetNodeAttributesTool,
                SetNodeAttributesTool,
                ListDomainAttributesTool,
                CreateDomainAttributeTool,
                GetDomainAttributeTool,
                UpdateDomainAttributeTool,
                DeleteDomainAttributeTool,
                GetNodeWithAttributesTool,
                FilterNodesByAttributesTool,
                CreateSubscriptionTool,
                ListSubscriptionsTool,
                GetNodeSubscriptionsTool,
                DeleteSubscriptionTool,
                CreateDependencyTool,
                ListNodeDependenciesTool,
                ListNodeDependentsTool,
                DeleteDependencyTool,
                GetNodeEventsTool,
                GetPendingEventsTool,
                ProcessEventTool,
                GetEventStatsTool,
                GetServerInfoTool,
        }
}</span>

// ToolCategories maps tool names to categories
var ToolCategories = map[string]string{
        ListDomainsTool:             "domain",
        CreateDomainTool:            "domain",
        ListNodesTool:               "node",
        CreateNodeTool:              "node",
        GetNodeTool:                 "node",
        UpdateNodeTool:              "node",
        DeleteNodeTool:              "node",
        FindNodeByUrlTool:           "node",
        GetNodeAttributesTool:       "attribute",
        SetNodeAttributesTool:       "attribute",
        ListDomainAttributesTool:    "schema",
        CreateDomainAttributeTool:   "schema",
        GetDomainAttributeTool:      "schema",
        UpdateDomainAttributeTool:   "schema",
        DeleteDomainAttributeTool:   "schema",
        GetNodeWithAttributesTool:   "query",
        FilterNodesByAttributesTool: "query",
        CreateSubscriptionTool:      "subscription",
        ListSubscriptionsTool:       "subscription",
        GetNodeSubscriptionsTool:    "subscription",
        DeleteSubscriptionTool:      "subscription",
        CreateDependencyTool:        "dependency",
        ListNodeDependenciesTool:    "dependency",
        ListNodeDependentsTool:      "dependency",
        DeleteDependencyTool:        "dependency",
        GetNodeEventsTool:           "event",
        GetPendingEventsTool:        "event",
        ProcessEventTool:            "event",
        GetEventStatsTool:           "event",
        GetServerInfoTool:           "meta",
}

// ToolDescriptions maps tool names to descriptions
var ToolDescriptions = map[string]string{
        ListDomainsTool:             "Get all domains",
        CreateDomainTool:            "Create new domain for organizing URLs",
        ListNodesTool:               "List URLs in domain",
        CreateNodeTool:              "Add URL to domain",
        GetNodeTool:                 "Get URL details",
        UpdateNodeTool:              "Update URL title or description",
        DeleteNodeTool:              "Remove URL",
        FindNodeByUrlTool:           "Search by exact URL",
        GetNodeAttributesTool:       "Get URL tags and attributes",
        SetNodeAttributesTool:       "Add or update URL tags",
        ListDomainAttributesTool:    "Get available tag types for domain",
        CreateDomainAttributeTool:   "Define new tag type for domain",
        GetDomainAttributeTool:      "Get tag type details",
        UpdateDomainAttributeTool:   "Update tag type description",
        DeleteDomainAttributeTool:   "Remove unused tag type",
        GetNodeWithAttributesTool:   "Get URL with all tags at once",
        FilterNodesByAttributesTool: "Search URLs by tag values",
        CreateSubscriptionTool:      "Subscribe to node events",
        ListSubscriptionsTool:       "List all subscriptions for a service",
        GetNodeSubscriptionsTool:    "Get all subscriptions for a specific node",
        DeleteSubscriptionTool:      "Cancel a subscription",
        CreateDependencyTool:        "Create dependency relationship between nodes",
        ListNodeDependenciesTool:    "Get all dependencies for a node",
        ListNodeDependentsTool:      "Get all nodes that depend on this node",
        DeleteDependencyTool:        "Remove dependency relationship",
        GetNodeEventsTool:           "Get event history for a node",
        GetPendingEventsTool:        "Get unprocessed events for processing",
        ProcessEventTool:            "Mark an event as processed",
        GetEventStatsTool:           "Get system event statistics",
        GetServerInfoTool:           "Get server info",
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package mcp

import (
        "context"
        "encoding/json"
        "fmt"
        "url-db/internal/models"
)

// MCP Tool 정의 및 구현

// ToolRegistry manages all available MCP tools
type ToolRegistry struct {
        service MCPService
        tools   []Tool
}

// NewToolRegistry creates a new tool registry
func NewToolRegistry(service MCPService) *ToolRegistry <span class="cov8" title="1">{
        registry := &amp;ToolRegistry{
                service: service,
        }
        registry.registerTools()
        return registry
}</span>

// GetTools returns all available tools
func (tr *ToolRegistry) GetTools() []Tool <span class="cov8" title="1">{
        return tr.tools
}</span>

// CallTool executes a tool by name
func (tr *ToolRegistry) CallTool(ctx context.Context, name string, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        switch name </span>{
        case ListDomainsTool:<span class="cov8" title="1">
                return tr.callListDomains(ctx, arguments)</span>
        case CreateDomainTool:<span class="cov8" title="1">
                return tr.callCreateDomain(ctx, arguments)</span>
        case ListNodesTool:<span class="cov8" title="1">
                return tr.callListNodes(ctx, arguments)</span>
        case CreateNodeTool:<span class="cov8" title="1">
                return tr.callCreateNode(ctx, arguments)</span>
        case GetNodeTool:<span class="cov8" title="1">
                return tr.callGetNode(ctx, arguments)</span>
        case UpdateNodeTool:<span class="cov8" title="1">
                return tr.callUpdateNode(ctx, arguments)</span>
        case DeleteNodeTool:<span class="cov8" title="1">
                return tr.callDeleteNode(ctx, arguments)</span>
        case FindNodeByUrlTool:<span class="cov8" title="1">
                return tr.callFindNodeByURL(ctx, arguments)</span>
        case GetNodeAttributesTool:<span class="cov8" title="1">
                return tr.callGetNodeAttributes(ctx, arguments)</span>
        case SetNodeAttributesTool:<span class="cov8" title="1">
                return tr.callSetNodeAttributes(ctx, arguments)</span>
        case ListDomainAttributesTool:<span class="cov8" title="1">
                return tr.callListDomainAttributes(ctx, arguments)</span>
        case CreateDomainAttributeTool:<span class="cov8" title="1">
                return tr.callCreateDomainAttribute(ctx, arguments)</span>
        case GetDomainAttributeTool:<span class="cov8" title="1">
                return tr.callGetDomainAttribute(ctx, arguments)</span>
        case UpdateDomainAttributeTool:<span class="cov8" title="1">
                return tr.callUpdateDomainAttribute(ctx, arguments)</span>
        case DeleteDomainAttributeTool:<span class="cov8" title="1">
                return tr.callDeleteDomainAttribute(ctx, arguments)</span>
        case GetNodeWithAttributesTool:<span class="cov0" title="0">
                return tr.callGetNodeWithAttributes(ctx, arguments)</span>
        case FilterNodesByAttributesTool:<span class="cov0" title="0">
                return tr.callFilterNodesByAttributes(ctx, arguments)</span>
        case GetServerInfoTool:<span class="cov8" title="1">
                return tr.callGetServerInfo(ctx, arguments)</span>
        // External dependency management tools
        case CreateSubscriptionTool:<span class="cov0" title="0">
                return tr.callCreateSubscription(ctx, arguments)</span>
        case ListSubscriptionsTool:<span class="cov0" title="0">
                return tr.callListSubscriptions(ctx, arguments)</span>
        case GetNodeSubscriptionsTool:<span class="cov0" title="0">
                return tr.callGetNodeSubscriptions(ctx, arguments)</span>
        case DeleteSubscriptionTool:<span class="cov0" title="0">
                return tr.callDeleteSubscription(ctx, arguments)</span>
        case CreateDependencyTool:<span class="cov0" title="0">
                return tr.callCreateDependency(ctx, arguments)</span>
        case ListNodeDependenciesTool:<span class="cov0" title="0">
                return tr.callListNodeDependencies(ctx, arguments)</span>
        case ListNodeDependentsTool:<span class="cov0" title="0">
                return tr.callListNodeDependents(ctx, arguments)</span>
        case DeleteDependencyTool:<span class="cov0" title="0">
                return tr.callDeleteDependency(ctx, arguments)</span>
        case GetNodeEventsTool:<span class="cov0" title="0">
                return tr.callGetNodeEvents(ctx, arguments)</span>
        case GetPendingEventsTool:<span class="cov0" title="0">
                return tr.callGetPendingEvents(ctx, arguments)</span>
        case ProcessEventTool:<span class="cov0" title="0">
                return tr.callProcessEvent(ctx, arguments)</span>
        case GetEventStatsTool:<span class="cov0" title="0">
                return tr.callGetEventStats(ctx, arguments)</span>
        default:<span class="cov8" title="1">
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Unknown tool: %s", name)}},
                        IsError: true,
                }, nil</span>
        }
}

// registerTools registers all available tools
func (tr *ToolRegistry) registerTools() <span class="cov8" title="1">{
        tr.tools = []Tool{
                {
                        Name:        ListDomainsTool,
                        Description: ToolDescriptions[ListDomainsTool],
                        InputSchema: map[string]interface{}{
                                "type":       "object",
                                "properties": map[string]interface{}{},
                        },
                },
                {
                        Name:        CreateDomainTool,
                        Description: ToolDescriptions[CreateDomainTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name",
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain description",
                                        },
                                },
                                "required": []string{"name", "description"},
                        },
                },
                {
                        Name:        ListNodesTool,
                        Description: ToolDescriptions[ListNodesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name to list nodes from",
                                        },
                                        "page": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Page number (default: 1)",
                                                "default":     1,
                                        },
                                        "size": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Page size (default: 20)",
                                                "default":     20,
                                        },
                                        "search": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Search query (optional)",
                                        },
                                },
                                "required": []string{"domain_name"},
                        },
                },
                {
                        Name:        CreateNodeTool,
                        Description: ToolDescriptions[CreateNodeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name",
                                        },
                                        "url": map[string]interface{}{
                                                "type":        "string",
                                                "description": "URL to store",
                                        },
                                        "title": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Node title (optional)",
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Node description (optional)",
                                        },
                                },
                                "required": []string{"domain_name", "url"},
                        },
                },
                {
                        Name:        GetNodeTool,
                        Description: ToolDescriptions[GetNodeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        UpdateNodeTool,
                        Description: ToolDescriptions[UpdateNodeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                        "title": map[string]interface{}{
                                                "type":        "string",
                                                "description": "New title (optional)",
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "New description (optional)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        DeleteNodeTool,
                        Description: ToolDescriptions[DeleteNodeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        FindNodeByUrlTool,
                        Description: ToolDescriptions[FindNodeByUrlTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name",
                                        },
                                        "url": map[string]interface{}{
                                                "type":        "string",
                                                "description": "URL to find",
                                        },
                                },
                                "required": []string{"domain_name", "url"},
                        },
                },
                {
                        Name:        GetNodeAttributesTool,
                        Description: ToolDescriptions[GetNodeAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        SetNodeAttributesTool,
                        Description: ToolDescriptions[SetNodeAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool:domain:id)",
                                        },
                                        "attributes": map[string]interface{}{
                                                "type": "array",
                                                "items": map[string]interface{}{
                                                        "type": "object",
                                                        "properties": map[string]interface{}{
                                                                "name": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Attribute name",
                                                                },
                                                                "value": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Attribute value",
                                                                },
                                                                "order_index": map[string]interface{}{
                                                                        "type":        "integer",
                                                                        "description": "Order index (required for ordered_tag type)",
                                                                },
                                                        },
                                                        "required": []string{"name", "value"},
                                                },
                                                "description": "Array of attributes to set",
                                        },
                                },
                                "required": []string{"composite_id", "attributes"},
                        },
                },
                {
                        Name:        GetServerInfoTool,
                        Description: ToolDescriptions[GetServerInfoTool],
                        InputSchema: map[string]interface{}{
                                "type":       "object",
                                "properties": map[string]interface{}{},
                        },
                },
                {
                        Name:        ListDomainAttributesTool,
                        Description: ToolDescriptions[ListDomainAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "The domain to list attributes for",
                                        },
                                },
                                "required": []string{"domain_name"},
                        },
                },
                {
                        Name:        CreateDomainAttributeTool,
                        Description: ToolDescriptions[CreateDomainAttributeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "The domain to add attribute to",
                                        },
                                        "name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Attribute name",
                                        },
                                        "type": map[string]interface{}{
                                                "type":        "string",
                                                "description": "One of: tag, ordered_tag, number, string, markdown, image",
                                                "enum":        []string{"tag", "ordered_tag", "number", "string", "markdown", "image"},
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Human-readable description (optional)",
                                        },
                                },
                                "required": []string{"domain_name", "name", "type"},
                        },
                },
                {
                        Name:        GetDomainAttributeTool,
                        Description: ToolDescriptions[GetDomainAttributeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool-name:domain:attr-{id})",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        UpdateDomainAttributeTool,
                        Description: ToolDescriptions[UpdateDomainAttributeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool-name:domain:attr-{id})",
                                        },
                                        "description": map[string]interface{}{
                                                "type":        "string",
                                                "description": "New description",
                                        },
                                },
                                "required": []string{"composite_id", "description"},
                        },
                },
                {
                        Name:        DeleteDomainAttributeTool,
                        Description: ToolDescriptions[DeleteDomainAttributeTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool-name:domain:attr-{id})",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        GetNodeWithAttributesTool,
                        Description: ToolDescriptions[GetNodeWithAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "composite_id": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Composite ID (format: tool-name:domain:id)",
                                        },
                                },
                                "required": []string{"composite_id"},
                        },
                },
                {
                        Name:        FilterNodesByAttributesTool,
                        Description: ToolDescriptions[FilterNodesByAttributesTool],
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "domain_name": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Domain name to search in",
                                        },
                                        "filters": map[string]interface{}{
                                                "type":        "array",
                                                "description": "Array of attribute filters",
                                                "items": map[string]interface{}{
                                                        "type": "object",
                                                        "properties": map[string]interface{}{
                                                                "name": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Attribute name",
                                                                },
                                                                "value": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Attribute value to match",
                                                                },
                                                                "operator": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Comparison operator: equals, contains, starts_with, ends_with",
                                                                        "enum":        []string{"equals", "contains", "starts_with", "ends_with"},
                                                                        "default":     "equals",
                                                                },
                                                        },
                                                        "required": []string{"name", "value"},
                                                },
                                        },
                                        "page": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Page number (default: 1)",
                                                "default":     1,
                                        },
                                        "size": map[string]interface{}{
                                                "type":        "integer",
                                                "description": "Page size (default: 20)",
                                                "default":     20,
                                        },
                                },
                                "required": []string{"domain_name", "filters"},
                        },
                },
        }
}</span>

// Tool implementation methods

func (tr *ToolRegistry) callListDomains(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        response, err := tr.service.ListDomains(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing domains: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callCreateDomain(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.CreateDomainRequest{
                Name:        argsMap["name"].(string),
                Description: argsMap["description"].(string),
        }

        domain, err := tr.service.CreateDomain(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating domain: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(domain, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callListNodes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">domainName := argsMap["domain_name"].(string)
        page := 1
        size := 20
        search := ""

        if p, exists := argsMap["page"]; exists </span><span class="cov8" title="1">{
                if pFloat, ok := p.(float64); ok </span><span class="cov8" title="1">{
                        page = int(pFloat)
                }</span>
        }
        <span class="cov8" title="1">if s, exists := argsMap["size"]; exists </span><span class="cov8" title="1">{
                if sFloat, ok := s.(float64); ok </span><span class="cov8" title="1">{
                        size = int(sFloat)
                }</span>
        }
        <span class="cov8" title="1">if s, exists := argsMap["search"]; exists </span><span class="cov8" title="1">{
                search = s.(string)
        }</span>

        <span class="cov8" title="1">response, err := tr.service.ListNodes(ctx, domainName, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing nodes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callCreateNode(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.CreateMCPNodeRequest{
                DomainName:  argsMap["domain_name"].(string),
                URL:         argsMap["url"].(string),
                Title:       getStringArg(argsMap, "title"),
                Description: getStringArg(argsMap, "description"),
        }

        node, err := tr.service.CreateNode(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(node, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNode(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)
        node, err := tr.service.GetNode(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(node, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callUpdateNode(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)
        req := &amp;models.UpdateNodeRequest{
                Title:       getStringArg(argsMap, "title"),
                Description: getStringArg(argsMap, "description"),
        }

        node, err := tr.service.UpdateNode(ctx, compositeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error updating node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(node, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callDeleteNode(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)
        err := tr.service.DeleteNode(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error deleting node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: fmt.Sprintf("Node %s deleted successfully", compositeID)}},
        }, nil</span>
}

func (tr *ToolRegistry) callFindNodeByURL(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.FindMCPNodeRequest{
                DomainName: argsMap["domain_name"].(string),
                URL:        argsMap["url"].(string),
        }

        node, err := tr.service.FindNodeByURL(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error finding node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(node, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNodeAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)
        response, err := tr.service.GetNodeAttributes(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node attributes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callSetNodeAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := argsMap["composite_id"].(string)

        // Parse attributes array
        attributesRaw, exists := argsMap["attributes"]
        if !exists </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing attributes parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">attributesArray, ok := attributesRaw.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid attributes format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">var attributes []struct {
                Name       string `json:"name" binding:"required"`
                Value      string `json:"value" binding:"required"`
                OrderIndex *int   `json:"order_index"`
        }
        for _, attrRaw := range attributesArray </span><span class="cov8" title="1">{
                attrMap, ok := attrRaw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">var orderIndex *int
                if orderIndexRaw, exists := attrMap["order_index"]; exists </span><span class="cov0" title="0">{
                        if orderIndexFloat, ok := orderIndexRaw.(float64); ok </span><span class="cov0" title="0">{
                                orderIndexInt := int(orderIndexFloat)
                                orderIndex = &amp;orderIndexInt
                        }</span>
                }

                <span class="cov8" title="1">attributes = append(attributes, struct {
                        Name       string `json:"name" binding:"required"`
                        Value      string `json:"value" binding:"required"`
                        OrderIndex *int   `json:"order_index"`
                }{
                        Name:       attrMap["name"].(string),
                        Value:      attrMap["value"].(string),
                        OrderIndex: orderIndex,
                })</span>
        }

        <span class="cov8" title="1">req := &amp;models.SetMCPNodeAttributesRequest{
                Attributes: attributes,
        }

        response, err := tr.service.SetNodeAttributes(ctx, compositeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error setting node attributes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetServerInfo(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        info, err := tr.service.GetServerInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting server info: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(info, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

// Helper function to safely get string arguments
func getStringArg(args map[string]interface{}, key string) string <span class="cov8" title="1">{
        if val, exists := args[key]; exists </span><span class="cov8" title="1">{
                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func getIntArg(args map[string]interface{}, key string, defaultValue int) int <span class="cov0" title="0">{
        if val, exists := args[key]; exists </span><span class="cov0" title="0">{
                if intVal, ok := val.(int); ok </span><span class="cov0" title="0">{
                        return intVal
                }</span>
                <span class="cov0" title="0">if floatVal, ok := val.(float64); ok </span><span class="cov0" title="0">{
                        return int(floatVal)
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// Domain attribute management methods
func (tr *ToolRegistry) callListDomainAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">domainName := getStringArg(argsMap, "domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing domain_name parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">response, err := tr.service.ListDomainAttributes(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing domain attributes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callCreateDomainAttribute(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">domainName := getStringArg(argsMap, "domain_name")
        name := getStringArg(argsMap, "name")
        typeStr := getStringArg(argsMap, "type")
        description := getStringArg(argsMap, "description")

        if domainName == "" || name == "" || typeStr == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing required parameters: domain_name, name, type"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.CreateAttributeRequest{
                Name:        name,
                Type:        models.AttributeType(typeStr),
                Description: description,
        }

        response, err := tr.service.CreateDomainAttribute(ctx, domainName, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating domain attribute: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetDomainAttribute(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">response, err := tr.service.GetDomainAttribute(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting domain attribute: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callUpdateDomainAttribute(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := getStringArg(argsMap, "composite_id")
        description := getStringArg(argsMap, "description")

        if compositeID == "" || description == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing required parameters: composite_id, description"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">req := &amp;models.UpdateAttributeRequest{
                Description: description,
        }

        response, err := tr.service.UpdateDomainAttribute(ctx, compositeID, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error updating domain attribute: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callDeleteDomainAttribute(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov8" title="1">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">err := tr.service.DeleteDomainAttribute(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error deleting domain attribute: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov8" title="1">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: "Domain attribute deleted successfully"}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNodeWithAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        // Get node information
        <span class="cov0" title="0">node, err := tr.service.GetNode(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        // Get node attributes
        <span class="cov0" title="0">attributes, err := tr.service.GetNodeAttributes(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node attributes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        // Combine node and attributes into a single response
        <span class="cov0" title="0">response := map[string]interface{}{
                "node":       node,
                "attributes": attributes.Attributes,
        }

        result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callFilterNodesByAttributes(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">domainName := getStringArg(argsMap, "domain_name")
        if domainName == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing domain_name parameter"}},
                        IsError: true,
                }, nil
        }</span>

        // Parse filters
        <span class="cov0" title="0">filtersRaw, exists := argsMap["filters"]
        if !exists </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing filters parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">filtersArray, ok := filtersRaw.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid filters format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">type attributeFilter struct {
                Name     string `json:"name"`
                Value    string `json:"value"`
                Operator string `json:"operator"`
        }

        var filters []attributeFilter
        for _, filterRaw := range filtersArray </span><span class="cov0" title="0">{
                filterMap, ok := filterRaw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">operator := getStringArg(filterMap, "operator")
                if operator == "" </span><span class="cov0" title="0">{
                        operator = "equals"
                }</span>

                <span class="cov0" title="0">filter := attributeFilter{
                        Name:     getStringArg(filterMap, "name"),
                        Value:    getStringArg(filterMap, "value"),
                        Operator: operator,
                }

                filters = append(filters, filter)</span>
        }

        // Parse pagination
        <span class="cov0" title="0">page := 1
        size := 20
        if p, exists := argsMap["page"]; exists </span><span class="cov0" title="0">{
                if pFloat, ok := p.(float64); ok </span><span class="cov0" title="0">{
                        page = int(pFloat)
                }</span>
        }
        <span class="cov0" title="0">if s, exists := argsMap["size"]; exists </span><span class="cov0" title="0">{
                if sFloat, ok := s.(float64); ok </span><span class="cov0" title="0">{
                        size = int(sFloat)
                }</span>
        }

        // Convert filters to interface slice as maps
        <span class="cov0" title="0">var filterInterfaces []interface{}
        for _, f := range filters </span><span class="cov0" title="0">{
                filterMap := map[string]interface{}{
                        "name":     f.Name,
                        "value":    f.Value,
                        "operator": f.Operator,
                }
                filterInterfaces = append(filterInterfaces, filterMap)
        }</span>

        // Call service method to filter nodes
        <span class="cov0" title="0">response, err := tr.service.FilterNodesByAttributes(ctx, domainName, filterInterfaces, page, size)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error filtering nodes: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

// External Dependency Management Tool Calls

func (tr *ToolRegistry) callCreateSubscription(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        subscriberService := getStringArg(argsMap, "subscriber_service")

        if compositeID == "" || subscriberService == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing required parameters: composite_id and subscriber_service"}},
                        IsError: true,
                }, nil
        }</span>

        // Parse event types
        <span class="cov0" title="0">eventTypesRaw, exists := argsMap["event_types"]
        if !exists </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing event_types parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">eventTypesArray, ok := eventTypesRaw.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid event_types format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">eventTypes := make([]string, len(eventTypesArray))
        for i, et := range eventTypesArray </span><span class="cov0" title="0">{
                eventTypes[i] = fmt.Sprintf("%v", et)
        }</span>

        <span class="cov0" title="0">req := &amp;MCPCreateSubscriptionRequest{
                CompositeID:        compositeID,
                SubscriberService:  subscriberService,
                SubscriberEndpoint: getStringPtr(argsMap, "subscriber_endpoint"),
                EventTypes:         eventTypes,
        }

        subscription, err := tr.service.CreateSubscription(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating subscription: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(subscription, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callListSubscriptions(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                argsMap = make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">serviceName := getStringArg(argsMap, "service_name")
        page := getIntArg(argsMap, "page", 1)
        size := getIntArg(argsMap, "size", 20)

        response, err := tr.service.ListSubscriptions(ctx, serviceName, page, size)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing subscriptions: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(response, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNodeSubscriptions(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">subscriptions, err := tr.service.GetNodeSubscriptions(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node subscriptions: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(subscriptions, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callDeleteSubscription(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">subscriptionID := getIntArg(argsMap, "subscription_id", 0)
        if subscriptionID == 0 </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing or invalid subscription_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">err := tr.service.DeleteSubscription(ctx, int64(subscriptionID))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error deleting subscription: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: "Subscription deleted successfully"}},
        }, nil</span>
}

func (tr *ToolRegistry) callCreateDependency(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">dependentNodeID := getStringArg(argsMap, "dependent_node_id")
        dependencyNodeID := getStringArg(argsMap, "dependency_node_id")
        dependencyType := getStringArg(argsMap, "dependency_type")

        if dependentNodeID == "" || dependencyNodeID == "" || dependencyType == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing required parameters: dependent_node_id, dependency_node_id, dependency_type"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">req := &amp;MCPCreateDependencyRequest{
                DependentNodeID:  dependentNodeID,
                DependencyNodeID: dependencyNodeID,
                DependencyType:   dependencyType,
                CascadeDelete:    getBoolArg(argsMap, "cascade_delete", false),
                CascadeUpdate:    getBoolArg(argsMap, "cascade_update", false),
        }

        dependency, err := tr.service.CreateDependency(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error creating dependency: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(dependency, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callListNodeDependencies(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">dependencies, err := tr.service.ListNodeDependencies(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing node dependencies: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(dependencies, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callListNodeDependents(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">dependents, err := tr.service.ListNodeDependents(ctx, compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error listing node dependents: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(dependents, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callDeleteDependency(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">dependencyID := getIntArg(argsMap, "dependency_id", 0)
        if dependencyID == 0 </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing or invalid dependency_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">err := tr.service.DeleteDependency(ctx, int64(dependencyID))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error deleting dependency: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: "Dependency deleted successfully"}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetNodeEvents(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">compositeID := getStringArg(argsMap, "composite_id")
        if compositeID == "" </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing composite_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">limit := getIntArg(argsMap, "limit", 50)

        events, err := tr.service.GetNodeEvents(ctx, compositeID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting node events: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(events, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetPendingEvents(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                argsMap = make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">limit := getIntArg(argsMap, "limit", 100)

        events, err := tr.service.GetPendingEvents(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting pending events: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(events, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

func (tr *ToolRegistry) callProcessEvent(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        argsMap, ok := arguments.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Invalid arguments format"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">eventID := getIntArg(argsMap, "event_id", 0)
        if eventID == 0 </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: "Missing or invalid event_id parameter"}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">err := tr.service.ProcessEvent(ctx, int64(eventID))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error processing event: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: "Event processed successfully"}},
        }, nil</span>
}

func (tr *ToolRegistry) callGetEventStats(ctx context.Context, arguments interface{}) (*CallToolResult, error) <span class="cov0" title="0">{
        stats, err := tr.service.GetEventStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CallToolResult{
                        Content: []Content{{Type: "text", Text: fmt.Sprintf("Error getting event stats: %v", err)}},
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">result, _ := json.MarshalIndent(stats, "", "  ")
        return &amp;CallToolResult{
                Content: []Content{{Type: "text", Text: string(result)}},
        }, nil</span>
}

// Helper functions
func getStringPtr(argsMap map[string]interface{}, key string) *string <span class="cov0" title="0">{
        if val, exists := argsMap[key]; exists </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok &amp;&amp; str != "" </span><span class="cov0" title="0">{
                        return &amp;str
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getBoolArg(argsMap map[string]interface{}, key string, defaultValue bool) bool <span class="cov0" title="0">{
        if val, exists := argsMap[key]; exists </span><span class="cov0" title="0">{
                if b, ok := val.(bool); ok </span><span class="cov0" title="0">{
                        return b
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "time"
)

// NodeDependency represents a dependency relationship between nodes
type NodeDependency struct {
        ID               int64               `db:"id" json:"id"`
        DependentNodeID  int64               `db:"dependent_node_id" json:"dependent_node_id"`
        DependencyNodeID int64               `db:"dependency_node_id" json:"dependency_node_id"`
        DependencyType   string              `db:"dependency_type" json:"dependency_type"`
        CascadeDelete    bool                `db:"cascade_delete" json:"cascade_delete"`
        CascadeUpdate    bool                `db:"cascade_update" json:"cascade_update"`
        Metadata         *DependencyMetadata `db:"metadata" json:"metadata,omitempty"`
        CreatedAt        time.Time           `db:"created_at" json:"created_at"`
}

// NodeDependencyV2 represents an enhanced dependency relationship with advanced features
type NodeDependencyV2 struct {
        ID                int64                 `db:"id" json:"id"`
        DependentNodeID   int64                 `db:"dependent_node_id" json:"dependent_node_id"`
        DependencyNodeID  int64                 `db:"dependency_node_id" json:"dependency_node_id"`
        DependencyType    string                `db:"dependency_type" json:"dependency_type"`
        Category          string                `db:"category" json:"category"`
        Strength          int                   `db:"strength" json:"strength"` // 0-100
        Priority          int                   `db:"priority" json:"priority"` // 0-100
        CascadeDelete     bool                  `db:"cascade_delete" json:"cascade_delete"`
        CascadeUpdate     bool                  `db:"cascade_update" json:"cascade_update"`
        Metadata          *DependencyMetadataV2 `db:"metadata" json:"metadata,omitempty"`
        VersionConstraint *string               `db:"version_constraint" json:"version_constraint,omitempty"`
        IsRequired        bool                  `db:"is_required" json:"is_required"`
        IsActive          bool                  `db:"is_active" json:"is_active"`
        ValidFrom         time.Time             `db:"valid_from" json:"valid_from"`
        ValidUntil        *time.Time            `db:"valid_until" json:"valid_until,omitempty"`
        CreatedAt         time.Time             `db:"created_at" json:"created_at"`
        UpdatedAt         time.Time             `db:"updated_at" json:"updated_at"`
        CreatedBy         *string               `db:"created_by" json:"created_by,omitempty"`
}

// DependencyMetadata represents additional metadata for a dependency
type DependencyMetadata struct {
        Relationship string `json:"relationship,omitempty"`
        Description  string `json:"description,omitempty"`
}

// DependencyMetadataV2 represents enhanced metadata with type-specific fields
type DependencyMetadataV2 struct {
        Relationship       string                 `json:"relationship,omitempty"`
        Description        string                 `json:"description,omitempty"`
        HealthCheckURL     string                 `json:"health_check_url,omitempty"`
        SyncFrequency      string                 `json:"sync_frequency,omitempty"`
        RetryPolicy        map[string]interface{} `json:"retry_policy,omitempty"`
        StartupOrder       int                    `json:"startup_order,omitempty"`
        FallbackBehavior   string                 `json:"fallback_behavior,omitempty"`
        ConflictResolution string                 `json:"conflict_resolution,omitempty"`
        CustomFields       map[string]interface{} `json:"custom_fields,omitempty"`
}

// Scan implements sql.Scanner interface
func (m *DependencyMetadata) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), m)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, m)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Value implements driver.Valuer interface
func (m *DependencyMetadata) Value() (driver.Value, error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(m)
        return string(data), err</span>
}

// ParseMetadata parses the dependency metadata into a map
func (d *NodeDependency) ParseMetadata() (map[string]interface{}, error) <span class="cov0" title="0">{
        if d.Metadata == nil </span><span class="cov0" title="0">{
                return make(map[string]interface{}), nil
        }</span>
        
        <span class="cov0" title="0">result := make(map[string]interface{})
        if d.Metadata.Relationship != "" </span><span class="cov0" title="0">{
                result["relationship"] = d.Metadata.Relationship
        }</span>
        <span class="cov0" title="0">if d.Metadata.Description != "" </span><span class="cov0" title="0">{
                result["description"] = d.Metadata.Description
        }</span>
        
        <span class="cov0" title="0">return result, nil</span>
}

// DependencyType constants
const (
        // Structural dependency types
        DependencyTypeHard      = "hard"
        DependencyTypeSoft      = "soft"
        DependencyTypeReference = "reference"

        // Behavioral dependency types
        DependencyTypeRuntime  = "runtime"
        DependencyTypeCompile  = "compile"
        DependencyTypeOptional = "optional"

        // Data dependency types
        DependencyTypeSync  = "sync"
        DependencyTypeAsync = "async"

        // Dependency categories
        CategoryStructural = "structural"
        CategoryBehavioral = "behavioral"
        CategoryData       = "data"

        // Impact levels
        ImpactLevelCritical = "critical"
        ImpactLevelHigh     = "high"
        ImpactLevelMedium   = "medium"
        ImpactLevelLow      = "low"
)

// CreateNodeDependencyRequest represents a request to create a dependency
type CreateNodeDependencyRequest struct {
        DependencyNodeID int64               `json:"dependency_node_id" validate:"required"`
        DependencyType   string              `json:"dependency_type" validate:"required,oneof=hard soft reference"`
        CascadeDelete    bool                `json:"cascade_delete"`
        CascadeUpdate    bool                `json:"cascade_update"`
        Metadata         *DependencyMetadata `json:"metadata,omitempty"`
}

// NodeEvent represents an event that occurred on a node
type NodeEvent struct {
        ID          int64      `db:"id" json:"id"`
        NodeID      int64      `db:"node_id" json:"node_id"`
        EventType   string     `db:"event_type" json:"event_type"`
        EventData   *EventData `db:"event_data" json:"event_data,omitempty"`
        OccurredAt  time.Time  `db:"occurred_at" json:"occurred_at"`
        ProcessedAt *time.Time `db:"processed_at" json:"processed_at,omitempty"`
}

// EventData represents the data associated with an event
type EventData struct {
        EventID   string                 `json:"event_id"`
        NodeID    int64                  `json:"node_id"`
        EventType string                 `json:"event_type"`
        Timestamp time.Time              `json:"timestamp"`
        Changes   *EventChanges          `json:"changes,omitempty"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// EventChanges represents before/after state in an event
type EventChanges struct {
        Before map[string]interface{} `json:"before,omitempty"`
        After  map[string]interface{} `json:"after,omitempty"`
}

// Scan implements sql.Scanner interface
func (e *EventData) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), e)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, e)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Value implements driver.Valuer interface
func (e *EventData) Value() (driver.Value, error) <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(e)
        return string(data), err</span>
}

// Event type constants
const (
        EventTypeCreated           = "created"
        EventTypeUpdated           = "updated"
        EventTypeDeleted           = "deleted"
        EventTypeAttributeChanged  = "attribute_changed"
        EventTypeConnectionChanged = "connection_changed"
)

// DependencyGraph represents a node's dependency relationships
type DependencyGraph struct {
        NodeID       int64                  `json:"node_id"`
        Dependencies []DependencyNode       `json:"dependencies"`
        Dependents   []DependencyNode       `json:"dependents"`
        Depth        int                    `json:"depth"`
        HasCircular  bool                   `json:"has_circular"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// DependencyNode represents a node in the dependency graph
type DependencyNode struct {
        NodeID            int64                  `json:"node_id"`
        CompositeID       string                 `json:"composite_id"`
        Title             string                 `json:"title"`
        DependencyType    string                 `json:"dependency_type"`
        Category          string                 `json:"category"`
        Strength          int                    `json:"strength"`
        Priority          int                    `json:"priority"`
        IsRequired        bool                   `json:"is_required"`
        VersionConstraint *string                `json:"version_constraint,omitempty"`
        Metadata          map[string]interface{} `json:"metadata,omitempty"`
        Children          []DependencyNode       `json:"children,omitempty"`
}

// ImpactAnalysisResult contains the results of dependency impact analysis
type ImpactAnalysisResult struct {
        SourceNodeID    int64          `json:"source_node_id"`
        SourceComposite string         `json:"source_composite_id"`
        ImpactType      string         `json:"impact_type"`
        AffectedNodes   []AffectedNode `json:"affected_nodes"`
        ImpactScore     int            `json:"impact_score"` // 0-100
        CascadeDepth    int            `json:"cascade_depth"`
        EstimatedTime   string         `json:"estimated_time"`
        Warnings        []string       `json:"warnings,omitempty"`
        Recommendations []string       `json:"recommendations,omitempty"`
}

// AffectedNode represents a node affected by a dependency change
type AffectedNode struct {
        NodeID       int64   `json:"node_id"`
        CompositeID  string  `json:"composite_id"`
        Title        string  `json:"title"`
        ImpactLevel  string  `json:"impact_level"` // 'critical', 'high', 'medium', 'low'
        Reason       string  `json:"reason"`
        ActionNeeded string  `json:"action_needed"`
        Path         []int64 `json:"path,omitempty"` // Path from source to this node
}

// CircularDependency represents a circular dependency path
type CircularDependency struct {
        Path        []int64  `json:"path"`
        NodeDetails []string `json:"node_details"`
        Strength    int      `json:"strength"` // Weakest link in the cycle
}

// DependencyValidationResult contains validation results
type DependencyValidationResult struct {
        IsValid  bool                 `json:"is_valid"`
        Errors   []string             `json:"errors,omitempty"`
        Warnings []string             `json:"warnings,omitempty"`
        Cycles   []CircularDependency `json:"cycles,omitempty"`
}

// DependencyTypeConfig represents configuration for a dependency type
type DependencyTypeConfig struct {
        TypeName           string                 `json:"type_name"`
        Category           string                 `json:"category"`
        CascadeDelete      bool                   `json:"cascade_delete"`
        CascadeUpdate      bool                   `json:"cascade_update"`
        ValidationRequired bool                   `json:"validation_required"`
        DefaultStrength    int                    `json:"default_strength"`
        DefaultPriority    int                    `json:"default_priority"`
        MetadataSchema     map[string]interface{} `json:"metadata_schema,omitempty"`
        Description        string                 `json:"description"`
}

// DependencyRule represents a validation rule for dependencies
type DependencyRule struct {
        ID         int64                  `db:"id" json:"id"`
        DomainID   *int64                 `db:"domain_id" json:"domain_id,omitempty"`
        RuleName   string                 `db:"rule_name" json:"rule_name"`
        RuleType   string                 `db:"rule_type" json:"rule_type"`
        RuleConfig map[string]interface{} `db:"rule_config" json:"rule_config"`
        IsActive   bool                   `db:"is_active" json:"is_active"`
        CreatedAt  time.Time              `db:"created_at" json:"created_at"`
}

// DependencyGraphCache represents cached dependency graph data
type DependencyGraphCache struct {
        ID         int64      `db:"id" json:"id"`
        NodeID     int64      `db:"node_id" json:"node_id"`
        GraphData  string     `db:"graph_data" json:"graph_data"`
        MaxDepth   int        `db:"max_depth" json:"max_depth"`
        CreatedAt  time.Time  `db:"created_at" json:"created_at"`
        ExpiresAt  *time.Time `db:"expires_at" json:"expires_at,omitempty"`
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "time"
)

// NodeSubscription represents a subscription to node events
type NodeSubscription struct {
        ID                 int64            `db:"id" json:"id"`
        SubscriberService  string           `db:"subscriber_service" json:"subscriber_service"`
        SubscriberEndpoint *string          `db:"subscriber_endpoint" json:"subscriber_endpoint,omitempty"`
        SubscribedNodeID   int64            `db:"subscribed_node_id" json:"subscribed_node_id"`
        EventTypes         EventTypeList    `db:"event_types" json:"event_types"`
        FilterConditions   *FilterCondition `db:"filter_conditions" json:"filter_conditions,omitempty"`
        IsActive           bool             `db:"is_active" json:"is_active"`
        CreatedAt          time.Time        `db:"created_at" json:"created_at"`
        UpdatedAt          time.Time        `db:"updated_at" json:"updated_at"`
}

// EventTypeList represents a list of event types
type EventTypeList []string

// Scan implements sql.Scanner interface
func (e *EventTypeList) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *e = EventTypeList{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), e)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, e)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Value implements driver.Valuer interface
func (e EventTypeList) Value() (driver.Value, error) <span class="cov0" title="0">{
        if len(e) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(e)
        return string(data), err</span>
}

// FilterCondition represents subscription filter conditions
type FilterCondition struct {
        AttributeFilters []AttributeFilter `json:"attribute_filters,omitempty"`
        ChangeFilters    *ChangeFilter     `json:"change_filters,omitempty"`
}

// AttributeFilter represents a filter on node attributes
type AttributeFilter struct {
        AttributeName string      `json:"attribute_name"`
        Operator      string      `json:"operator"`
        Value         interface{} `json:"value"`
}

// ChangeFilter represents filters on what changes to track
type ChangeFilter struct {
        Fields       []string `json:"fields,omitempty"`
        IgnoreFields []string `json:"ignore_fields,omitempty"`
}

// Scan implements sql.Scanner interface
func (f *FilterCondition) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), f)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, f)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Value implements driver.Valuer interface
func (f *FilterCondition) Value() (driver.Value, error) <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(f)
        return string(data), err</span>
}

// CreateNodeSubscriptionRequest represents a request to create a subscription
type CreateNodeSubscriptionRequest struct {
        SubscriberService  string           `json:"subscriber_service" validate:"required"`
        SubscriberEndpoint *string          `json:"subscriber_endpoint,omitempty"`
        EventTypes         []string         `json:"event_types" validate:"required,min=1"`
        FilterConditions   *FilterCondition `json:"filter_conditions,omitempty"`
}

// UpdateNodeSubscriptionRequest represents a request to update a subscription
type UpdateNodeSubscriptionRequest struct {
        SubscriberEndpoint *string          `json:"subscriber_endpoint,omitempty"`
        EventTypes         []string         `json:"event_types,omitempty"`
        FilterConditions   *FilterCondition `json:"filter_conditions,omitempty"`
        IsActive           *bool            `json:"is_active,omitempty"`
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package nodeattributes

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "url-db/internal/models"
)

type Handler struct {
        service Service
}

func NewHandler(service Service) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                service: service,
        }
}</span>

func (h *Handler) RegisterRoutes(router *gin.Engine) <span class="cov0" title="0">{
        api := router.Group("/api")
        </span><span class="cov0" title="0">{
                // Node attribute routes
                api.POST("/urls/:url_id/attributes", h.CreateNodeAttribute)
                api.GET("/urls/:url_id/attributes", h.GetNodeAttributesByNodeID)
                api.GET("/url-attributes/:id", h.GetNodeAttributeByID)
                api.PUT("/url-attributes/:id", h.UpdateNodeAttribute)
                api.DELETE("/url-attributes/:id", h.DeleteNodeAttribute)
                api.DELETE("/urls/:url_id/attributes/:attribute_id", h.DeleteNodeAttributeByNodeIDAndAttributeID)
        }</span>
}

// CreateNodeAttribute godoc
// @Summary      Create a node attribute
// @Description  Create a new attribute value for a URL node
// @Tags         node-attributes
// @Accept       json
// @Produce      json
// @Param        url_id     path      int                               true  "URL Node ID"
// @Param        attribute  body      models.CreateNodeAttributeRequest true  "Node attribute data"
// @Success      201        {object}  models.NodeAttribute
// @Failure      400        {object}  map[string]interface{}
// @Failure      409        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /urls/{url_id}/attributes [post]
func (h *Handler) CreateNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        urlID, err := strconv.Atoi(c.Param("url_id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid URL ID",
                        "code":  "validation_error",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateNodeAttributeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                        "code":  "validation_error",
                })
                return
        }</span>

        <span class="cov0" title="0">nodeAttribute, err := h.service.CreateNodeAttribute(urlID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := http.StatusInternalServerError
                errorCode := "internal_error"

                switch err </span>{
                case ErrNodeAttributeDomainMismatch:<span class="cov0" title="0">
                        statusCode = http.StatusBadRequest
                        errorCode = "business_rule_violation"</span>
                case ErrNodeAttributeExists:<span class="cov0" title="0">
                        statusCode = http.StatusConflict
                        errorCode = "conflict"</span>
                case ErrNodeAttributeValueInvalid, ErrInvalidAttributeType, ErrOrderIndexRequired, ErrOrderIndexNotAllowed, ErrInvalidOrderIndex:<span class="cov0" title="0">
                        statusCode = http.StatusBadRequest
                        errorCode = "validation_error"</span>
                case ErrDuplicateOrderIndex:<span class="cov0" title="0">
                        statusCode = http.StatusConflict
                        errorCode = "constraint_violation"</span>
                }

                <span class="cov0" title="0">c.JSON(statusCode, gin.H{
                        "error": err.Error(),
                        "code":  errorCode,
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, nodeAttribute)</span>
}

// GetNodeAttributesByNodeID godoc
// @Summary      Get node attributes
// @Description  Get all attribute values for a URL node
// @Tags         node-attributes
// @Produce      json
// @Param        url_id  path      int  true  "URL Node ID"
// @Success      200     {object}  models.NodeAttributeListResponse
// @Failure      400     {object}  map[string]interface{}
// @Failure      500     {object}  map[string]interface{}
// @Router       /urls/{url_id}/attributes [get]
func (h *Handler) GetNodeAttributesByNodeID(c *gin.Context) <span class="cov0" title="0">{
        urlID, err := strconv.Atoi(c.Param("url_id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid URL ID",
                        "code":  "validation_error",
                })
                return
        }</span>

        <span class="cov0" title="0">response, err := h.service.GetNodeAttributesByNodeID(urlID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": err.Error(),
                        "code":  "internal_error",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetNodeAttributeByID godoc
// @Summary      Get a node attribute
// @Description  Get a specific node attribute by ID
// @Tags         node-attributes
// @Produce      json
// @Param        id  path      int  true  "Node Attribute ID"
// @Success      200 {object}  models.NodeAttribute
// @Failure      400 {object}  map[string]interface{}
// @Failure      404 {object}  map[string]interface{}
// @Failure      500 {object}  map[string]interface{}
// @Router       /url-attributes/{id} [get]
func (h *Handler) GetNodeAttributeByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid ID",
                        "code":  "validation_error",
                })
                return
        }</span>

        <span class="cov0" title="0">nodeAttribute, err := h.service.GetNodeAttributeByID(id)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := http.StatusInternalServerError
                errorCode := "internal_error"

                if err == ErrNodeAttributeNotFound </span><span class="cov0" title="0">{
                        statusCode = http.StatusNotFound
                        errorCode = "not_found"
                }</span>

                <span class="cov0" title="0">c.JSON(statusCode, gin.H{
                        "error": err.Error(),
                        "code":  errorCode,
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, nodeAttribute)</span>
}

// UpdateNodeAttribute godoc
// @Summary      Update a node attribute
// @Description  Update a node attribute value and order index by ID
// @Tags         node-attributes
// @Accept       json
// @Produce      json
// @Param        id         path      int                               true  "Node Attribute ID"
// @Param        attribute  body      models.UpdateNodeAttributeRequest true  "Updated node attribute data"
// @Success      200        {object}  models.NodeAttribute
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      409        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /url-attributes/{id} [put]
func (h *Handler) UpdateNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid ID",
                        "code":  "validation_error",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateNodeAttributeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                        "code":  "validation_error",
                })
                return
        }</span>

        <span class="cov0" title="0">nodeAttribute, err := h.service.UpdateNodeAttribute(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := http.StatusInternalServerError
                errorCode := "internal_error"

                switch err </span>{
                case ErrNodeAttributeNotFound:<span class="cov0" title="0">
                        statusCode = http.StatusNotFound
                        errorCode = "not_found"</span>
                case ErrNodeAttributeValueInvalid, ErrInvalidAttributeType, ErrOrderIndexRequired, ErrOrderIndexNotAllowed, ErrInvalidOrderIndex:<span class="cov0" title="0">
                        statusCode = http.StatusBadRequest
                        errorCode = "validation_error"</span>
                case ErrDuplicateOrderIndex:<span class="cov0" title="0">
                        statusCode = http.StatusConflict
                        errorCode = "constraint_violation"</span>
                }

                <span class="cov0" title="0">c.JSON(statusCode, gin.H{
                        "error": err.Error(),
                        "code":  errorCode,
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, nodeAttribute)</span>
}

// DeleteNodeAttribute godoc
// @Summary      Delete a node attribute
// @Description  Delete a node attribute by ID
// @Tags         node-attributes
// @Param        id  path  int  true  "Node Attribute ID"
// @Success      204
// @Failure      400  {object}  map[string]interface{}
// @Failure      404  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /url-attributes/{id} [delete]
func (h *Handler) DeleteNodeAttribute(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid ID",
                        "code":  "validation_error",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.service.DeleteNodeAttribute(id)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := http.StatusInternalServerError
                errorCode := "internal_error"

                if err == ErrNodeAttributeNotFound </span><span class="cov0" title="0">{
                        statusCode = http.StatusNotFound
                        errorCode = "not_found"
                }</span>

                <span class="cov0" title="0">c.JSON(statusCode, gin.H{
                        "error": err.Error(),
                        "code":  errorCode,
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// DeleteNodeAttributeByNodeIDAndAttributeID godoc
// @Summary      Delete a node attribute by node and attribute ID
// @Description  Delete a specific node attribute by URL node ID and attribute ID
// @Tags         node-attributes
// @Param        url_id       path  int  true  "URL Node ID"
// @Param        attribute_id path  int  true  "Attribute ID"
// @Success      204
// @Failure      400  {object}  map[string]interface{}
// @Failure      404  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /urls/{url_id}/attributes/{attribute_id} [delete]
func (h *Handler) DeleteNodeAttributeByNodeIDAndAttributeID(c *gin.Context) <span class="cov0" title="0">{
        urlID, err := strconv.Atoi(c.Param("url_id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid URL ID",
                        "code":  "validation_error",
                })
                return
        }</span>

        <span class="cov0" title="0">attributeID, err := strconv.Atoi(c.Param("attribute_id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid Attribute ID",
                        "code":  "validation_error",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.service.DeleteNodeAttributeByNodeIDAndAttributeID(urlID, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := http.StatusInternalServerError
                errorCode := "internal_error"

                if err == ErrNodeAttributeNotFound </span><span class="cov0" title="0">{
                        statusCode = http.StatusNotFound
                        errorCode = "not_found"
                }</span>

                <span class="cov0" title="0">c.JSON(statusCode, gin.H{
                        "error": err.Error(),
                        "code":  errorCode,
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package nodeattributes

import (
        "fmt"
        "url-db/internal/models"
)

type OrderManager interface {
        AssignOrderIndex(nodeID, attributeID int, orderIndex *int) (*int, error)
        ValidateOrderIndex(nodeID, attributeID int, orderIndex *int, excludeID *int) error
        ReorderAfterDeletion(nodeID, attributeID int, deletedOrderIndex int) error
}

type orderManager struct {
        repo Repository
}

func NewOrderManager(repo Repository) OrderManager <span class="cov0" title="0">{
        return &amp;orderManager{repo: repo}
}</span>

func (om *orderManager) AssignOrderIndex(nodeID, attributeID int, orderIndex *int) (*int, error) <span class="cov0" title="0">{
        if orderIndex == nil </span><span class="cov0" title="0">{
                // Auto-assign next available order index
                maxIndex, err := om.repo.GetMaxOrderIndex(nodeID, attributeID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get max order index: %w", err)
                }</span>
                <span class="cov0" title="0">nextIndex := maxIndex + 1
                return &amp;nextIndex, nil</span>
        }

        // Validate provided order index
        <span class="cov0" title="0">if *orderIndex &lt; 1 </span><span class="cov0" title="0">{
                return nil, ErrInvalidOrderIndex
        }</span>

        // Check if order index already exists
        <span class="cov0" title="0">existing, err := om.getNodeAttributeByOrderIndex(nodeID, attributeID, *orderIndex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing order index: %w", err)
        }</span>

        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                // Shift existing items up
                if err := om.repo.ReorderAfterIndex(nodeID, attributeID, *orderIndex-1); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to reorder existing items: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return orderIndex, nil</span>
}

func (om *orderManager) ValidateOrderIndex(nodeID, attributeID int, orderIndex *int, excludeID *int) error <span class="cov0" title="0">{
        if orderIndex == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if *orderIndex &lt; 1 </span><span class="cov0" title="0">{
                return ErrInvalidOrderIndex
        }</span>

        // Check if order index already exists (excluding current item if updating)
        <span class="cov0" title="0">existing, err := om.getNodeAttributeByOrderIndex(nodeID, attributeID, *orderIndex)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check existing order index: %w", err)
        }</span>

        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                // If we're updating and this is the same item, it's okay
                if excludeID != nil &amp;&amp; existing.ID == *excludeID </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return ErrDuplicateOrderIndex</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (om *orderManager) ReorderAfterDeletion(nodeID, attributeID int, deletedOrderIndex int) error <span class="cov0" title="0">{
        // Get all items with order index greater than deleted item
        nodeAttrs, err := om.repo.GetByNodeID(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get node attributes: %w", err)
        }</span>

        // Update order indexes for items after the deleted one
        <span class="cov0" title="0">for _, attr := range nodeAttrs </span><span class="cov0" title="0">{
                if attr.AttributeID == attributeID &amp;&amp; attr.OrderIndex != nil &amp;&amp; *attr.OrderIndex &gt; deletedOrderIndex </span><span class="cov0" title="0">{
                        newIndex := *attr.OrderIndex - 1
                        updateReq := &amp;models.UpdateNodeAttributeRequest{
                                Value:      attr.Value,
                                OrderIndex: &amp;newIndex,
                        }

                        if _, err := om.repo.Update(attr.ID, updateReq); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update order index after deletion: %w", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (om *orderManager) getNodeAttributeByOrderIndex(nodeID, attributeID int, orderIndex int) (*models.NodeAttributeWithInfo, error) <span class="cov0" title="0">{
        nodeAttrs, err := om.repo.GetByNodeID(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node attributes: %w", err)
        }</span>

        <span class="cov0" title="0">for _, attr := range nodeAttrs </span><span class="cov0" title="0">{
                if attr.AttributeID == attributeID &amp;&amp; attr.OrderIndex != nil &amp;&amp; *attr.OrderIndex == orderIndex </span><span class="cov0" title="0">{
                        return &amp;attr, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package nodeattributes

import (
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"

        "url-db/internal/models"
)

type Repository interface {
        Create(nodeAttribute *models.NodeAttribute) error
        GetByID(id int) (*models.NodeAttributeWithInfo, error)
        GetByNodeID(nodeID int) ([]models.NodeAttributeWithInfo, error)
        Update(id int, req *models.UpdateNodeAttributeRequest) (*models.NodeAttribute, error)
        Delete(id int) error
        DeleteByNodeIDAndAttributeID(nodeID, attributeID int) error
        GetByNodeIDAndAttributeID(nodeID, attributeID int) (*models.NodeAttributeWithInfo, error)
        GetMaxOrderIndex(nodeID, attributeID int) (int, error)
        ReorderAfterIndex(nodeID, attributeID, afterIndex int) error
        ValidateNodeAndAttributeDomain(nodeID, attributeID int) error
        GetAttributeType(attributeID int) (models.AttributeType, error)
}

type repository struct {
        db *sqlx.DB
}

func NewRepository(db *sqlx.DB) Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

func (r *repository) Create(nodeAttribute *models.NodeAttribute) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_attributes (node_id, attribute_id, value, order_index)
                VALUES (:node_id, :attribute_id, :value, :order_index)
        `

        result, err := r.db.NamedExec(query, nodeAttribute)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create node attribute: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov0" title="0">nodeAttribute.ID = int(id)
        return nil</span>
}

func (r *repository) GetByID(id int) (*models.NodeAttributeWithInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        na.id,
                        na.node_id,
                        na.attribute_id,
                        a.name,
                        a.type,
                        na.value,
                        na.order_index,
                        na.created_at
                FROM node_attributes na
                JOIN attributes a ON na.attribute_id = a.id
                WHERE na.id = ?
        `

        var nodeAttr models.NodeAttributeWithInfo
        err := r.db.Get(&amp;nodeAttr, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get node attribute by id: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;nodeAttr, nil</span>
}

func (r *repository) GetByNodeID(nodeID int) ([]models.NodeAttributeWithInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        na.id,
                        na.node_id,
                        na.attribute_id,
                        a.name,
                        a.type,
                        na.value,
                        na.order_index,
                        na.created_at
                FROM node_attributes na
                JOIN attributes a ON na.attribute_id = a.id
                WHERE na.node_id = ?
                ORDER BY a.name, na.order_index, na.created_at
        `

        var nodeAttrs []models.NodeAttributeWithInfo
        err := r.db.Select(&amp;nodeAttrs, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node attributes by node id: %w", err)
        }</span>

        <span class="cov0" title="0">return nodeAttrs, nil</span>
}

func (r *repository) Update(id int, req *models.UpdateNodeAttributeRequest) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        query := `
                UPDATE node_attributes 
                SET value = ?, order_index = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query, req.Value, req.OrderIndex, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update node attribute: %w", err)
        }</span>

        // Return updated node attribute
        <span class="cov0" title="0">selectQuery := `
                SELECT id, node_id, attribute_id, value, order_index, created_at
                FROM node_attributes
                WHERE id = ?
        `

        var nodeAttr models.NodeAttribute
        err = r.db.Get(&amp;nodeAttr, selectQuery, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get updated node attribute: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;nodeAttr, nil</span>
}

func (r *repository) Delete(id int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE id = ?`

        result, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete node attribute: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("node attribute not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *repository) DeleteByNodeIDAndAttributeID(nodeID, attributeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE node_id = ? AND attribute_id = ?`

        result, err := r.db.Exec(query, nodeID, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete node attribute: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("node attribute not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *repository) GetByNodeIDAndAttributeID(nodeID, attributeID int) (*models.NodeAttributeWithInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        na.id,
                        na.node_id,
                        na.attribute_id,
                        a.name,
                        a.type,
                        na.value,
                        na.order_index,
                        na.created_at
                FROM node_attributes na
                JOIN attributes a ON na.attribute_id = a.id
                WHERE na.node_id = ? AND na.attribute_id = ?
        `

        var nodeAttr models.NodeAttributeWithInfo
        err := r.db.Get(&amp;nodeAttr, query, nodeID, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get node attribute: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;nodeAttr, nil</span>
}

func (r *repository) GetMaxOrderIndex(nodeID, attributeID int) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COALESCE(MAX(order_index), 0)
                FROM node_attributes
                WHERE node_id = ? AND attribute_id = ?
        `

        var maxIndex int
        err := r.db.Get(&amp;maxIndex, query, nodeID, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get max order index: %w", err)
        }</span>

        <span class="cov0" title="0">return maxIndex, nil</span>
}

func (r *repository) ReorderAfterIndex(nodeID, attributeID, afterIndex int) error <span class="cov0" title="0">{
        query := `
                UPDATE node_attributes
                SET order_index = order_index + 1
                WHERE node_id = ? AND attribute_id = ? AND order_index &gt; ?
        `

        _, err := r.db.Exec(query, nodeID, attributeID, afterIndex)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reorder node attributes: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *repository) ValidateNodeAndAttributeDomain(nodeID, attributeID int) error <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM nodes n
                JOIN attributes a ON n.domain_id = a.domain_id
                WHERE n.id = ? AND a.id = ?
        `

        var count int
        err := r.db.Get(&amp;count, query, nodeID, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate node and attribute domain: %w", err)
        }</span>

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("node and attribute must belong to the same domain")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *repository) GetAttributeType(attributeID int) (models.AttributeType, error) <span class="cov0" title="0">{
        query := `SELECT type FROM attributes WHERE id = ?`

        var attributeType models.AttributeType
        err := r.db.Get(&amp;attributeType, query, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("attribute not found")
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to get attribute type: %w", err)</span>
        }

        <span class="cov0" title="0">return attributeType, nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package nodeattributes

import (
        "fmt"
        "time"

        "url-db/internal/models"
)

type Service interface {
        CreateNodeAttribute(nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttribute, error)
        GetNodeAttributeByID(id int) (*models.NodeAttributeWithInfo, error)
        GetNodeAttributesByNodeID(nodeID int) (*models.NodeAttributeListResponse, error)
        UpdateNodeAttribute(id int, req *models.UpdateNodeAttributeRequest) (*models.NodeAttribute, error)
        DeleteNodeAttribute(id int) error
        DeleteNodeAttributeByNodeIDAndAttributeID(nodeID, attributeID int) error
        ValidateNodeAttribute(nodeID int, req *models.CreateNodeAttributeRequest) error
}

type service struct {
        repo         Repository
        validator    Validator
        orderManager OrderManager
}

func NewService(repo Repository, validator Validator, orderManager OrderManager) Service <span class="cov8" title="1">{
        return &amp;service{
                repo:         repo,
                validator:    validator,
                orderManager: orderManager,
        }
}</span>

func (s *service) CreateNodeAttribute(nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttribute, error) <span class="cov8" title="1">{
        // Validate request
        if err := s.ValidateNodeAttribute(nodeID, req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if node and attribute belong to the same domain
        <span class="cov8" title="1">if err := s.repo.ValidateNodeAndAttributeDomain(nodeID, req.AttributeID); err != nil </span><span class="cov8" title="1">{
                return nil, ErrNodeAttributeDomainMismatch
        }</span>

        // Get attribute type for validation
        <span class="cov8" title="1">attrInfo, err := s.repo.GetByNodeIDAndAttributeID(nodeID, req.AttributeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get attribute info: %w", err)
        }</span>

        // For non-ordered attributes, check if attribute already exists for this node
        <span class="cov8" title="1">if attrInfo != nil </span><span class="cov0" title="0">{
                // If it's not an ordered tag, we don't allow duplicates
                if attrInfo.Type != models.AttributeTypeOrderedTag </span><span class="cov0" title="0">{
                        return nil, ErrNodeAttributeExists
                }</span>
        }

        // Get attribute type from database (we need to query attributes table)
        <span class="cov8" title="1">attributeType, err := s.getAttributeType(req.AttributeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get attribute type: %w", err)
        }</span>

        // Validate attribute value and order index
        <span class="cov8" title="1">if err := s.validator.Validate(attributeType, req.Value, req.OrderIndex); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // Handle order index for ordered tags
        <span class="cov8" title="1">var finalOrderIndex *int
        if attributeType == models.AttributeTypeOrderedTag </span><span class="cov0" title="0">{
                finalOrderIndex, err = s.orderManager.AssignOrderIndex(nodeID, req.AttributeID, req.OrderIndex)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to assign order index: %w", err)
                }</span>
        }

        // Create node attribute
        <span class="cov8" title="1">nodeAttribute := &amp;models.NodeAttribute{
                NodeID:      nodeID,
                AttributeID: req.AttributeID,
                Value:       req.Value,
                OrderIndex:  finalOrderIndex,
                CreatedAt:   time.Now(),
        }

        if err := s.repo.Create(nodeAttribute); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create node attribute: %w", err)
        }</span>

        <span class="cov8" title="1">return nodeAttribute, nil</span>
}

func (s *service) GetNodeAttributeByID(id int) (*models.NodeAttributeWithInfo, error) <span class="cov8" title="1">{
        nodeAttr, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node attribute: %w", err)
        }</span>

        <span class="cov8" title="1">if nodeAttr == nil </span><span class="cov8" title="1">{
                return nil, ErrNodeAttributeNotFound
        }</span>

        <span class="cov8" title="1">return nodeAttr, nil</span>
}

func (s *service) GetNodeAttributesByNodeID(nodeID int) (*models.NodeAttributeListResponse, error) <span class="cov0" title="0">{
        nodeAttrs, err := s.repo.GetByNodeID(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node attributes: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.NodeAttributeListResponse{
                Attributes: nodeAttrs,
        }, nil</span>
}

func (s *service) UpdateNodeAttribute(id int, req *models.UpdateNodeAttributeRequest) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        // Get existing node attribute
        existing, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get existing node attribute: %w", err)
        }</span>

        <span class="cov0" title="0">if existing == nil </span><span class="cov0" title="0">{
                return nil, ErrNodeAttributeNotFound
        }</span>

        // Validate attribute value and order index
        <span class="cov0" title="0">if err := s.validator.Validate(existing.Type, req.Value, req.OrderIndex); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // Handle order index for ordered tags
        <span class="cov0" title="0">var finalOrderIndex *int = req.OrderIndex
        if existing.Type == models.AttributeTypeOrderedTag </span><span class="cov0" title="0">{
                if req.OrderIndex != nil </span><span class="cov0" title="0">{
                        // Validate order index (excluding current item)
                        if err := s.orderManager.ValidateOrderIndex(existing.NodeID, existing.AttributeID, req.OrderIndex, &amp;id); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("order index validation failed: %w", err)
                        }</span>

                        // If order index changed, need to reorder
                        <span class="cov0" title="0">if existing.OrderIndex == nil || *existing.OrderIndex != *req.OrderIndex </span><span class="cov0" title="0">{
                                // Move other items to make space
                                if err := s.repo.ReorderAfterIndex(existing.NodeID, existing.AttributeID, *req.OrderIndex-1); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to reorder items: %w", err)
                                }</span>
                        }
                }
        }

        // Update node attribute
        <span class="cov0" title="0">updateReq := &amp;models.UpdateNodeAttributeRequest{
                Value:      req.Value,
                OrderIndex: finalOrderIndex,
        }

        updatedAttr, err := s.repo.Update(id, updateReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update node attribute: %w", err)
        }</span>

        <span class="cov0" title="0">return updatedAttr, nil</span>
}

func (s *service) DeleteNodeAttribute(id int) error <span class="cov0" title="0">{
        // Get existing node attribute for order management
        existing, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get existing node attribute: %w", err)
        }</span>

        <span class="cov0" title="0">if existing == nil </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        // Delete the node attribute
        <span class="cov0" title="0">if err := s.repo.Delete(id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete node attribute: %w", err)
        }</span>

        // Handle order reordering for ordered tags
        <span class="cov0" title="0">if existing.Type == models.AttributeTypeOrderedTag &amp;&amp; existing.OrderIndex != nil </span><span class="cov0" title="0">{
                if err := s.orderManager.ReorderAfterDeletion(existing.NodeID, existing.AttributeID, *existing.OrderIndex); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reorder after deletion: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *service) DeleteNodeAttributeByNodeIDAndAttributeID(nodeID, attributeID int) error <span class="cov0" title="0">{
        // Get existing node attribute for order management
        existing, err := s.repo.GetByNodeIDAndAttributeID(nodeID, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get existing node attribute: %w", err)
        }</span>

        <span class="cov0" title="0">if existing == nil </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        // Delete the node attribute
        <span class="cov0" title="0">if err := s.repo.DeleteByNodeIDAndAttributeID(nodeID, attributeID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete node attribute: %w", err)
        }</span>

        // Handle order reordering for ordered tags
        <span class="cov0" title="0">if existing.Type == models.AttributeTypeOrderedTag &amp;&amp; existing.OrderIndex != nil </span><span class="cov0" title="0">{
                if err := s.orderManager.ReorderAfterDeletion(existing.NodeID, existing.AttributeID, *existing.OrderIndex); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reorder after deletion: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *service) ValidateNodeAttribute(nodeID int, req *models.CreateNodeAttributeRequest) error <span class="cov8" title="1">{
        if req.AttributeID &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("attribute_id must be a positive integer")
        }</span>

        <span class="cov8" title="1">if req.Value == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("value cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(req.Value) &gt; 2048 </span><span class="cov8" title="1">{
                return fmt.Errorf("value must be 2048 characters or less")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *service) getAttributeType(attributeID int) (models.AttributeType, error) <span class="cov8" title="1">{
        return s.repo.GetAttributeType(attributeID)
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package nodeattributes

import (
        "fmt"
        "net/url"
        "regexp"
        "strconv"
        "strings"

        "url-db/internal/models"
)

type Validator interface {
        Validate(attributeType models.AttributeType, value string, orderIndex *int) error
        ValidateValue(attributeType models.AttributeType, value string) error
        ValidateOrderIndex(attributeType models.AttributeType, orderIndex *int) error
}

type validator struct{}

func NewValidator() Validator <span class="cov8" title="1">{
        return &amp;validator{}
}</span>

func (v *validator) Validate(attributeType models.AttributeType, value string, orderIndex *int) error <span class="cov8" title="1">{
        if err := v.ValidateValue(attributeType, value); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := v.ValidateOrderIndex(attributeType, orderIndex); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (v *validator) ValidateValue(attributeType models.AttributeType, value string) error <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("value cannot be empty")
        }</span>

        <span class="cov8" title="1">switch attributeType </span>{
        case models.AttributeTypeTag:<span class="cov8" title="1">
                return v.validateTag(value)</span>
        case models.AttributeTypeOrderedTag:<span class="cov8" title="1">
                return v.validateOrderedTag(value)</span>
        case models.AttributeTypeNumber:<span class="cov8" title="1">
                return v.validateNumber(value)</span>
        case models.AttributeTypeString:<span class="cov8" title="1">
                return v.validateString(value)</span>
        case models.AttributeTypeMarkdown:<span class="cov8" title="1">
                return v.validateMarkdown(value)</span>
        case models.AttributeTypeImage:<span class="cov8" title="1">
                return v.validateImage(value)</span>
        default:<span class="cov0" title="0">
                return ErrInvalidAttributeType</span>
        }
}

func (v *validator) ValidateOrderIndex(attributeType models.AttributeType, orderIndex *int) error <span class="cov8" title="1">{
        switch attributeType </span>{
        case models.AttributeTypeOrderedTag:<span class="cov8" title="1">
                if orderIndex == nil </span><span class="cov8" title="1">{
                        return ErrOrderIndexRequired
                }</span>
                <span class="cov8" title="1">if *orderIndex &lt; 0 </span><span class="cov8" title="1">{
                        return ErrInvalidOrderIndex
                }</span>
        case models.AttributeTypeTag, models.AttributeTypeNumber, models.AttributeTypeString, models.AttributeTypeMarkdown, models.AttributeTypeImage:<span class="cov8" title="1">
                if orderIndex != nil </span><span class="cov8" title="1">{
                        return ErrOrderIndexNotAllowed
                }</span>
        default:<span class="cov0" title="0">
                return ErrInvalidAttributeType</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (v *validator) validateTag(value string) error <span class="cov8" title="1">{
        if len(value) &gt; 255 </span><span class="cov8" title="1">{
                return fmt.Errorf("tag value must be 255 characters or less")
        }</span>

        // Basic tag validation - no special characters except hyphens and underscores
        <span class="cov8" title="1">if !regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).MatchString(value) </span><span class="cov8" title="1">{
                return fmt.Errorf("tag value can only contain letters, numbers, hyphens, and underscores")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (v *validator) validateOrderedTag(value string) error <span class="cov8" title="1">{
        if len(value) &gt; 255 </span><span class="cov8" title="1">{
                return fmt.Errorf("ordered tag value must be 255 characters or less")
        }</span>

        // Same validation as tag
        <span class="cov8" title="1">if !regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).MatchString(value) </span><span class="cov8" title="1">{
                return fmt.Errorf("ordered tag value can only contain letters, numbers, hyphens, and underscores")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (v *validator) validateNumber(value string) error <span class="cov8" title="1">{
        // Try to parse as float64 to support both integers and decimals
        _, err := strconv.ParseFloat(value, 64)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("number value must be a valid number")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (v *validator) validateString(value string) error <span class="cov8" title="1">{
        if len(value) &gt; 2048 </span><span class="cov8" title="1">{
                return fmt.Errorf("string value must be 2048 characters or less")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (v *validator) validateMarkdown(value string) error <span class="cov8" title="1">{
        if len(value) &gt; 10000 </span><span class="cov8" title="1">{
                return fmt.Errorf("markdown value must be 10000 characters or less")
        }</span>

        // Basic markdown validation - ensure it's valid text
        <span class="cov8" title="1">if strings.TrimSpace(value) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("markdown value cannot be empty or only whitespace")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (v *validator) validateImage(value string) error <span class="cov8" title="1">{
        // Validate URL format
        parsedURL, err := url.Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("image value must be a valid URL")
        }</span>

        <span class="cov8" title="1">if parsedURL.Scheme != "http" &amp;&amp; parsedURL.Scheme != "https" </span><span class="cov8" title="1">{
                return fmt.Errorf("image URL must use http or https scheme")
        }</span>

        // Validate image file extensions
        <span class="cov8" title="1">validExtensions := []string{".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg"}
        path := strings.ToLower(parsedURL.Path)

        isValidExtension := false
        for _, ext := range validExtensions </span><span class="cov8" title="1">{
                if strings.HasSuffix(path, ext) </span><span class="cov8" title="1">{
                        isValidExtension = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !isValidExtension </span><span class="cov8" title="1">{
                return fmt.Errorf("image URL must have a valid image file extension (.jpg, .jpeg, .png, .gif, .webp, .svg)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package nodes

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "url-db/internal/models"
)

type NodeHandler struct {
        service NodeService
}

func NewNodeHandler(service NodeService) *NodeHandler <span class="cov0" title="0">{
        return &amp;NodeHandler{service: service}
}</span>

// CreateNode godoc
// @Summary      Create a new URL node
// @Description  Create a new URL node in a domain
// @Tags         nodes
// @Accept       json
// @Produce      json
// @Param        domain_id  path      int                        true   "Domain ID"
// @Param        node       body      models.CreateNodeRequest  true   "Node data"
// @Success      201        {object}  models.Node
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      409        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /domains/{domain_id}/urls [post]
func (h *NodeHandler) CreateNode(c *gin.Context) <span class="cov0" title="0">{
        domainIDStr := c.Param("domain_id")
        domainID, err := strconv.Atoi(domainIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">node, err := h.service.CreateNode(domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrNodeDomainNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": "Domain not found",
                        })</span>
                case ErrNodeAlreadyExists:<span class="cov0" title="0">
                        c.JSON(http.StatusConflict, gin.H{
                                "error":   "conflict",
                                "message": "Node already exists",
                        })</span>
                case ErrNodeURLInvalid:<span class="cov0" title="0">
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "validation_error",
                                "message": "Invalid URL",
                        })</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error":   "internal_error",
                                "message": "Internal server error",
                        })</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, node)</span>
}

// GetNodesByDomain godoc
// @Summary      Get nodes by domain
// @Description  Get all nodes in a domain with pagination and optional search
// @Tags         nodes
// @Produce      json
// @Param        domain_id  path   int     true   "Domain ID"
// @Param        page       query  int     false  "Page number" default(1)
// @Param        size       query  int     false  "Page size" default(20)
// @Param        search     query  string  false  "Search term for URL content"
// @Success      200        {object}  models.NodeListResponse
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /domains/{domain_id}/urls [get]
func (h *NodeHandler) GetNodesByDomain(c *gin.Context) <span class="cov0" title="0">{
        domainIDStr := c.Param("domain_id")
        domainID, err := strconv.Atoi(domainIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        size, _ := strconv.Atoi(c.DefaultQuery("size", "20"))
        search := c.Query("search")

        var response *models.NodeListResponse
        if search != "" </span><span class="cov0" title="0">{
                response, err = h.service.SearchNodes(domainID, search, page, size)
        }</span> else<span class="cov0" title="0"> {
                response, err = h.service.GetNodesByDomainID(domainID, page, size)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrNodeDomainNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": "Domain not found",
                        })</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error":   "internal_error",
                                "message": "Internal server error",
                        })</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetNode godoc
// @Summary      Get a node
// @Description  Get node by ID
// @Tags         nodes
// @Produce      json
// @Param        id  path      int  true  "Node ID"
// @Success      200 {object}  models.Node
// @Failure      400 {object}  map[string]interface{}
// @Failure      404 {object}  map[string]interface{}
// @Failure      500 {object}  map[string]interface{}
// @Router       /urls/{id} [get]
func (h *NodeHandler) GetNode(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">node, err := h.service.GetNodeByID(id)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrNodeNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": "Node not found",
                        })</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error":   "internal_error",
                                "message": "Internal server error",
                        })</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

// UpdateNode godoc
// @Summary      Update a node
// @Description  Update node title and description by ID
// @Tags         nodes
// @Accept       json
// @Produce      json
// @Param        id    path      int                       true  "Node ID"
// @Param        node  body      models.UpdateNodeRequest  true  "Updated node data"
// @Success      200   {object}  models.Node
// @Failure      400   {object}  map[string]interface{}
// @Failure      404   {object}  map[string]interface{}
// @Failure      500   {object}  map[string]interface{}
// @Router       /urls/{id} [put]
func (h *NodeHandler) UpdateNode(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateNodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">node, err := h.service.UpdateNode(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrNodeNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": "Node not found",
                        })</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error":   "internal_error",
                                "message": "Internal server error",
                        })</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

// DeleteNode godoc
// @Summary      Delete a node
// @Description  Delete node by ID
// @Tags         nodes
// @Param        id  path  int  true  "Node ID"
// @Success      204
// @Failure      400  {object}  map[string]interface{}
// @Failure      404  {object}  map[string]interface{}
// @Failure      500  {object}  map[string]interface{}
// @Router       /urls/{id} [delete]
func (h *NodeHandler) DeleteNode(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid node ID",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.service.DeleteNode(id)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrNodeNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": "Node not found",
                        })</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error":   "internal_error",
                                "message": "Internal server error",
                        })</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// FindNodeByURL godoc
// @Summary      Find node by URL
// @Description  Find a node by its URL within a domain
// @Tags         nodes
// @Accept       json
// @Produce      json
// @Param        domain_id  path      int                         true  "Domain ID"
// @Param        request    body      models.FindNodeByURLRequest true  "URL to search for"
// @Success      200        {object}  models.Node
// @Failure      400        {object}  map[string]interface{}
// @Failure      404        {object}  map[string]interface{}
// @Failure      500        {object}  map[string]interface{}
// @Router       /domains/{domain_id}/urls/find [post]
func (h *NodeHandler) FindNodeByURL(c *gin.Context) <span class="cov0" title="0">{
        domainIDStr := c.Param("domain_id")
        domainID, err := strconv.Atoi(domainIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Invalid domain ID",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.FindNodeByURLRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">node, err := h.service.FindNodeByURL(domainID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrNodeNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": "Node not found",
                        })</span>
                case ErrNodeDomainNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "not_found",
                                "message": "Domain not found",
                        })</span>
                case ErrNodeURLInvalid:<span class="cov0" title="0">
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "validation_error",
                                "message": "Invalid URL",
                        })</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error":   "internal_error",
                                "message": "Internal server error",
                        })</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, node)</span>
}

func (h *NodeHandler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        api := r.Group("/api")
        </span><span class="cov0" title="0">{
                // Node creation by domain
                api.POST("/domains/:domain_id/urls", h.CreateNode)

                // Node list by domain
                api.GET("/domains/:domain_id/urls", h.GetNodesByDomain)

                // Find node by URL
                api.POST("/domains/:domain_id/urls/find", h.FindNodeByURL)

                // Individual node operations
                api.GET("/urls/:id", h.GetNode)
                api.PUT("/urls/:id", h.UpdateNode)
                api.DELETE("/urls/:id", h.DeleteNode)
        }</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package nodes

import (
        "database/sql"
        "fmt"
        "time"

        "url-db/internal/models"
)

type NodeRepository interface {
        Create(node *models.Node) error
        GetByID(id int) (*models.Node, error)
        GetByDomainID(domainID, page, size int) ([]models.Node, int, error)
        GetByURL(domainID int, url string) (*models.Node, error)
        Update(node *models.Node) error
        Delete(id int) error
        Search(domainID int, query string, page, size int) ([]models.Node, int, error)
        CheckDomainExists(domainID int) (bool, error)
}

type SQLiteNodeRepository struct {
        db *sql.DB
}

func NewSQLiteNodeRepository(db *sql.DB) NodeRepository <span class="cov8" title="1">{
        return &amp;SQLiteNodeRepository{db: db}
}</span>

func (r *SQLiteNodeRepository) Create(node *models.Node) error <span class="cov8" title="1">{
        query := `
                INSERT INTO nodes (content, domain_id, title, description, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        now := time.Now()
        result, err := r.db.Exec(query, node.Content, node.DomainID, node.Title, node.Description, now, now)
        if err != nil </span><span class="cov8" title="1">{
                if isUniqueConstraintError(err) </span><span class="cov8" title="1">{
                        return ErrNodeAlreadyExists
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to create node: %w", err)</span>
        }

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov8" title="1">node.ID = int(id)
        node.CreatedAt = now
        node.UpdatedAt = now

        return nil</span>
}

func (r *SQLiteNodeRepository) GetByID(id int) (*models.Node, error) <span class="cov8" title="1">{
        query := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE id = ?
        `

        node := &amp;models.Node{}
        err := r.db.QueryRow(query, id).Scan(
                &amp;node.ID,
                &amp;node.Content,
                &amp;node.DomainID,
                &amp;node.Title,
                &amp;node.Description,
                &amp;node.CreatedAt,
                &amp;node.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrNodeNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get node by id: %w", err)</span>
        }

        <span class="cov8" title="1">return node, nil</span>
}

func (r *SQLiteNodeRepository) GetByDomainID(domainID, page, size int) ([]models.Node, int, error) <span class="cov8" title="1">{
        offset := (page - 1) * size

        // Get total count
        countQuery := `SELECT COUNT(*) FROM nodes WHERE domain_id = ?`
        var totalCount int
        err := r.db.QueryRow(countQuery, domainID).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get total count: %w", err)
        }</span>

        // Get nodes with pagination
        <span class="cov8" title="1">query := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE domain_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.Query(query, domainID, size, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get nodes by domain id: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var nodes []models.Node
        for rows.Next() </span><span class="cov8" title="1">{
                var node models.Node
                err := rows.Scan(
                        &amp;node.ID,
                        &amp;node.Content,
                        &amp;node.DomainID,
                        &amp;node.Title,
                        &amp;node.Description,
                        &amp;node.CreatedAt,
                        &amp;node.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan node: %w", err)
                }</span>
                <span class="cov8" title="1">nodes = append(nodes, node)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("rows iteration error: %w", err)
        }</span>

        <span class="cov8" title="1">return nodes, totalCount, nil</span>
}

func (r *SQLiteNodeRepository) GetByURL(domainID int, url string) (*models.Node, error) <span class="cov8" title="1">{
        query := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE domain_id = ? AND content = ?
        `

        node := &amp;models.Node{}
        err := r.db.QueryRow(query, domainID, url).Scan(
                &amp;node.ID,
                &amp;node.Content,
                &amp;node.DomainID,
                &amp;node.Title,
                &amp;node.Description,
                &amp;node.CreatedAt,
                &amp;node.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrNodeNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get node by url: %w", err)</span>
        }

        <span class="cov8" title="1">return node, nil</span>
}

func (r *SQLiteNodeRepository) Update(node *models.Node) error <span class="cov8" title="1">{
        query := `
                UPDATE nodes
                SET title = ?, description = ?, updated_at = ?
                WHERE id = ?
        `

        now := time.Now()
        result, err := r.db.Exec(query, node.Title, node.Description, now, node.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update node: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">node.UpdatedAt = now
        return nil</span>
}

func (r *SQLiteNodeRepository) Delete(id int) error <span class="cov8" title="1">{
        query := `DELETE FROM nodes WHERE id = ?`

        result, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete node: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *SQLiteNodeRepository) Search(domainID int, query string, page, size int) ([]models.Node, int, error) <span class="cov8" title="1">{
        offset := (page - 1) * size
        searchPattern := "%" + query + "%"

        // Get total count
        countQuery := `
                SELECT COUNT(*) FROM nodes 
                WHERE domain_id = ? AND (title LIKE ? OR description LIKE ? OR content LIKE ?)
        `
        var totalCount int
        err := r.db.QueryRow(countQuery, domainID, searchPattern, searchPattern, searchPattern).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get search count: %w", err)
        }</span>

        // Get nodes with search and pagination
        <span class="cov8" title="1">searchQuery := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE domain_id = ? AND (title LIKE ? OR description LIKE ? OR content LIKE ?)
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.Query(searchQuery, domainID, searchPattern, searchPattern, searchPattern, size, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to search nodes: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var nodes []models.Node
        for rows.Next() </span><span class="cov8" title="1">{
                var node models.Node
                err := rows.Scan(
                        &amp;node.ID,
                        &amp;node.Content,
                        &amp;node.DomainID,
                        &amp;node.Title,
                        &amp;node.Description,
                        &amp;node.CreatedAt,
                        &amp;node.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan search result: %w", err)
                }</span>
                <span class="cov8" title="1">nodes = append(nodes, node)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("search rows iteration error: %w", err)
        }</span>

        <span class="cov8" title="1">return nodes, totalCount, nil</span>
}

func (r *SQLiteNodeRepository) CheckDomainExists(domainID int) (bool, error) <span class="cov8" title="1">{
        query := `SELECT COUNT(*) FROM domains WHERE id = ?`
        var count int
        err := r.db.QueryRow(query, domainID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check domain existence: %w", err)
        }</span>
        <span class="cov8" title="1">return count &gt; 0, nil</span>
}

func isUniqueConstraintError(err error) bool <span class="cov8" title="1">{
        return err != nil &amp;&amp; (err.Error() == "UNIQUE constraint failed: nodes.content, nodes.domain_id" ||
                err.Error() == "constraint failed: UNIQUE constraint failed: nodes.content, nodes.domain_id")
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">package nodes

import (
        "fmt"
        "math"
        "strings"

        "url-db/internal/models"
)

type NodeService interface {
        CreateNode(domainID int, req *models.CreateNodeRequest) (*models.Node, error)
        GetNodeByID(id int) (*models.Node, error)
        GetNodesByDomainID(domainID, page, size int) (*models.NodeListResponse, error)
        FindNodeByURL(domainID int, req *models.FindNodeByURLRequest) (*models.Node, error)
        UpdateNode(id int, req *models.UpdateNodeRequest) (*models.Node, error)
        DeleteNode(id int) error
        SearchNodes(domainID int, query string, page, size int) (*models.NodeListResponse, error)
}

type NodeServiceImpl struct {
        repo NodeRepository
}

func NewNodeService(repo NodeRepository) NodeService <span class="cov0" title="0">{
        return &amp;NodeServiceImpl{repo: repo}
}</span>

func (s *NodeServiceImpl) CreateNode(domainID int, req *models.CreateNodeRequest) (*models.Node, error) <span class="cov0" title="0">{
        // Validate domain exists
        exists, err := s.repo.CheckDomainExists(domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check domain existence: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, ErrNodeDomainNotFound
        }</span>

        // Validate URL
        <span class="cov0" title="0">if err := ValidateURL(req.URL); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if node already exists
        <span class="cov0" title="0">existingNode, err := s.repo.GetByURL(domainID, req.URL)
        if err != nil &amp;&amp; err != ErrNodeNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing node: %w", err)
        }</span>
        <span class="cov0" title="0">if existingNode != nil </span><span class="cov0" title="0">{
                return nil, ErrNodeAlreadyExists
        }</span>

        // Generate title if not provided
        <span class="cov0" title="0">title := strings.TrimSpace(req.Title)
        if title == "" </span><span class="cov0" title="0">{
                title = GenerateTitleFromURL(req.URL)
        }</span>

        // Create node
        <span class="cov0" title="0">node := &amp;models.Node{
                Content:     req.URL,
                DomainID:    domainID,
                Title:       title,
                Description: strings.TrimSpace(req.Description),
        }

        if err := s.repo.Create(node); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create node: %w", err)
        }</span>

        <span class="cov0" title="0">return node, nil</span>
}

func (s *NodeServiceImpl) GetNodeByID(id int) (*models.Node, error) <span class="cov0" title="0">{
        node, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node by id: %w", err)
        }</span>

        <span class="cov0" title="0">return node, nil</span>
}

func (s *NodeServiceImpl) GetNodesByDomainID(domainID, page, size int) (*models.NodeListResponse, error) <span class="cov0" title="0">{
        // Validate pagination parameters
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if size &lt; 1 || size &gt; 100 </span><span class="cov0" title="0">{
                size = 20
        }</span>

        // Check if domain exists
        <span class="cov0" title="0">exists, err := s.repo.CheckDomainExists(domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check domain existence: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, ErrNodeDomainNotFound
        }</span>

        <span class="cov0" title="0">nodes, totalCount, err := s.repo.GetByDomainID(domainID, page, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get nodes by domain id: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := int(math.Ceil(float64(totalCount) / float64(size)))

        return &amp;models.NodeListResponse{
                Nodes:      nodes,
                TotalCount: totalCount,
                Page:       page,
                Size:       size,
                TotalPages: totalPages,
        }, nil</span>
}

func (s *NodeServiceImpl) FindNodeByURL(domainID int, req *models.FindNodeByURLRequest) (*models.Node, error) <span class="cov0" title="0">{
        // Validate domain exists
        exists, err := s.repo.CheckDomainExists(domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check domain existence: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, ErrNodeDomainNotFound
        }</span>

        // Validate URL
        <span class="cov0" title="0">if err := ValidateURL(req.URL); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">node, err := s.repo.GetByURL(domainID, req.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find node by url: %w", err)
        }</span>

        <span class="cov0" title="0">return node, nil</span>
}

func (s *NodeServiceImpl) UpdateNode(id int, req *models.UpdateNodeRequest) (*models.Node, error) <span class="cov0" title="0">{
        // Get existing node
        node, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node for update: %w", err)
        }</span>

        // Update fields
        <span class="cov0" title="0">node.Title = strings.TrimSpace(req.Title)
        node.Description = strings.TrimSpace(req.Description)

        // Generate title if empty
        if node.Title == "" </span><span class="cov0" title="0">{
                node.Title = GenerateTitleFromURL(node.Content)
        }</span>

        <span class="cov0" title="0">if err := s.repo.Update(node); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update node: %w", err)
        }</span>

        <span class="cov0" title="0">return node, nil</span>
}

func (s *NodeServiceImpl) DeleteNode(id int) error <span class="cov0" title="0">{
        // Check if node exists
        _, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get node for deletion: %w", err)
        }</span>

        // Delete node (cascade will handle attributes)
        <span class="cov0" title="0">if err := s.repo.Delete(id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete node: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *NodeServiceImpl) SearchNodes(domainID int, query string, page, size int) (*models.NodeListResponse, error) <span class="cov0" title="0">{
        // Validate pagination parameters
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if size &lt; 1 || size &gt; 100 </span><span class="cov0" title="0">{
                size = 20
        }</span>

        // Check if domain exists
        <span class="cov0" title="0">exists, err := s.repo.CheckDomainExists(domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check domain existence: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, ErrNodeDomainNotFound
        }</span>

        // Validate search query
        <span class="cov0" title="0">query = strings.TrimSpace(query)
        if query == "" </span><span class="cov0" title="0">{
                return &amp;models.NodeListResponse{
                        Nodes:      []models.Node{},
                        TotalCount: 0,
                        Page:       page,
                        Size:       size,
                        TotalPages: 0,
                }, nil
        }</span>

        <span class="cov0" title="0">nodes, totalCount, err := s.repo.Search(domainID, query, page, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search nodes: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := int(math.Ceil(float64(totalCount) / float64(size)))

        return &amp;models.NodeListResponse{
                Nodes:      nodes,
                TotalCount: totalCount,
                Page:       page,
                Size:       size,
                TotalPages: totalPages,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package nodes

import (
        "fmt"
        "os"

        "url-db/internal/models"
        "url-db/internal/services"
)

// NodeServiceWithEvents wraps the basic node service and adds event tracking
type NodeServiceWithEvents struct {
        nodeService  NodeService
        eventService *services.EventService
}

// NewNodeServiceWithEvents creates a new node service with event tracking
func NewNodeServiceWithEvents(nodeService NodeService, eventService *services.EventService) NodeService <span class="cov0" title="0">{
        return &amp;NodeServiceWithEvents{
                nodeService:  nodeService,
                eventService: eventService,
        }
}</span>

func (s *NodeServiceWithEvents) CreateNode(domainID int, req *models.CreateNodeRequest) (*models.Node, error) <span class="cov0" title="0">{
        // Create the node using the wrapped service
        node, err := s.nodeService.CreateNode(domainID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create event for node creation
        <span class="cov0" title="0">changes := &amp;models.EventChanges{
                After: map[string]interface{}{
                        "url":         node.Content,
                        "title":       node.Title,
                        "description": node.Description,
                        "domain_id":   node.DomainID,
                },
        }

        if eventErr := s.eventService.CreateNodeEvent(int64(node.ID), "node.created", changes); eventErr != nil </span><span class="cov0" title="0">{
                // Log the error but don't fail the operation
                fmt.Fprintf(os.Stderr, "Warning: Failed to create event for node creation: %v\n", eventErr)
        }</span>

        <span class="cov0" title="0">return node, nil</span>
}

func (s *NodeServiceWithEvents) GetNodeByID(id int) (*models.Node, error) <span class="cov0" title="0">{
        return s.nodeService.GetNodeByID(id)
}</span>

func (s *NodeServiceWithEvents) GetNodesByDomainID(domainID, page, size int) (*models.NodeListResponse, error) <span class="cov0" title="0">{
        return s.nodeService.GetNodesByDomainID(domainID, page, size)
}</span>

func (s *NodeServiceWithEvents) FindNodeByURL(domainID int, req *models.FindNodeByURLRequest) (*models.Node, error) <span class="cov0" title="0">{
        return s.nodeService.FindNodeByURL(domainID, req)
}</span>

func (s *NodeServiceWithEvents) UpdateNode(id int, req *models.UpdateNodeRequest) (*models.Node, error) <span class="cov0" title="0">{
        // Get the existing node to capture before state
        existingNode, err := s.nodeService.GetNodeByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update the node using the wrapped service
        <span class="cov0" title="0">updatedNode, err := s.nodeService.UpdateNode(id, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create event for node update
        <span class="cov0" title="0">changes := &amp;models.EventChanges{
                Before: map[string]interface{}{
                        "title":       existingNode.Title,
                        "description": existingNode.Description,
                },
                After: map[string]interface{}{
                        "title":       updatedNode.Title,
                        "description": updatedNode.Description,
                },
        }

        if eventErr := s.eventService.CreateNodeEvent(int64(updatedNode.ID), "node.updated", changes); eventErr != nil </span><span class="cov0" title="0">{
                // Log the error but don't fail the operation
                fmt.Fprintf(os.Stderr, "Warning: Failed to create event for node update: %v\n", eventErr)
        }</span>

        <span class="cov0" title="0">return updatedNode, nil</span>
}

func (s *NodeServiceWithEvents) DeleteNode(id int) error <span class="cov0" title="0">{
        // Get the existing node to capture before state
        existingNode, err := s.nodeService.GetNodeByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete the node using the wrapped service
        <span class="cov0" title="0">if err := s.nodeService.DeleteNode(id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create event for node deletion
        <span class="cov0" title="0">changes := &amp;models.EventChanges{
                Before: map[string]interface{}{
                        "url":         existingNode.Content,
                        "title":       existingNode.Title,
                        "description": existingNode.Description,
                        "domain_id":   existingNode.DomainID,
                },
        }

        if eventErr := s.eventService.CreateNodeEvent(int64(existingNode.ID), "node.deleted", changes); eventErr != nil </span><span class="cov0" title="0">{
                // Log the error but don't fail the operation
                fmt.Fprintf(os.Stderr, "Warning: Failed to create event for node deletion: %v\n", eventErr)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *NodeServiceWithEvents) SearchNodes(domainID int, query string, page, size int) (*models.NodeListResponse, error) <span class="cov0" title="0">{
        return s.nodeService.SearchNodes(domainID, query, page, size)
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">package nodes

import (
        "net/url"
        "strings"
)

func GenerateTitleFromURL(rawURL string) string <span class="cov8" title="1">{
        if rawURL == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">parsedURL, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return extractTitleFromRawURL(rawURL)
        }</span>

        // Extract domain name
        <span class="cov8" title="1">host := parsedURL.Host
        if host == "" </span><span class="cov8" title="1">{
                return extractTitleFromRawURL(rawURL)
        }</span>

        // Remove www. prefix if present
        <span class="cov8" title="1">if strings.HasPrefix(host, "www.") </span><span class="cov8" title="1">{
                host = host[4:]
        }</span>

        // Get path for additional context
        <span class="cov8" title="1">path := parsedURL.Path
        if path == "" || path == "/" </span><span class="cov8" title="1">{
                return host
        }</span>

        // Handle trailing slash - if path ends with /, treat it as no meaningful path
        <span class="cov8" title="1">if strings.HasSuffix(path, "/") &amp;&amp; len(path) &gt; 1 </span><span class="cov8" title="1">{
                return host
        }</span>

        // Extract meaningful part from path
        <span class="cov8" title="1">pathParts := strings.Split(strings.Trim(path, "/"), "/")
        if len(pathParts) &gt; 0 </span><span class="cov8" title="1">{
                lastPart := pathParts[len(pathParts)-1]
                if lastPart != "" </span><span class="cov8" title="1">{
                        // Remove file extension if present
                        if dotIndex := strings.LastIndex(lastPart, "."); dotIndex &gt; 0 </span><span class="cov8" title="1">{
                                lastPart = lastPart[:dotIndex]
                        }</span>

                        // Replace dashes and underscores with spaces
                        <span class="cov8" title="1">lastPart = strings.ReplaceAll(lastPart, "-", " ")
                        lastPart = strings.ReplaceAll(lastPart, "_", " ")

                        // Capitalize first letter of each word
                        words := strings.Fields(lastPart)
                        for i, word := range words </span><span class="cov8" title="1">{
                                if len(word) &gt; 0 </span><span class="cov8" title="1">{
                                        words[i] = strings.ToUpper(word[:1]) + word[1:]
                                }</span>
                        }

                        <span class="cov8" title="1">return strings.Join(words, " ") + " - " + host</span>
                }
        }

        <span class="cov0" title="0">return host</span>
}

func extractTitleFromRawURL(rawURL string) string <span class="cov8" title="1">{
        // If URL parsing fails, try to extract meaningful parts manually
        if strings.Contains(rawURL, "://") </span><span class="cov8" title="1">{
                parts := strings.Split(rawURL, "://")
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        remaining := parts[1]
                        if slashIndex := strings.Index(remaining, "/"); slashIndex &gt;= 0 </span><span class="cov8" title="1">{
                                host := remaining[:slashIndex]
                                path := remaining[slashIndex+1:]

                                // Remove www. prefix
                                if strings.HasPrefix(host, "www.") </span><span class="cov8" title="1">{
                                        host = host[4:]
                                }</span>

                                <span class="cov8" title="1">if path != "" </span><span class="cov8" title="1">{
                                        pathParts := strings.Split(path, "/")
                                        if len(pathParts) &gt; 0 </span><span class="cov8" title="1">{
                                                lastPart := pathParts[len(pathParts)-1]
                                                if lastPart != "" </span><span class="cov8" title="1">{
                                                        return lastPart + " - " + host
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">return host</span>
                        } else<span class="cov8" title="1"> {
                                // No slash found, entire remaining part is the host
                                host := remaining
                                // Remove www. prefix
                                if strings.HasPrefix(host, "www.") </span><span class="cov0" title="0">{
                                        host = host[4:]
                                }</span>
                                <span class="cov8" title="1">return host</span>
                        }
                }
        }

        <span class="cov8" title="1">return rawURL</span>
}

func ValidateURL(rawURL string) error <span class="cov8" title="1">{
        if rawURL == "" </span><span class="cov8" title="1">{
                return ErrNodeURLInvalid
        }</span>

        <span class="cov8" title="1">if len(rawURL) &gt; 2048 </span><span class="cov8" title="1">{
                return ErrNodeURLInvalid
        }</span>

        // Basic URL validation - just check if it looks like a URL
        // We're being lenient here as per the requirements
        <span class="cov8" title="1">if !strings.Contains(rawURL, "://") &amp;&amp; !strings.HasPrefix(rawURL, "//") </span><span class="cov8" title="1">{
                return ErrNodeURLInvalid
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package repositories

import (
        "database/sql"
        "url-db/internal/models"
)

// sqliteAttributeRepository 는 SQLite 기반 속성 리포지토리 구현체입니다.
type sqliteAttributeRepository struct {
        *BaseRepository
}

// NewSQLiteAttributeRepository 는 새로운 SQLite 속성 리포지토리를 생성합니다.
func NewSQLiteAttributeRepository(db *sql.DB) AttributeRepository <span class="cov0" title="0">{
        return &amp;sqliteAttributeRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 속성을 생성합니다.
func (r *sqliteAttributeRepository) Create(attribute *models.Attribute) error <span class="cov0" title="0">{
        query := `
                INSERT INTO attributes (domain_id, name, type, description, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRow(query, attribute.DomainID, attribute.Name, attribute.Type, attribute.Description).Scan(
                &amp;attribute.ID, &amp;attribute.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID 는 ID로 속성을 조회합니다.
func (r *sqliteAttributeRepository) GetByID(id int) (*models.Attribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE id = ?
        `

        attribute := &amp;models.Attribute{}
        err := r.QueryRow(query, id).Scan(
                &amp;attribute.ID, &amp;attribute.DomainID, &amp;attribute.Name,
                &amp;attribute.Type, &amp;attribute.Description, &amp;attribute.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return attribute, nil</span>
}

// GetByDomainAndName 은 도메인 ID와 이름으로 속성을 조회합니다.
func (r *sqliteAttributeRepository) GetByDomainAndName(domainID int, name string) (*models.Attribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE domain_id = ? AND name = ?
        `

        attribute := &amp;models.Attribute{}
        err := r.QueryRow(query, domainID, name).Scan(
                &amp;attribute.ID, &amp;attribute.DomainID, &amp;attribute.Name,
                &amp;attribute.Type, &amp;attribute.Description, &amp;attribute.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return attribute, nil</span>
}

// ListByDomain 은 도메인별 속성 목록을 조회합니다.
func (r *sqliteAttributeRepository) ListByDomain(domainID int) ([]models.Attribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, domain_id, name, type, description, created_at
                FROM attributes
                WHERE domain_id = ?
                ORDER BY name
        `

        rows, err := r.Query(query, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var attributes []models.Attribute
        for rows.Next() </span><span class="cov0" title="0">{
                var attribute models.Attribute
                err := rows.Scan(&amp;attribute.ID, &amp;attribute.DomainID, &amp;attribute.Name,
                        &amp;attribute.Type, &amp;attribute.Description, &amp;attribute.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">attributes = append(attributes, attribute)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return attributes, nil</span>
}

// Update 는 속성 정보를 업데이트합니다.
func (r *sqliteAttributeRepository) Update(attribute *models.Attribute) error <span class="cov0" title="0">{
        query := `
                UPDATE attributes
                SET name = ?, type = ?, description = ?
                WHERE id = ?
        `

        result, err := r.Execute(query, attribute.Name, attribute.Type, attribute.Description, attribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete 는 속성을 삭제합니다.
func (r *sqliteAttributeRepository) Delete(id int) error <span class="cov0" title="0">{
        query := `DELETE FROM attributes WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExistsByDomainAndName 은 도메인 ID와 이름으로 속성 존재 여부를 확인합니다.
func (r *sqliteAttributeRepository) ExistsByDomainAndName(domainID int, name string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM attributes WHERE domain_id = ? AND name = ?)`

        var exists bool
        err := r.QueryRow(query, domainID, name).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// 트랜잭션 지원 메서드들

// CreateTx 는 트랜잭션 내에서 속성을 생성합니다.
func (r *sqliteAttributeRepository) CreateTx(tx *sql.Tx, attribute *models.Attribute) error <span class="cov0" title="0">{
        query := `
                INSERT INTO attributes (domain_id, name, type, description, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRowInTransaction(tx, query, attribute.DomainID, attribute.Name, attribute.Type, attribute.Description).Scan(
                &amp;attribute.ID, &amp;attribute.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 속성을 업데이트합니다.
func (r *sqliteAttributeRepository) UpdateTx(tx *sql.Tx, attribute *models.Attribute) error <span class="cov0" title="0">{
        query := `
                UPDATE attributes
                SET name = ?, type = ?, description = ?
                WHERE id = ?
        `

        result, err := r.ExecuteInTransaction(tx, query, attribute.Name, attribute.Type, attribute.Description, attribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 속성을 삭제합니다.
func (r *sqliteAttributeRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM attributes WHERE id = ?`

        result, err := r.ExecuteInTransaction(tx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package repositories

import (
        "database/sql"
)

// BaseRepository 는 모든 리포지토리의 공통 베이스 구조체입니다.
type BaseRepository struct {
        db *sql.DB
}

// NewBaseRepository 는 새로운 베이스 리포지토리를 생성합니다.
func NewBaseRepository(db *sql.DB) *BaseRepository <span class="cov8" title="1">{
        return &amp;BaseRepository{
                db: db,
        }
}</span>

// WithTransaction 은 트랜잭션을 사용하여 함수를 실행합니다.
func (r *BaseRepository) WithTransaction(fn func(tx *sql.Tx) error) error <span class="cov8" title="1">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        panic(r)</span>
                }
        }()

        <span class="cov8" title="1">if err := fn(tx); err != nil </span><span class="cov8" title="1">{
                if rbErr := tx.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                        // 롤백 실패 시 원래 에러와 함께 로그 (실제 구현에서는 로거 사용)
                        return MapSQLiteError(err)
                }</span>
                <span class="cov8" title="1">return MapSQLiteError(err)</span>
        }

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetDB 는 데이터베이스 연결을 반환합니다.
func (r *BaseRepository) GetDB() *sql.DB <span class="cov0" title="0">{
        return r.db
}</span>

// Ping 은 데이터베이스 연결을 확인합니다.
func (r *BaseRepository) Ping() error <span class="cov0" title="0">{
        return r.db.Ping()
}</span>

// Close 는 데이터베이스 연결을 닫습니다.
func (r *BaseRepository) Close() error <span class="cov0" title="0">{
        return r.db.Close()
}</span>

// ExecuteInTransaction 은 트랜잭션 내에서 쿼리를 실행합니다.
func (r *BaseRepository) ExecuteInTransaction(tx *sql.Tx, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        result, err := tx.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// QueryInTransaction 은 트랜잭션 내에서 쿼리를 실행하고 결과를 반환합니다.
func (r *BaseRepository) QueryInTransaction(tx *sql.Tx, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        rows, err := tx.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">return rows, nil</span>
}

// QueryRowInTransaction 은 트랜잭션 내에서 단일 행 쿼리를 실행합니다.
func (r *BaseRepository) QueryRowInTransaction(tx *sql.Tx, query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        return tx.QueryRow(query, args...)
}</span>

// PrepareStatement 는 프리페어드 스테이트먼트를 생성합니다.
func (r *BaseRepository) PrepareStatement(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">return stmt, nil</span>
}

// PrepareStatementInTransaction 은 트랜잭션 내에서 프리페어드 스테이트먼트를 생성합니다.
func (r *BaseRepository) PrepareStatementInTransaction(tx *sql.Tx, query string) (*sql.Stmt, error) <span class="cov8" title="1">{
        stmt, err := tx.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">return stmt, nil</span>
}

// Execute 는 쿼리를 실행합니다.
func (r *BaseRepository) Execute(query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        result, err := r.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// Query 는 쿼리를 실행하고 결과를 반환합니다.
func (r *BaseRepository) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">return rows, nil</span>
}

// QueryRow 는 단일 행 쿼리를 실행합니다.
func (r *BaseRepository) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        return r.db.QueryRow(query, args...)
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">package repositories

import (
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"
        "url-db/internal/models"
)

// DependencyRepository handles database operations for dependencies
type DependencyRepository struct {
        db *sqlx.DB
}

// NewDependencyRepository creates a new dependency repository
func NewDependencyRepository(db *sqlx.DB) *DependencyRepository <span class="cov0" title="0">{
        return &amp;DependencyRepository{db: db}
}</span>

// Create creates a new dependency
func (r *DependencyRepository) Create(dependency *models.NodeDependency) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_dependencies (
                        dependent_node_id, dependency_node_id, dependency_type,
                        cascade_delete, cascade_update, metadata
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(
                query,
                dependency.DependentNodeID,
                dependency.DependencyNodeID,
                dependency.DependencyType,
                dependency.CascadeDelete,
                dependency.CascadeUpdate,
                dependency.Metadata,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dependency: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov0" title="0">dependency.ID = id
        return nil</span>
}

// GetByID retrieves a dependency by ID
func (r *DependencyRepository) GetByID(id int64) (*models.NodeDependency, error) <span class="cov0" title="0">{
        var dependency models.NodeDependency
        query := `
                SELECT id, dependent_node_id, dependency_node_id, dependency_type,
                           cascade_delete, cascade_update, metadata, created_at
                FROM node_dependencies
                WHERE id = ?
        `

        err := r.db.Get(&amp;dependency, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get dependency: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;dependency, nil</span>
}

// GetByDependentNode retrieves all dependencies for a dependent node
func (r *DependencyRepository) GetByDependentNode(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        var dependencies []*models.NodeDependency
        query := `
                SELECT id, dependent_node_id, dependency_node_id, dependency_type,
                           cascade_delete, cascade_update, metadata, created_at
                FROM node_dependencies
                WHERE dependent_node_id = ?
                ORDER BY created_at DESC
        `

        err := r.db.Select(&amp;dependencies, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependencies: %w", err)
        }</span>

        <span class="cov0" title="0">return dependencies, nil</span>
}

// GetByDependencyNode retrieves all dependencies where a node is the dependency
func (r *DependencyRepository) GetByDependencyNode(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        var dependencies []*models.NodeDependency
        query := `
                SELECT id, dependent_node_id, dependency_node_id, dependency_type,
                           cascade_delete, cascade_update, metadata, created_at
                FROM node_dependencies
                WHERE dependency_node_id = ?
                ORDER BY created_at DESC
        `

        err := r.db.Select(&amp;dependencies, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependencies: %w", err)
        }</span>

        <span class="cov0" title="0">return dependencies, nil</span>
}

// CheckCircularDependency checks if creating a dependency would create a circular reference
func (r *DependencyRepository) CheckCircularDependency(dependentID, dependencyID int64) (bool, error) <span class="cov0" title="0">{
        // Recursive CTE to check for circular dependencies
        query := `
                WITH RECURSIVE dependency_chain AS (
                        SELECT dependent_node_id, dependency_node_id
                        FROM node_dependencies
                        WHERE dependent_node_id = ?
                        
                        UNION
                        
                        SELECT nd.dependent_node_id, nd.dependency_node_id
                        FROM node_dependencies nd
                        INNER JOIN dependency_chain dc ON nd.dependent_node_id = dc.dependency_node_id
                )
                SELECT COUNT(*) FROM dependency_chain WHERE dependency_node_id = ?
        `

        var count int
        err := r.db.Get(&amp;count, query, dependencyID, dependentID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check circular dependency: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// Delete deletes a dependency
func (r *DependencyRepository) Delete(id int64) error <span class="cov0" title="0">{
        query := "DELETE FROM node_dependencies WHERE id = ?"

        result, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete dependency: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDependentsWithCascadeDelete retrieves all dependent nodes that should be deleted
func (r *DependencyRepository) GetDependentsWithCascadeDelete(nodeID int64) ([]int64, error) <span class="cov0" title="0">{
        var dependentIDs []int64
        query := `
                SELECT dependent_node_id
                FROM node_dependencies
                WHERE dependency_node_id = ? AND cascade_delete = true
        `

        err := r.db.Select(&amp;dependentIDs, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cascade delete dependents: %w", err)
        }</span>

        <span class="cov0" title="0">return dependentIDs, nil</span>
}

// GetDependentsWithCascadeUpdate retrieves all dependent nodes that should be notified
func (r *DependencyRepository) GetDependentsWithCascadeUpdate(nodeID int64) ([]int64, error) <span class="cov0" title="0">{
        var dependentIDs []int64
        query := `
                SELECT dependent_node_id
                FROM node_dependencies
                WHERE dependency_node_id = ? AND cascade_update = true
        `

        err := r.db.Select(&amp;dependentIDs, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cascade update dependents: %w", err)
        }</span>

        <span class="cov0" title="0">return dependentIDs, nil</span>
}

// GetDependency retrieves a specific dependency by dependent and dependency node IDs
func (r *DependencyRepository) GetDependency(dependentID, dependencyID int64) (*models.NodeDependency, error) <span class="cov0" title="0">{
        var dependency models.NodeDependency
        query := `
                SELECT id, dependent_node_id, dependency_node_id, dependency_type,
                           cascade_delete, cascade_update, metadata, created_at
                FROM node_dependencies
                WHERE dependent_node_id = ? AND dependency_node_id = ?
        `

        err := r.db.Get(&amp;dependency, query, dependentID, dependencyID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get dependency: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;dependency, nil</span>
}

// GetNodeDependencies retrieves all dependencies for a node
func (r *DependencyRepository) GetNodeDependencies(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        return r.GetByDependentNode(nodeID)
}</span>

// GetNodeDependents retrieves all nodes that depend on the given node
func (r *DependencyRepository) GetNodeDependents(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        return r.GetByDependencyNode(nodeID)
}</span>

// GetActiveRules retrieves active dependency rules for a node
func (r *DependencyRepository) GetActiveRules(nodeID int64) ([]*models.DependencyRule, error) <span class="cov0" title="0">{
        var rules []*models.DependencyRule
        // For now, return empty slice as dependency rules are not fully implemented
        return rules, nil
}</span>

// GetCachedGraph retrieves cached dependency graph
func (r *DependencyRepository) GetCachedGraph(nodeID int64) (*models.DependencyGraphCache, error) <span class="cov0" title="0">{
        var cache models.DependencyGraphCache
        query := `
                SELECT id, node_id, graph_data, max_depth, created_at, expires_at
                FROM dependency_graph_cache
                WHERE node_id = ?
                ORDER BY created_at DESC
                LIMIT 1
        `

        err := r.db.Get(&amp;cache, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get cached graph: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;cache, nil</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package repositories

import (
        "database/sql"
        "url-db/internal/models"
)

// sqliteDomainRepository 는 SQLite 기반 도메인 리포지토리 구현체입니다.
type sqliteDomainRepository struct {
        *BaseRepository
}

// NewSQLiteDomainRepository 는 새로운 SQLite 도메인 리포지토리를 생성합니다.
func NewSQLiteDomainRepository(db *sql.DB) DomainRepository <span class="cov8" title="1">{
        return &amp;sqliteDomainRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 도메인을 생성합니다.
func (r *sqliteDomainRepository) Create(domain *models.Domain) error <span class="cov8" title="1">{
        query := `
                INSERT INTO domains (name, description, created_at, updated_at)
                VALUES (?, ?, datetime('now'), datetime('now'))
                RETURNING id, created_at, updated_at
        `

        err := r.QueryRow(query, domain.Name, domain.Description).Scan(
                &amp;domain.ID, &amp;domain.CreatedAt, &amp;domain.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetByID 는 ID로 도메인을 조회합니다.
func (r *sqliteDomainRepository) GetByID(id int) (*models.Domain, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM domains
                WHERE id = ?
        `

        domain := &amp;models.Domain{}
        err := r.QueryRow(query, id).Scan(
                &amp;domain.ID, &amp;domain.Name, &amp;domain.Description,
                &amp;domain.CreatedAt, &amp;domain.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return domain, nil</span>
}

// GetByName 은 이름으로 도메인을 조회합니다.
func (r *sqliteDomainRepository) GetByName(name string) (*models.Domain, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM domains
                WHERE name = ?
        `

        domain := &amp;models.Domain{}
        err := r.QueryRow(query, name).Scan(
                &amp;domain.ID, &amp;domain.Name, &amp;domain.Description,
                &amp;domain.CreatedAt, &amp;domain.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return domain, nil</span>
}

// List 는 도메인 목록을 페이지네이션과 함께 조회합니다.
func (r *sqliteDomainRepository) List(offset, limit int) ([]models.Domain, int, error) <span class="cov8" title="1">{
        // 데이터 조회
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM domains
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var domains []models.Domain
        for rows.Next() </span><span class="cov8" title="1">{
                var domain models.Domain
                err := rows.Scan(&amp;domain.ID, &amp;domain.Name, &amp;domain.Description,
                        &amp;domain.CreatedAt, &amp;domain.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov8" title="1">domains = append(domains, domain)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov8" title="1">countQuery := `SELECT COUNT(*) FROM domains`
        var total int
        err = r.QueryRow(countQuery).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return domains, total, nil</span>
}

// Update 는 도메인 정보를 업데이트합니다.
func (r *sqliteDomainRepository) Update(domain *models.Domain) error <span class="cov8" title="1">{
        query := `
                UPDATE domains
                SET name = ?, description = ?, updated_at = datetime('now')
                WHERE id = ?
                RETURNING updated_at
        `

        err := r.QueryRow(query, domain.Name, domain.Description, domain.ID).Scan(
                &amp;domain.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete 는 도메인을 삭제합니다.
func (r *sqliteDomainRepository) Delete(id int) error <span class="cov8" title="1">{
        query := `DELETE FROM domains WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrDomainNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ExistsByName 은 이름으로 도메인 존재 여부를 확인합니다.
func (r *sqliteDomainRepository) ExistsByName(name string) (bool, error) <span class="cov8" title="1">{
        query := `SELECT EXISTS(SELECT 1 FROM domains WHERE name = ?)`

        var exists bool
        err := r.QueryRow(query, name).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// 트랜잭션 지원 메서드들

// CreateTx 는 트랜잭션 내에서 도메인을 생성합니다.
func (r *sqliteDomainRepository) CreateTx(tx *sql.Tx, domain *models.Domain) error <span class="cov8" title="1">{
        query := `
                INSERT INTO domains (name, description, created_at, updated_at)
                VALUES (?, ?, datetime('now'), datetime('now'))
                RETURNING id, created_at, updated_at
        `

        err := r.QueryRowInTransaction(tx, query, domain.Name, domain.Description).Scan(
                &amp;domain.ID, &amp;domain.CreatedAt, &amp;domain.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 도메인을 업데이트합니다.
func (r *sqliteDomainRepository) UpdateTx(tx *sql.Tx, domain *models.Domain) error <span class="cov0" title="0">{
        query := `
                UPDATE domains
                SET name = ?, description = ?, updated_at = datetime('now')
                WHERE id = ?
                RETURNING updated_at
        `

        err := r.QueryRowInTransaction(tx, query, domain.Name, domain.Description, domain.ID).Scan(
                &amp;domain.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrDomainNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 도메인을 삭제합니다.
func (r *sqliteDomainRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM domains WHERE id = ?`

        result, err := r.ExecuteInTransaction(tx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrDomainNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package repositories

import (
        "database/sql"
        "errors"
        "strings"
)

// 리포지토리 에러 정의
var (
        ErrDomainNotFound         = errors.New("domain not found")
        ErrNodeNotFound           = errors.New("node not found")
        ErrAttributeNotFound      = errors.New("attribute not found")
        ErrNodeAttributeNotFound  = errors.New("node attribute not found")
        ErrNodeConnectionNotFound = errors.New("node connection not found")
        ErrDuplicateEntry         = errors.New("duplicate entry")
        ErrForeignKeyConstraint   = errors.New("foreign key constraint violation")
        ErrInvalidInput           = errors.New("invalid input")
        ErrConnectionTimeout      = errors.New("database connection timeout")
        ErrTransactionFailed      = errors.New("transaction failed")
)

// SQLiteError 는 SQLite 관련 에러를 처리하는 구조체입니다.
type SQLiteError struct {
        Code    int
        Message string
        Query   string
}

func (e SQLiteError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// MapSQLiteError 는 SQLite 에러를 도메인 에러로 매핑합니다.
func MapSQLiteError(err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // sql.ErrNoRows 처리
        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrDomainNotFound // 기본값, 각 리포지토리에서 적절히 변경
        }</span>

        // SQLite 에러 처리 (문자열 기반)
        <span class="cov8" title="1">errStr := err.Error()
        if strings.Contains(errStr, "UNIQUE constraint failed") </span><span class="cov8" title="1">{
                return ErrDuplicateEntry
        }</span>
        <span class="cov8" title="1">if strings.Contains(errStr, "FOREIGN KEY constraint failed") </span><span class="cov0" title="0">{
                return ErrForeignKeyConstraint
        }</span>
        <span class="cov8" title="1">if strings.Contains(errStr, "CHECK constraint failed") ||
                strings.Contains(errStr, "NOT NULL constraint failed") </span><span class="cov0" title="0">{
                return ErrInvalidInput
        }</span>
        <span class="cov8" title="1">if strings.Contains(errStr, "database is locked") ||
                strings.Contains(errStr, "database is busy") </span><span class="cov0" title="0">{
                return ErrConnectionTimeout
        }</span>

        <span class="cov8" title="1">return err</span>
}

// IsNotFoundError 는 해당 에러가 "찾을 수 없음" 에러인지 확인합니다.
func IsNotFoundError(err error) bool <span class="cov0" title="0">{
        return err == ErrDomainNotFound ||
                err == ErrNodeNotFound ||
                err == ErrAttributeNotFound ||
                err == ErrNodeAttributeNotFound ||
                err == ErrNodeConnectionNotFound
}</span>

// IsDuplicateError 는 해당 에러가 중복 에러인지 확인합니다.
func IsDuplicateError(err error) bool <span class="cov0" title="0">{
        return err == ErrDuplicateEntry
}</span>

// IsForeignKeyError 는 해당 에러가 외래키 제약 조건 에러인지 확인합니다.
func IsForeignKeyError(err error) bool <span class="cov0" title="0">{
        return err == ErrForeignKeyConstraint
}</span>

// IsInvalidInputError 는 해당 에러가 잘못된 입력 에러인지 확인합니다.
func IsInvalidInputError(err error) bool <span class="cov0" title="0">{
        return err == ErrInvalidInput
}</span>

// IsConnectionError 는 해당 에러가 연결 관련 에러인지 확인합니다.
func IsConnectionError(err error) bool <span class="cov0" title="0">{
        return err == ErrConnectionTimeout
}</span>

// IsTransactionError 는 해당 에러가 트랜잭션 관련 에러인지 확인합니다.
func IsTransactionError(err error) bool <span class="cov0" title="0">{
        return err == ErrTransactionFailed
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">package repositories

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/jmoiron/sqlx"
        "url-db/internal/models"
)

// EventRepository handles database operations for events
type EventRepository struct {
        db *sqlx.DB
}

// NewEventRepository creates a new event repository
func NewEventRepository(db *sqlx.DB) *EventRepository <span class="cov0" title="0">{
        return &amp;EventRepository{db: db}
}</span>

// Create creates a new event
func (r *EventRepository) Create(event *models.NodeEvent) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_events (
                        node_id, event_type, event_data
                ) VALUES (?, ?, ?)
        `

        result, err := r.db.Exec(
                query,
                event.NodeID,
                event.EventType,
                event.EventData,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create event: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov0" title="0">event.ID = id
        return nil</span>
}

// GetByID retrieves an event by ID
func (r *EventRepository) GetByID(id int64) (*models.NodeEvent, error) <span class="cov0" title="0">{
        var event models.NodeEvent
        query := `
                SELECT id, node_id, event_type, event_data, occurred_at, processed_at
                FROM node_events
                WHERE id = ?
        `

        err := r.db.Get(&amp;event, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get event: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;event, nil</span>
}

// GetByNode retrieves all events for a specific node
func (r *EventRepository) GetByNode(nodeID int64, limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        var events []*models.NodeEvent
        query := `
                SELECT id, node_id, event_type, event_data, occurred_at, processed_at
                FROM node_events
                WHERE node_id = ?
                ORDER BY occurred_at DESC
                LIMIT ?
        `

        err := r.db.Select(&amp;events, query, nodeID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get events: %w", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// GetPendingEvents retrieves unprocessed events
func (r *EventRepository) GetPendingEvents(limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        var events []*models.NodeEvent
        query := `
                SELECT id, node_id, event_type, event_data, occurred_at, processed_at
                FROM node_events
                WHERE processed_at IS NULL
                ORDER BY occurred_at ASC
                LIMIT ?
        `

        err := r.db.Select(&amp;events, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending events: %w", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// MarkAsProcessed marks an event as processed
func (r *EventRepository) MarkAsProcessed(id int64) error <span class="cov0" title="0">{
        query := "UPDATE node_events SET processed_at = ? WHERE id = ?"

        _, err := r.db.Exec(query, time.Now(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark event as processed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByTypeAndDateRange retrieves events by type within a date range
func (r *EventRepository) GetByTypeAndDateRange(eventType string, start, end time.Time) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        var events []*models.NodeEvent
        query := `
                SELECT id, node_id, event_type, event_data, occurred_at, processed_at
                FROM node_events
                WHERE event_type = ? AND occurred_at BETWEEN ? AND ?
                ORDER BY occurred_at DESC
        `

        err := r.db.Select(&amp;events, query, eventType, start, end)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get events by type and date: %w", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// DeleteOldEvents deletes events older than the specified duration
func (r *EventRepository) DeleteOldEvents(olderThan time.Duration) (int64, error) <span class="cov0" title="0">{
        cutoffTime := time.Now().Add(-olderThan)
        query := "DELETE FROM node_events WHERE occurred_at &lt; ? AND processed_at IS NOT NULL"

        result, err := r.db.Exec(query, cutoffTime)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to delete old events: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// GetEventStats retrieves statistics about events
func (r *EventRepository) GetEventStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Total events
        var totalEvents int
        err := r.db.Get(&amp;totalEvents, "SELECT COUNT(*) FROM node_events")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total events: %w", err)
        }</span>
        <span class="cov0" title="0">stats["total_events"] = totalEvents

        // Pending events
        var pendingEvents int
        err = r.db.Get(&amp;pendingEvents, "SELECT COUNT(*) FROM node_events WHERE processed_at IS NULL")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending events: %w", err)
        }</span>
        <span class="cov0" title="0">stats["pending_events"] = pendingEvents

        // Events by type
        type eventTypeCount struct {
                EventType string `db:"event_type"`
                Count     int    `db:"count"`
        }
        var eventTypeCounts []eventTypeCount

        query := `
                SELECT event_type, COUNT(*) as count
                FROM node_events
                GROUP BY event_type
                ORDER BY count DESC
        `
        err = r.db.Select(&amp;eventTypeCounts, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get events by type: %w", err)
        }</span>

        <span class="cov0" title="0">eventsByType := make(map[string]int)
        for _, etc := range eventTypeCounts </span><span class="cov0" title="0">{
                eventsByType[etc.EventType] = etc.Count
        }</span>
        <span class="cov0" title="0">stats["events_by_type"] = eventsByType

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "url-db/internal/models"
)

// DomainRepository 는 도메인 데이터 접근을 위한 인터페이스입니다.
type DomainRepository interface {
        Create(domain *models.Domain) error
        GetByID(id int) (*models.Domain, error)
        GetByName(name string) (*models.Domain, error)
        List(offset, limit int) ([]models.Domain, int, error)
        Update(domain *models.Domain) error
        Delete(id int) error
        ExistsByName(name string) (bool, error)

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, domain *models.Domain) error
        UpdateTx(tx *sql.Tx, domain *models.Domain) error
        DeleteTx(tx *sql.Tx, id int) error
}

// NodeRepository 는 노드 데이터 접근을 위한 인터페이스입니다.
type NodeRepository interface {
        Create(node *models.Node) error
        GetByID(id int) (*models.Node, error)
        GetByDomainAndContent(domainID int, content string) (*models.Node, error)
        ListByDomain(domainID int, offset, limit int) ([]models.Node, int, error)
        Search(domainID int, query string, offset, limit int) ([]models.Node, int, error)
        Update(node *models.Node) error
        Delete(id int) error
        ExistsByDomainAndContent(domainID int, content string) (bool, error)
        CountNodesByDomain(ctx context.Context, domainID int) (int, error)

        // 배치 처리 메서드
        BatchCreate(nodes []models.Node) error
        BatchUpdate(nodes []models.Node) error
        BatchDelete(ids []int) error

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, node *models.Node) error
        UpdateTx(tx *sql.Tx, node *models.Node) error
        DeleteTx(tx *sql.Tx, id int) error
}

// AttributeRepository 는 속성 데이터 접근을 위한 인터페이스입니다.
type AttributeRepository interface {
        Create(attribute *models.Attribute) error
        GetByID(id int) (*models.Attribute, error)
        GetByDomainAndName(domainID int, name string) (*models.Attribute, error)
        ListByDomain(domainID int) ([]models.Attribute, error)
        Update(attribute *models.Attribute) error
        Delete(id int) error
        ExistsByDomainAndName(domainID int, name string) (bool, error)

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, attribute *models.Attribute) error
        UpdateTx(tx *sql.Tx, attribute *models.Attribute) error
        DeleteTx(tx *sql.Tx, id int) error
}

// NodeAttributeRepository 는 노드 속성 데이터 접근을 위한 인터페이스입니다.
type NodeAttributeRepository interface {
        Create(nodeAttribute *models.NodeAttribute) error
        GetByID(id int) (*models.NodeAttribute, error)
        GetByNodeAndAttribute(nodeID, attributeID int) (*models.NodeAttribute, error)
        ListByNode(nodeID int) ([]models.NodeAttributeWithInfo, error)
        ListByAttribute(attributeID int) ([]models.NodeAttribute, error)
        Update(nodeAttribute *models.NodeAttribute) error
        Delete(id int) error
        DeleteByNode(nodeID int) error
        DeleteByAttribute(attributeID int) error
        ExistsByNodeAndAttribute(nodeID, attributeID int) (bool, error)

        // 배치 처리 메서드
        BatchCreate(nodeAttributes []models.NodeAttribute) error
        BatchUpdate(nodeAttributes []models.NodeAttribute) error
        BatchDeleteByNode(nodeID int) error
        BatchDeleteByAttribute(attributeID int) error

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, nodeAttribute *models.NodeAttribute) error
        UpdateTx(tx *sql.Tx, nodeAttribute *models.NodeAttribute) error
        DeleteTx(tx *sql.Tx, id int) error
}

// NodeConnectionRepository 는 노드 연결 데이터 접근을 위한 인터페이스입니다.
type NodeConnectionRepository interface {
        Create(ctx context.Context, connection *models.NodeConnection) error
        GetByID(ctx context.Context, id int) (*models.NodeConnection, error)
        GetBySourceAndTarget(ctx context.Context, sourceNodeID, targetNodeID int, relationshipType string) (*models.NodeConnection, error)
        ListBySourceNode(ctx context.Context, sourceNodeID int, offset, limit int) ([]models.NodeConnectionWithInfo, int, error)
        ListByTargetNode(ctx context.Context, targetNodeID int, offset, limit int) ([]models.NodeConnectionWithInfo, int, error)
        ListByRelationshipType(ctx context.Context, relationshipType string, offset, limit int) ([]models.NodeConnectionWithInfo, int, error)
        Update(ctx context.Context, connection *models.NodeConnection) error
        Delete(ctx context.Context, id int) error
        DeleteBySourceNode(ctx context.Context, sourceNodeID int) error
        DeleteByTargetNode(ctx context.Context, targetNodeID int) error
        ExistsBySourceAndTarget(ctx context.Context, sourceNodeID, targetNodeID int, relationshipType string) (bool, error)

        // 배치 처리 메서드
        BatchCreate(ctx context.Context, connections []models.NodeConnection) error
        BatchDelete(ctx context.Context, ids []int) error

        // 트랜잭션 지원 메서드
        CreateTx(tx *sql.Tx, connection *models.NodeConnection) error
        UpdateTx(tx *sql.Tx, connection *models.NodeConnection) error
        DeleteTx(tx *sql.Tx, id int) error
}

// Transactional 은 트랜잭션을 지원하는 인터페이스입니다.
type Transactional interface {
        WithTransaction(fn func(tx *sql.Tx) error) error
}

// Repositories 는 모든 리포지토리를 포함하는 구조체입니다.
type Repositories struct {
        Domain        DomainRepository
        Node          NodeRepository
        Attribute     AttributeRepository
        NodeAttribute NodeAttributeRepository
}

// NewRepositories 는 새로운 리포지토리 컬렉션을 생성합니다.
func NewRepositories(db *sql.DB) *Repositories <span class="cov0" title="0">{
        return &amp;Repositories{
                Domain:        NewSQLiteDomainRepository(db),
                Node:          NewSQLiteNodeRepository(db),
                Attribute:     NewSQLiteAttributeRepository(db),
                NodeAttribute: NewSQLiteNodeAttributeRepository(db),
        }
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "url-db/internal/models"
)

// sqliteNodeRepository 는 SQLite 기반 노드 리포지토리 구현체입니다.
type sqliteNodeRepository struct {
        *BaseRepository
}

// NewSQLiteNodeRepository 는 새로운 SQLite 노드 리포지토리를 생성합니다.
func NewSQLiteNodeRepository(db *sql.DB) NodeRepository <span class="cov8" title="1">{
        return &amp;sqliteNodeRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 노드를 생성합니다.
func (r *sqliteNodeRepository) Create(node *models.Node) error <span class="cov8" title="1">{
        query := `
                INSERT INTO nodes (content, domain_id, title, description, created_at, updated_at)
                VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))
                RETURNING id, created_at, updated_at
        `

        err := r.QueryRow(query, node.Content, node.DomainID, node.Title, node.Description).Scan(
                &amp;node.ID, &amp;node.CreatedAt, &amp;node.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetByID 는 ID로 노드를 조회합니다.
func (r *sqliteNodeRepository) GetByID(id int) (*models.Node, error) <span class="cov8" title="1">{
        query := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE id = ?
        `

        node := &amp;models.Node{}
        err := r.QueryRow(query, id).Scan(
                &amp;node.ID, &amp;node.Content, &amp;node.DomainID, &amp;node.Title,
                &amp;node.Description, &amp;node.CreatedAt, &amp;node.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return node, nil</span>
}

// GetByDomainAndContent 는 도메인 ID와 콘텐츠로 노드를 조회합니다.
func (r *sqliteNodeRepository) GetByDomainAndContent(domainID int, content string) (*models.Node, error) <span class="cov8" title="1">{
        query := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE domain_id = ? AND content = ?
        `

        node := &amp;models.Node{}
        err := r.QueryRow(query, domainID, content).Scan(
                &amp;node.ID, &amp;node.Content, &amp;node.DomainID, &amp;node.Title,
                &amp;node.Description, &amp;node.CreatedAt, &amp;node.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return node, nil</span>
}

// ListByDomain 은 도메인별 노드 목록을 페이지네이션과 함께 조회합니다.
func (r *sqliteNodeRepository) ListByDomain(domainID int, offset, limit int) ([]models.Node, int, error) <span class="cov8" title="1">{
        // 데이터 조회
        query := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE domain_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, domainID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var nodes []models.Node
        for rows.Next() </span><span class="cov8" title="1">{
                var node models.Node
                err := rows.Scan(&amp;node.ID, &amp;node.Content, &amp;node.DomainID, &amp;node.Title,
                        &amp;node.Description, &amp;node.CreatedAt, &amp;node.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov8" title="1">nodes = append(nodes, node)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov8" title="1">countQuery := `SELECT COUNT(*) FROM nodes WHERE domain_id = ?`
        var total int
        err = r.QueryRow(countQuery, domainID).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nodes, total, nil</span>
}

// Search 는 도메인 내에서 노드를 검색합니다.
func (r *sqliteNodeRepository) Search(domainID int, query string, offset, limit int) ([]models.Node, int, error) <span class="cov8" title="1">{
        // 데이터 검색
        searchQuery := `
                SELECT id, content, domain_id, title, description, created_at, updated_at
                FROM nodes
                WHERE domain_id = ? AND (title LIKE ? OR content LIKE ? OR description LIKE ?)
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        searchPattern := "%" + query + "%"
        rows, err := r.Query(searchQuery, domainID, searchPattern, searchPattern, searchPattern, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var nodes []models.Node
        for rows.Next() </span><span class="cov8" title="1">{
                var node models.Node
                err := rows.Scan(&amp;node.ID, &amp;node.Content, &amp;node.DomainID, &amp;node.Title,
                        &amp;node.Description, &amp;node.CreatedAt, &amp;node.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov8" title="1">nodes = append(nodes, node)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov8" title="1">countQuery := `
                SELECT COUNT(*)
                FROM nodes
                WHERE domain_id = ? AND (title LIKE ? OR content LIKE ? OR description LIKE ?)
        `

        var total int
        err = r.QueryRow(countQuery, domainID, searchPattern, searchPattern, searchPattern).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nodes, total, nil</span>
}

// Update 는 노드 정보를 업데이트합니다.
func (r *sqliteNodeRepository) Update(node *models.Node) error <span class="cov8" title="1">{
        query := `
                UPDATE nodes
                SET content = ?, title = ?, description = ?, updated_at = datetime('now')
                WHERE id = ?
                RETURNING updated_at
        `

        err := r.QueryRow(query, node.Content, node.Title, node.Description, node.ID).Scan(
                &amp;node.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete 는 노드를 삭제합니다.
func (r *sqliteNodeRepository) Delete(id int) error <span class="cov8" title="1">{
        query := `DELETE FROM nodes WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrNodeNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ExistsByDomainAndContent 는 도메인 ID와 콘텐츠로 노드 존재 여부를 확인합니다.
func (r *sqliteNodeRepository) ExistsByDomainAndContent(domainID int, content string) (bool, error) <span class="cov8" title="1">{
        query := `SELECT EXISTS(SELECT 1 FROM nodes WHERE domain_id = ? AND content = ?)`

        var exists bool
        err := r.QueryRow(query, domainID, content).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// CountNodesByDomain 는 도메인별 노드 수를 반환합니다.
func (r *sqliteNodeRepository) CountNodesByDomain(ctx context.Context, domainID int) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM nodes WHERE domain_id = ?`

        var count int
        err := r.QueryRow(query, domainID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// BatchCreate 는 여러 노드를 배치로 생성합니다.
func (r *sqliteNodeRepository) BatchCreate(nodes []models.Node) error <span class="cov8" title="1">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        INSERT INTO nodes (content, domain_id, title, description, created_at, updated_at)
                        VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer stmt.Close()

                for _, node := range nodes </span><span class="cov8" title="1">{
                        _, err := stmt.Exec(node.Content, node.DomainID, node.Title, node.Description)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

// BatchUpdate 는 여러 노드를 배치로 업데이트합니다.
func (r *sqliteNodeRepository) BatchUpdate(nodes []models.Node) error <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        UPDATE nodes
                        SET content = ?, title = ?, description = ?, updated_at = datetime('now')
                        WHERE id = ?
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, node := range nodes </span><span class="cov0" title="0">{
                        _, err := stmt.Exec(node.Content, node.Title, node.Description, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// BatchDelete 는 여러 노드를 배치로 삭제합니다.
func (r *sqliteNodeRepository) BatchDelete(ids []int) error <span class="cov8" title="1">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                stmt, err := r.PrepareStatementInTransaction(tx, `DELETE FROM nodes WHERE id = ?`)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer stmt.Close()

                for _, id := range ids </span><span class="cov8" title="1">{
                        _, err := stmt.Exec(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

// 트랜잭션 지원 메서드들

// CreateTx 는 트랜잭션 내에서 노드를 생성합니다.
func (r *sqliteNodeRepository) CreateTx(tx *sql.Tx, node *models.Node) error <span class="cov0" title="0">{
        query := `
                INSERT INTO nodes (content, domain_id, title, description, created_at, updated_at)
                VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))
                RETURNING id, created_at, updated_at
        `

        err := r.QueryRowInTransaction(tx, query, node.Content, node.DomainID, node.Title, node.Description).Scan(
                &amp;node.ID, &amp;node.CreatedAt, &amp;node.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 노드를 업데이트합니다.
func (r *sqliteNodeRepository) UpdateTx(tx *sql.Tx, node *models.Node) error <span class="cov0" title="0">{
        query := `
                UPDATE nodes
                SET content = ?, title = ?, description = ?, updated_at = datetime('now')
                WHERE id = ?
                RETURNING updated_at
        `

        err := r.QueryRowInTransaction(tx, query, node.Content, node.Title, node.Description, node.ID).Scan(
                &amp;node.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNodeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 노드를 삭제합니다.
func (r *sqliteNodeRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM nodes WHERE id = ?`

        result, err := r.ExecuteInTransaction(tx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package repositories

import (
        "database/sql"
        "url-db/internal/models"
)

// sqliteNodeAttributeRepository 는 SQLite 기반 노드 속성 리포지토리 구현체입니다.
type sqliteNodeAttributeRepository struct {
        *BaseRepository
}

// NewSQLiteNodeAttributeRepository 는 새로운 SQLite 노드 속성 리포지토리를 생성합니다.
func NewSQLiteNodeAttributeRepository(db *sql.DB) NodeAttributeRepository <span class="cov0" title="0">{
        return &amp;sqliteNodeAttributeRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 노드 속성을 생성합니다.
func (r *sqliteNodeAttributeRepository) Create(nodeAttribute *models.NodeAttribute) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_attributes (node_id, attribute_id, value, order_index, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRow(query, nodeAttribute.NodeID, nodeAttribute.AttributeID,
                nodeAttribute.Value, nodeAttribute.OrderIndex).Scan(
                &amp;nodeAttribute.ID, &amp;nodeAttribute.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID 는 ID로 노드 속성을 조회합니다.
func (r *sqliteNodeAttributeRepository) GetByID(id int) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, node_id, attribute_id, value, order_index, created_at
                FROM node_attributes
                WHERE id = ?
        `

        nodeAttribute := &amp;models.NodeAttribute{}
        err := r.QueryRow(query, id).Scan(
                &amp;nodeAttribute.ID, &amp;nodeAttribute.NodeID, &amp;nodeAttribute.AttributeID,
                &amp;nodeAttribute.Value, &amp;nodeAttribute.OrderIndex, &amp;nodeAttribute.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nodeAttribute, nil</span>
}

// GetByNodeAndAttribute 는 노드 ID와 속성 ID로 노드 속성을 조회합니다.
func (r *sqliteNodeAttributeRepository) GetByNodeAndAttribute(nodeID, attributeID int) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, node_id, attribute_id, value, order_index, created_at
                FROM node_attributes
                WHERE node_id = ? AND attribute_id = ?
        `

        nodeAttribute := &amp;models.NodeAttribute{}
        err := r.QueryRow(query, nodeID, attributeID).Scan(
                &amp;nodeAttribute.ID, &amp;nodeAttribute.NodeID, &amp;nodeAttribute.AttributeID,
                &amp;nodeAttribute.Value, &amp;nodeAttribute.OrderIndex, &amp;nodeAttribute.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nodeAttribute, nil</span>
}

// ListByNode 은 노드 ID로 노드 속성 목록을 조회합니다 (속성 정보 포함).
func (r *sqliteNodeAttributeRepository) ListByNode(nodeID int) ([]models.NodeAttributeWithInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT na.id, na.node_id, na.attribute_id, na.value, na.order_index, na.created_at,
                       a.name, a.type
                FROM node_attributes na
                JOIN attributes a ON na.attribute_id = a.id
                WHERE na.node_id = ?
                ORDER BY a.name, na.order_index
        `

        rows, err := r.Query(query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var attributes []models.NodeAttributeWithInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var attr models.NodeAttributeWithInfo
                err := rows.Scan(&amp;attr.ID, &amp;attr.NodeID, &amp;attr.AttributeID,
                        &amp;attr.Value, &amp;attr.OrderIndex, &amp;attr.CreatedAt,
                        &amp;attr.Name, &amp;attr.Type)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">attributes = append(attributes, attr)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return attributes, nil</span>
}

// ListByAttribute 는 속성 ID로 노드 속성 목록을 조회합니다.
func (r *sqliteNodeAttributeRepository) ListByAttribute(attributeID int) ([]models.NodeAttribute, error) <span class="cov0" title="0">{
        query := `
                SELECT id, node_id, attribute_id, value, order_index, created_at
                FROM node_attributes
                WHERE attribute_id = ?
                ORDER BY order_index
        `

        rows, err := r.Query(query, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var nodeAttributes []models.NodeAttribute
        for rows.Next() </span><span class="cov0" title="0">{
                var nodeAttribute models.NodeAttribute
                err := rows.Scan(&amp;nodeAttribute.ID, &amp;nodeAttribute.NodeID, &amp;nodeAttribute.AttributeID,
                        &amp;nodeAttribute.Value, &amp;nodeAttribute.OrderIndex, &amp;nodeAttribute.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">nodeAttributes = append(nodeAttributes, nodeAttribute)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nodeAttributes, nil</span>
}

// Update 는 노드 속성 정보를 업데이트합니다.
func (r *sqliteNodeAttributeRepository) Update(nodeAttribute *models.NodeAttribute) error <span class="cov0" title="0">{
        query := `
                UPDATE node_attributes
                SET value = ?, order_index = ?
                WHERE id = ?
        `

        result, err := r.Execute(query, nodeAttribute.Value, nodeAttribute.OrderIndex, nodeAttribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete 는 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) Delete(id int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteByNode 는 노드 ID로 모든 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) DeleteByNode(nodeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE node_id = ?`

        _, err := r.Execute(query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteByAttribute 는 속성 ID로 모든 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) DeleteByAttribute(attributeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE attribute_id = ?`

        _, err := r.Execute(query, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExistsByNodeAndAttribute 는 노드 ID와 속성 ID로 노드 속성 존재 여부를 확인합니다.
func (r *sqliteNodeAttributeRepository) ExistsByNodeAndAttribute(nodeID, attributeID int) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM node_attributes WHERE node_id = ? AND attribute_id = ?)`

        var exists bool
        err := r.QueryRow(query, nodeID, attributeID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// BatchCreate 는 여러 노드 속성을 배치로 생성합니다.
func (r *sqliteNodeAttributeRepository) BatchCreate(nodeAttributes []models.NodeAttribute) error <span class="cov0" title="0">{
        if len(nodeAttributes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        INSERT INTO node_attributes (node_id, attribute_id, value, order_index, created_at)
                        VALUES (?, ?, ?, ?, datetime('now'))
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, nodeAttribute := range nodeAttributes </span><span class="cov0" title="0">{
                        _, err := stmt.Exec(nodeAttribute.NodeID, nodeAttribute.AttributeID,
                                nodeAttribute.Value, nodeAttribute.OrderIndex)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// BatchUpdate 는 여러 노드 속성을 배치로 업데이트합니다.
func (r *sqliteNodeAttributeRepository) BatchUpdate(nodeAttributes []models.NodeAttribute) error <span class="cov0" title="0">{
        if len(nodeAttributes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        UPDATE node_attributes
                        SET value = ?, order_index = ?
                        WHERE id = ?
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, nodeAttribute := range nodeAttributes </span><span class="cov0" title="0">{
                        _, err := stmt.Exec(nodeAttribute.Value, nodeAttribute.OrderIndex, nodeAttribute.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// BatchDeleteByNode 는 노드 ID로 모든 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) BatchDeleteByNode(nodeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE node_id = ?`

        _, err := r.Execute(query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// BatchDeleteByAttribute 는 속성 ID로 모든 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) BatchDeleteByAttribute(attributeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE attribute_id = ?`

        _, err := r.Execute(query, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// 트랜잭션 지원 메서드들

// CreateTx 는 트랜잭션 내에서 노드 속성을 생성합니다.
func (r *sqliteNodeAttributeRepository) CreateTx(tx *sql.Tx, nodeAttribute *models.NodeAttribute) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_attributes (node_id, attribute_id, value, order_index, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRowInTransaction(tx, query, nodeAttribute.NodeID, nodeAttribute.AttributeID,
                nodeAttribute.Value, nodeAttribute.OrderIndex).Scan(
                &amp;nodeAttribute.ID, &amp;nodeAttribute.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 노드 속성을 업데이트합니다.
func (r *sqliteNodeAttributeRepository) UpdateTx(tx *sql.Tx, nodeAttribute *models.NodeAttribute) error <span class="cov0" title="0">{
        query := `
                UPDATE node_attributes
                SET value = ?, order_index = ?
                WHERE id = ?
        `

        result, err := r.ExecuteInTransaction(tx, query, nodeAttribute.Value, nodeAttribute.OrderIndex, nodeAttribute.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 노드 속성을 삭제합니다.
func (r *sqliteNodeAttributeRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_attributes WHERE id = ?`

        result, err := r.ExecuteInTransaction(tx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeAttributeNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "url-db/internal/models"
)

// sqliteNodeConnectionRepository 는 SQLite 기반 노드 연결 리포지토리 구현체입니다.
type sqliteNodeConnectionRepository struct {
        *BaseRepository
}

// NewSQLiteNodeConnectionRepository 는 새로운 SQLite 노드 연결 리포지토리를 생성합니다.
func NewSQLiteNodeConnectionRepository(db *sql.DB) NodeConnectionRepository <span class="cov0" title="0">{
        return &amp;sqliteNodeConnectionRepository{
                BaseRepository: NewBaseRepository(db),
        }
}</span>

// Create 는 새로운 노드 연결을 생성합니다.
func (r *sqliteNodeConnectionRepository) Create(ctx context.Context, connection *models.NodeConnection) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_connections (source_node_id, target_node_id, relationship_type, description, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := r.QueryRow(query, connection.SourceNodeID, connection.TargetNodeID, connection.RelationshipType, connection.Description).Scan(
                &amp;connection.ID, &amp;connection.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID 는 ID로 노드 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) GetByID(ctx context.Context, id int) (*models.NodeConnection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, source_node_id, target_node_id, relationship_type, description, created_at
                FROM node_connections
                WHERE id = ?
        `

        connection := &amp;models.NodeConnection{}
        err := r.QueryRow(query, id).Scan(
                &amp;connection.ID, &amp;connection.SourceNodeID, &amp;connection.TargetNodeID,
                &amp;connection.RelationshipType, &amp;connection.Description, &amp;connection.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNodeConnectionNotFound
                }</span>
                <span class="cov0" title="0">return nil, MapSQLiteError(err)</span>
        }

        <span class="cov0" title="0">return connection, nil</span>
}

// GetBySourceAndTarget 는 소스 노드와 타겟 노드 및 관계 유형으로 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) GetBySourceAndTarget(ctx context.Context, sourceNodeID, targetNodeID int, relationshipType string) (*models.NodeConnection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, source_node_id, target_node_id, relationship_type, description, created_at
                FROM node_connections
                WHERE source_node_id = ? AND target_node_id = ? AND relationship_type = ?
        `

        connection := &amp;models.NodeConnection{}
        err := r.QueryRow(query, sourceNodeID, targetNodeID, relationshipType).Scan(
                &amp;connection.ID, &amp;connection.SourceNodeID, &amp;connection.TargetNodeID,
                &amp;connection.RelationshipType, &amp;connection.Description, &amp;connection.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNodeConnectionNotFound
                }</span>
                <span class="cov0" title="0">return nil, MapSQLiteError(err)</span>
        }

        <span class="cov0" title="0">return connection, nil</span>
}

// ListBySourceNode 는 소스 노드별로 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) ListBySourceNode(ctx context.Context, sourceNodeID int, offset, limit int) ([]models.NodeConnectionWithInfo, int, error) <span class="cov0" title="0">{
        query := `
                SELECT nc.id, nc.source_node_id, nc.target_node_id, nc.relationship_type, nc.description, nc.created_at,
                           sn.content as source_node_url, tn.content as target_node_url,
                           sn.title as source_node_title, tn.title as target_node_title
                FROM node_connections nc
                JOIN nodes sn ON nc.source_node_id = sn.id
                JOIN nodes tn ON nc.target_node_id = tn.id
                WHERE nc.source_node_id = ?
                ORDER BY nc.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, sourceNodeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var connections []models.NodeConnectionWithInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var conn models.NodeConnectionWithInfo
                err := rows.Scan(
                        &amp;conn.ID, &amp;conn.SourceNodeID, &amp;conn.TargetNodeID, &amp;conn.RelationshipType,
                        &amp;conn.Description, &amp;conn.CreatedAt, &amp;conn.SourceNodeURL, &amp;conn.TargetNodeURL,
                        &amp;conn.SourceNodeTitle, &amp;conn.TargetNodeTitle,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">connections = append(connections, conn)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov0" title="0">countQuery := `SELECT COUNT(*) FROM node_connections WHERE source_node_id = ?`
        var totalCount int
        err = r.QueryRow(countQuery, sourceNodeID).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return connections, totalCount, nil</span>
}

// ListByTargetNode 는 타겟 노드별로 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) ListByTargetNode(ctx context.Context, targetNodeID int, offset, limit int) ([]models.NodeConnectionWithInfo, int, error) <span class="cov0" title="0">{
        query := `
                SELECT nc.id, nc.source_node_id, nc.target_node_id, nc.relationship_type, nc.description, nc.created_at,
                           sn.content as source_node_url, tn.content as target_node_url,
                           sn.title as source_node_title, tn.title as target_node_title
                FROM node_connections nc
                JOIN nodes sn ON nc.source_node_id = sn.id
                JOIN nodes tn ON nc.target_node_id = tn.id
                WHERE nc.target_node_id = ?
                ORDER BY nc.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, targetNodeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var connections []models.NodeConnectionWithInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var conn models.NodeConnectionWithInfo
                err := rows.Scan(
                        &amp;conn.ID, &amp;conn.SourceNodeID, &amp;conn.TargetNodeID, &amp;conn.RelationshipType,
                        &amp;conn.Description, &amp;conn.CreatedAt, &amp;conn.SourceNodeURL, &amp;conn.TargetNodeURL,
                        &amp;conn.SourceNodeTitle, &amp;conn.TargetNodeTitle,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">connections = append(connections, conn)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov0" title="0">countQuery := `SELECT COUNT(*) FROM node_connections WHERE target_node_id = ?`
        var totalCount int
        err = r.QueryRow(countQuery, targetNodeID).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return connections, totalCount, nil</span>
}

// ListByRelationshipType 는 관계 유형별로 연결을 조회합니다.
func (r *sqliteNodeConnectionRepository) ListByRelationshipType(ctx context.Context, relationshipType string, offset, limit int) ([]models.NodeConnectionWithInfo, int, error) <span class="cov0" title="0">{
        query := `
                SELECT nc.id, nc.source_node_id, nc.target_node_id, nc.relationship_type, nc.description, nc.created_at,
                           sn.content as source_node_url, tn.content as target_node_url,
                           sn.title as source_node_title, tn.title as target_node_title
                FROM node_connections nc
                JOIN nodes sn ON nc.source_node_id = sn.id
                JOIN nodes tn ON nc.target_node_id = tn.id
                WHERE nc.relationship_type = ?
                ORDER BY nc.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, relationshipType, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var connections []models.NodeConnectionWithInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var conn models.NodeConnectionWithInfo
                err := rows.Scan(
                        &amp;conn.ID, &amp;conn.SourceNodeID, &amp;conn.TargetNodeID, &amp;conn.RelationshipType,
                        &amp;conn.Description, &amp;conn.CreatedAt, &amp;conn.SourceNodeURL, &amp;conn.TargetNodeURL,
                        &amp;conn.SourceNodeTitle, &amp;conn.TargetNodeTitle,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, MapSQLiteError(err)
                }</span>
                <span class="cov0" title="0">connections = append(connections, conn)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        // 총 개수 조회
        <span class="cov0" title="0">countQuery := `SELECT COUNT(*) FROM node_connections WHERE relationship_type = ?`
        var totalCount int
        err = r.QueryRow(countQuery, relationshipType).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return connections, totalCount, nil</span>
}

// Update 는 노드 연결을 업데이트합니다.
func (r *sqliteNodeConnectionRepository) Update(ctx context.Context, connection *models.NodeConnection) error <span class="cov0" title="0">{
        query := `
                UPDATE node_connections
                SET relationship_type = ?, description = ?
                WHERE id = ?
        `

        result, err := r.Execute(query, connection.RelationshipType, connection.Description, connection.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeConnectionNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete 는 노드 연결을 삭제합니다.
func (r *sqliteNodeConnectionRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_connections WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeConnectionNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteBySourceNode 는 소스 노드로 연결을 삭제합니다.
func (r *sqliteNodeConnectionRepository) DeleteBySourceNode(ctx context.Context, sourceNodeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_connections WHERE source_node_id = ?`

        _, err := r.Execute(query, sourceNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteByTargetNode 는 타겟 노드로 연결을 삭제합니다.
func (r *sqliteNodeConnectionRepository) DeleteByTargetNode(ctx context.Context, targetNodeID int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_connections WHERE target_node_id = ?`

        _, err := r.Execute(query, targetNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExistsBySourceAndTarget 는 소스 노드와 타겟 노드 및 관계 유형으로 연결 존재 여부를 확인합니다.
func (r *sqliteNodeConnectionRepository) ExistsBySourceAndTarget(ctx context.Context, sourceNodeID, targetNodeID int, relationshipType string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM node_connections WHERE source_node_id = ? AND target_node_id = ? AND relationship_type = ?)`

        var exists bool
        err := r.QueryRow(query, sourceNodeID, targetNodeID, relationshipType).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// BatchCreate 는 여러 노드 연결을 배치로 생성합니다.
func (r *sqliteNodeConnectionRepository) BatchCreate(ctx context.Context, connections []models.NodeConnection) error <span class="cov0" title="0">{
        if len(connections) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `
                        INSERT INTO node_connections (source_node_id, target_node_id, relationship_type, description, created_at)
                        VALUES (?, ?, ?, ?, datetime('now'))
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, connection := range connections </span><span class="cov0" title="0">{
                        _, err = stmt.Exec(connection.SourceNodeID, connection.TargetNodeID, connection.RelationshipType, connection.Description)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// BatchDelete 는 여러 노드 연결을 배치로 삭제합니다.
func (r *sqliteNodeConnectionRepository) BatchDelete(ctx context.Context, ids []int) error <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.WithTransaction(func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := r.PrepareStatementInTransaction(tx, `DELETE FROM node_connections WHERE id = ?`)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, id := range ids </span><span class="cov0" title="0">{
                        _, err = stmt.Exec(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return MapSQLiteError(err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// CreateTx 는 트랜잭션 내에서 노드 연결을 생성합니다.
func (r *sqliteNodeConnectionRepository) CreateTx(tx *sql.Tx, connection *models.NodeConnection) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_connections (source_node_id, target_node_id, relationship_type, description, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
                RETURNING id, created_at
        `

        err := tx.QueryRow(query, connection.SourceNodeID, connection.TargetNodeID, connection.RelationshipType, connection.Description).Scan(
                &amp;connection.ID, &amp;connection.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTx 는 트랜잭션 내에서 노드 연결을 업데이트합니다.
func (r *sqliteNodeConnectionRepository) UpdateTx(tx *sql.Tx, connection *models.NodeConnection) error <span class="cov0" title="0">{
        query := `
                UPDATE node_connections
                SET relationship_type = ?, description = ?
                WHERE id = ?
        `

        result, err := tx.Exec(query, connection.RelationshipType, connection.Description, connection.ID)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeConnectionNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTx 는 트랜잭션 내에서 노드 연결을 삭제합니다.
func (r *sqliteNodeConnectionRepository) DeleteTx(tx *sql.Tx, id int) error <span class="cov0" title="0">{
        query := `DELETE FROM node_connections WHERE id = ?`

        result, err := tx.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return MapSQLiteError(err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNodeConnectionNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package repositories

import (
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"
        "url-db/internal/models"
)

// SubscriptionRepository handles database operations for subscriptions
type SubscriptionRepository struct {
        db *sqlx.DB
}

// NewSubscriptionRepository creates a new subscription repository
func NewSubscriptionRepository(db *sqlx.DB) *SubscriptionRepository <span class="cov0" title="0">{
        return &amp;SubscriptionRepository{db: db}
}</span>

// Create creates a new subscription
func (r *SubscriptionRepository) Create(subscription *models.NodeSubscription) error <span class="cov0" title="0">{
        query := `
                INSERT INTO node_subscriptions (
                        subscriber_service, subscriber_endpoint, subscribed_node_id,
                        event_types, filter_conditions, is_active
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(
                query,
                subscription.SubscriberService,
                subscription.SubscriberEndpoint,
                subscription.SubscribedNodeID,
                subscription.EventTypes,
                subscription.FilterConditions,
                subscription.IsActive,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create subscription: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov0" title="0">subscription.ID = id
        return nil</span>
}

// GetByID retrieves a subscription by ID
func (r *SubscriptionRepository) GetByID(id int64) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        var subscription models.NodeSubscription
        query := `
                SELECT id, subscriber_service, subscriber_endpoint, subscribed_node_id,
                           event_types, filter_conditions, is_active, created_at, updated_at
                FROM node_subscriptions
                WHERE id = ?
        `

        err := r.db.Get(&amp;subscription, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get subscription: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;subscription, nil</span>
}

// GetByNode retrieves all subscriptions for a specific node
func (r *SubscriptionRepository) GetByNode(nodeID int64) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        var subscriptions []*models.NodeSubscription
        query := `
                SELECT id, subscriber_service, subscriber_endpoint, subscribed_node_id,
                           event_types, filter_conditions, is_active, created_at, updated_at
                FROM node_subscriptions
                WHERE subscribed_node_id = ? AND is_active = true
        `

        err := r.db.Select(&amp;subscriptions, query, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subscriptions: %w", err)
        }</span>

        <span class="cov0" title="0">return subscriptions, nil</span>
}

// GetByService retrieves all subscriptions for a specific service
func (r *SubscriptionRepository) GetByService(service string) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        var subscriptions []*models.NodeSubscription
        query := `
                SELECT id, subscriber_service, subscriber_endpoint, subscribed_node_id,
                           event_types, filter_conditions, is_active, created_at, updated_at
                FROM node_subscriptions
                WHERE subscriber_service = ?
                ORDER BY created_at DESC
        `

        err := r.db.Select(&amp;subscriptions, query, service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subscriptions: %w", err)
        }</span>

        <span class="cov0" title="0">return subscriptions, nil</span>
}

// Update updates a subscription
func (r *SubscriptionRepository) Update(id int64, updates map[string]interface{}) error <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := "UPDATE node_subscriptions SET "
        args := []interface{}{}

        for field, value := range updates </span><span class="cov0" title="0">{
                query += field + " = ?, "
                args = append(args, value)
        }</span>

        <span class="cov0" title="0">query = query[:len(query)-2] + " WHERE id = ?"
        args = append(args, id)

        _, err := r.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete deletes a subscription
func (r *SubscriptionRepository) Delete(id int64) error <span class="cov0" title="0">{
        query := "DELETE FROM node_subscriptions WHERE id = ?"

        result, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete subscription: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAll retrieves all subscriptions with pagination
func (r *SubscriptionRepository) GetAll(offset, limit int) ([]*models.NodeSubscription, int, error) <span class="cov0" title="0">{
        var subscriptions []*models.NodeSubscription
        var total int

        countQuery := "SELECT COUNT(*) FROM node_subscriptions"
        err := r.db.Get(&amp;total, countQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count subscriptions: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, subscriber_service, subscriber_endpoint, subscribed_node_id,
                           event_types, filter_conditions, is_active, created_at, updated_at
                FROM node_subscriptions
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        err = r.db.Select(&amp;subscriptions, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get subscriptions: %w", err)
        }</span>

        <span class="cov0" title="0">return subscriptions, total, nil</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package repositories

import (
        "database/sql"
        "testing"
        "time"
        "url-db/internal/models"

        _ "github.com/mattn/go-sqlite3"
        "github.com/stretchr/testify/require"
)

// TestDB 는 테스트용 데이터베이스 설정을 위한 구조체입니다.
type TestDB struct {
        DB *sql.DB
}

// SetupTestDB 는 테스트용 인메모리 SQLite 데이터베이스를 설정합니다.
func SetupTestDB(t *testing.T) *TestDB <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", ":memory:")
        require.NoError(t, err)

        // 테스트용 스키마 생성
        createTestSchema(t, db)

        return &amp;TestDB{DB: db}
}</span>

// Close 는 테스트 데이터베이스를 닫습니다.
func (tdb *TestDB) Close() <span class="cov8" title="1">{
        tdb.DB.Close()
}</span>

// createTestSchema 는 테스트용 스키마를 생성합니다.
func createTestSchema(t *testing.T, db *sql.DB) <span class="cov8" title="1">{
        schema := `
                CREATE TABLE domains (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL UNIQUE,
                        description TEXT,
                        created_at DATETIME NOT NULL,
                        updated_at DATETIME NOT NULL
                );

                CREATE TABLE nodes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        content TEXT NOT NULL,
                        domain_id INTEGER NOT NULL,
                        title TEXT,
                        description TEXT,
                        created_at DATETIME NOT NULL,
                        updated_at DATETIME NOT NULL,
                        FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE,
                        UNIQUE(content, domain_id)
                );

                CREATE TABLE attributes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        domain_id INTEGER NOT NULL,
                        name TEXT NOT NULL,
                        type TEXT NOT NULL CHECK (type IN ('tag', 'ordered_tag', 'number', 'string', 'markdown', 'image')),
                        description TEXT,
                        created_at DATETIME NOT NULL,
                        FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE,
                        UNIQUE(domain_id, name)
                );

                CREATE TABLE node_attributes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        node_id INTEGER NOT NULL,
                        attribute_id INTEGER NOT NULL,
                        value TEXT NOT NULL,
                        order_index INTEGER DEFAULT 0,
                        created_at DATETIME NOT NULL,
                        FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE,
                        FOREIGN KEY (attribute_id) REFERENCES attributes(id) ON DELETE CASCADE,
                        UNIQUE(node_id, attribute_id, order_index)
                );

                -- 인덱스 생성
                CREATE INDEX idx_nodes_domain_id ON nodes(domain_id);
                CREATE INDEX idx_nodes_content ON nodes(content);
                CREATE INDEX idx_attributes_domain_id ON attributes(domain_id);
                CREATE INDEX idx_node_attributes_node_id ON node_attributes(node_id);
                CREATE INDEX idx_node_attributes_attribute_id ON node_attributes(attribute_id);
        `

        _, err := db.Exec(schema)
        require.NoError(t, err)
}</span>

// TestDomainBuilder 는 테스트용 도메인 빌더입니다.
type TestDomainBuilder struct {
        domain *models.Domain
}

// NewTestDomainBuilder 는 새로운 테스트 도메인 빌더를 생성합니다.
func NewTestDomainBuilder() *TestDomainBuilder <span class="cov8" title="1">{
        return &amp;TestDomainBuilder{
                domain: &amp;models.Domain{
                        Name:        "test-domain",
                        Description: "Test domain",
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
        }
}</span>

// WithName 은 도메인 이름을 설정합니다.
func (b *TestDomainBuilder) WithName(name string) *TestDomainBuilder <span class="cov8" title="1">{
        b.domain.Name = name
        return b
}</span>

// WithDescription 은 도메인 설명을 설정합니다.
func (b *TestDomainBuilder) WithDescription(description string) *TestDomainBuilder <span class="cov0" title="0">{
        b.domain.Description = description
        return b
}</span>

// WithID 는 도메인 ID를 설정합니다.
func (b *TestDomainBuilder) WithID(id int) *TestDomainBuilder <span class="cov0" title="0">{
        b.domain.ID = id
        return b
}</span>

// Build 는 도메인을 빌드합니다.
func (b *TestDomainBuilder) Build() *models.Domain <span class="cov8" title="1">{
        return b.domain
}</span>

// TestNodeBuilder 는 테스트용 노드 빌더입니다.
type TestNodeBuilder struct {
        node *models.Node
}

// NewTestNodeBuilder 는 새로운 테스트 노드 빌더를 생성합니다.
func NewTestNodeBuilder() *TestNodeBuilder <span class="cov8" title="1">{
        return &amp;TestNodeBuilder{
                node: &amp;models.Node{
                        Content:     "https://example.com",
                        DomainID:    1,
                        Title:       "Test Node",
                        Description: "Test node description",
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
        }
}</span>

// WithContent 는 노드 콘텐츠를 설정합니다.
func (b *TestNodeBuilder) WithContent(content string) *TestNodeBuilder <span class="cov8" title="1">{
        b.node.Content = content
        return b
}</span>

// WithDomainID 는 도메인 ID를 설정합니다.
func (b *TestNodeBuilder) WithDomainID(domainID int) *TestNodeBuilder <span class="cov8" title="1">{
        b.node.DomainID = domainID
        return b
}</span>

// WithTitle 은 노드 제목을 설정합니다.
func (b *TestNodeBuilder) WithTitle(title string) *TestNodeBuilder <span class="cov8" title="1">{
        b.node.Title = title
        return b
}</span>

// WithDescription 은 노드 설명을 설정합니다.
func (b *TestNodeBuilder) WithDescription(description string) *TestNodeBuilder <span class="cov8" title="1">{
        b.node.Description = description
        return b
}</span>

// WithID 는 노드 ID를 설정합니다.
func (b *TestNodeBuilder) WithID(id int) *TestNodeBuilder <span class="cov0" title="0">{
        b.node.ID = id
        return b
}</span>

// Build 는 노드를 빌드합니다.
func (b *TestNodeBuilder) Build() *models.Node <span class="cov8" title="1">{
        return b.node
}</span>

// TestAttributeBuilder 는 테스트용 속성 빌더입니다.
type TestAttributeBuilder struct {
        attribute *models.Attribute
}

// NewTestAttributeBuilder 는 새로운 테스트 속성 빌더를 생성합니다.
func NewTestAttributeBuilder() *TestAttributeBuilder <span class="cov0" title="0">{
        return &amp;TestAttributeBuilder{
                attribute: &amp;models.Attribute{
                        DomainID:    1,
                        Name:        "test-attribute",
                        Type:        "tag",
                        Description: "Test attribute",
                        CreatedAt:   time.Now(),
                },
        }
}</span>

// WithDomainID 는 도메인 ID를 설정합니다.
func (b *TestAttributeBuilder) WithDomainID(domainID int) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.DomainID = domainID
        return b
}</span>

// WithName 은 속성 이름을 설정합니다.
func (b *TestAttributeBuilder) WithName(name string) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.Name = name
        return b
}</span>

// WithType 은 속성 타입을 설정합니다.
func (b *TestAttributeBuilder) WithType(attrType string) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.Type = models.AttributeType(attrType)
        return b
}</span>

// WithDescription 은 속성 설명을 설정합니다.
func (b *TestAttributeBuilder) WithDescription(description string) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.Description = description
        return b
}</span>

// WithID 는 속성 ID를 설정합니다.
func (b *TestAttributeBuilder) WithID(id int) *TestAttributeBuilder <span class="cov0" title="0">{
        b.attribute.ID = id
        return b
}</span>

// Build 는 속성을 빌드합니다.
func (b *TestAttributeBuilder) Build() *models.Attribute <span class="cov0" title="0">{
        return b.attribute
}</span>

// TestNodeAttributeBuilder 는 테스트용 노드 속성 빌더입니다.
type TestNodeAttributeBuilder struct {
        nodeAttribute *models.NodeAttribute
}

// NewTestNodeAttributeBuilder 는 새로운 테스트 노드 속성 빌더를 생성합니다.
func NewTestNodeAttributeBuilder() *TestNodeAttributeBuilder <span class="cov0" title="0">{
        return &amp;TestNodeAttributeBuilder{
                nodeAttribute: &amp;models.NodeAttribute{
                        NodeID:      1,
                        AttributeID: 1,
                        Value:       "test-value",
                        OrderIndex:  nil,
                        CreatedAt:   time.Now(),
                },
        }
}</span>

// WithNodeID 는 노드 ID를 설정합니다.
func (b *TestNodeAttributeBuilder) WithNodeID(nodeID int) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.NodeID = nodeID
        return b
}</span>

// WithAttributeID 는 속성 ID를 설정합니다.
func (b *TestNodeAttributeBuilder) WithAttributeID(attributeID int) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.AttributeID = attributeID
        return b
}</span>

// WithValue 는 속성 값을 설정합니다.
func (b *TestNodeAttributeBuilder) WithValue(value string) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.Value = value
        return b
}</span>

// WithOrderIndex 는 순서 인덱스를 설정합니다.
func (b *TestNodeAttributeBuilder) WithOrderIndex(orderIndex int) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.OrderIndex = &amp;orderIndex
        return b
}</span>

// WithID 는 노드 속성 ID를 설정합니다.
func (b *TestNodeAttributeBuilder) WithID(id int) *TestNodeAttributeBuilder <span class="cov0" title="0">{
        b.nodeAttribute.ID = id
        return b
}</span>

// Build 는 노드 속성을 빌드합니다.
func (b *TestNodeAttributeBuilder) Build() *models.NodeAttribute <span class="cov0" title="0">{
        return b.nodeAttribute
}</span>

// CreateTestDomain 은 테스트용 도메인을 생성합니다.
func CreateTestDomain(t *testing.T, repo DomainRepository) *models.Domain <span class="cov8" title="1">{
        domain := NewTestDomainBuilder().Build()
        err := repo.Create(domain)
        require.NoError(t, err)
        return domain
}</span>

// CreateTestNode 는 테스트용 노드를 생성합니다.
func CreateTestNode(t *testing.T, repo NodeRepository, domainID int) *models.Node <span class="cov8" title="1">{
        node := NewTestNodeBuilder().WithDomainID(domainID).Build()
        err := repo.Create(node)
        require.NoError(t, err)
        return node
}</span>

// CreateTestAttribute 는 테스트용 속성을 생성합니다.
func CreateTestAttribute(t *testing.T, repo AttributeRepository, domainID int) *models.Attribute <span class="cov0" title="0">{
        attribute := NewTestAttributeBuilder().WithDomainID(domainID).Build()
        err := repo.Create(attribute)
        require.NoError(t, err)
        return attribute
}</span>

// CreateTestNodeAttribute 는 테스트용 노드 속성을 생성합니다.
func CreateTestNodeAttribute(t *testing.T, repo NodeAttributeRepository, nodeID, attributeID int) *models.NodeAttribute <span class="cov0" title="0">{
        nodeAttribute := NewTestNodeAttributeBuilder().WithNodeID(nodeID).WithAttributeID(attributeID).Build()
        err := repo.Create(nodeAttribute)
        require.NoError(t, err)
        return nodeAttribute
}</span>

// AssertDomainEqual 은 두 도메인이 같은지 확인합니다.
func AssertDomainEqual(t *testing.T, expected, actual *models.Domain) <span class="cov8" title="1">{
        require.Equal(t, expected.Name, actual.Name)
        require.Equal(t, expected.Description, actual.Description)
        if expected.ID != 0 </span><span class="cov8" title="1">{
                require.Equal(t, expected.ID, actual.ID)
        }</span>
}

// AssertNodeEqual 은 두 노드가 같은지 확인합니다.
func AssertNodeEqual(t *testing.T, expected, actual *models.Node) <span class="cov8" title="1">{
        require.Equal(t, expected.Content, actual.Content)
        require.Equal(t, expected.DomainID, actual.DomainID)
        require.Equal(t, expected.Title, actual.Title)
        require.Equal(t, expected.Description, actual.Description)
        if expected.ID != 0 </span><span class="cov8" title="1">{
                require.Equal(t, expected.ID, actual.ID)
        }</span>
}

// AssertAttributeEqual 은 두 속성이 같은지 확인합니다.
func AssertAttributeEqual(t *testing.T, expected, actual *models.Attribute) <span class="cov0" title="0">{
        require.Equal(t, expected.DomainID, actual.DomainID)
        require.Equal(t, expected.Name, actual.Name)
        require.Equal(t, expected.Type, actual.Type)
        require.Equal(t, expected.Description, actual.Description)
        if expected.ID != 0 </span><span class="cov0" title="0">{
                require.Equal(t, expected.ID, actual.ID)
        }</span>
}

// AssertNodeAttributeEqual 은 두 노드 속성이 같은지 확인합니다.
func AssertNodeAttributeEqual(t *testing.T, expected, actual *models.NodeAttribute) <span class="cov0" title="0">{
        require.Equal(t, expected.NodeID, actual.NodeID)
        require.Equal(t, expected.AttributeID, actual.AttributeID)
        require.Equal(t, expected.Value, actual.Value)
        require.Equal(t, expected.OrderIndex, actual.OrderIndex)
        if expected.ID != 0 </span><span class="cov0" title="0">{
                require.Equal(t, expected.ID, actual.ID)
        }</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">package services

import (
        "fmt"
        "os"
        "time"
        "url-db/internal/models"
        "url-db/internal/repositories"
)

// DependencyGraphService provides graph operations for dependencies
type DependencyGraphService struct {
        dependencyRepo *repositories.DependencyRepository
        nodeRepo       repositories.NodeRepository
}

// NewDependencyGraphService creates a new dependency graph service
func NewDependencyGraphService(depRepo *repositories.DependencyRepository, nodeRepo repositories.NodeRepository) *DependencyGraphService <span class="cov0" title="0">{
        return &amp;DependencyGraphService{
                dependencyRepo: depRepo,
                nodeRepo:       nodeRepo,
        }
}</span>

// graphNode represents a node in the dependency graph for traversal
type graphNode struct {
        ID      int64
        Visited bool
        InStack bool
        LowLink int
        Index   int
        Parent  *graphNode
}

// DetectCycles uses Tarjan's algorithm to find all cycles in the dependency graph
func (s *DependencyGraphService) DetectCycles(domainID int64) ([]models.CircularDependency, error) <span class="cov0" title="0">{
        // Build adjacency list
        graph, err := s.buildGraph(domainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build graph: %w", err)
        }</span>

        // Initialize Tarjan's algorithm
        <span class="cov0" title="0">index := 0
        stack := make([]int64, 0)
        nodes := make(map[int64]*graphNode)
        cycles := make([]models.CircularDependency, 0)

        // Initialize all nodes
        for nodeID := range graph </span><span class="cov0" title="0">{
                nodes[nodeID] = &amp;graphNode{
                        ID:      nodeID,
                        Index:   -1,
                        LowLink: -1,
                }
        }</span>

        // Run Tarjan's algorithm on all unvisited nodes
        <span class="cov0" title="0">for nodeID := range graph </span><span class="cov0" title="0">{
                if nodes[nodeID].Index == -1 </span><span class="cov0" title="0">{
                        s.tarjanDFS(nodeID, graph, nodes, &amp;stack, &amp;index, &amp;cycles)
                }</span>
        }

        // Get node details for cycles
        <span class="cov0" title="0">for i := range cycles </span><span class="cov0" title="0">{
                details, err := s.getNodeDetails(cycles[i].Path)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">cycles[i].NodeDetails = details
                cycles[i].Strength = s.calculateCycleStrength(cycles[i].Path, graph)</span>
        }

        <span class="cov0" title="0">return cycles, nil</span>
}

// tarjanDFS performs depth-first search for Tarjan's algorithm
func (s *DependencyGraphService) tarjanDFS(
        nodeID int64,
        graph map[int64][]dependencyEdge,
        nodes map[int64]*graphNode,
        stack *[]int64,
        index *int,
        cycles *[]models.CircularDependency,
) <span class="cov0" title="0">{
        node := nodes[nodeID]
        node.Index = *index
        node.LowLink = *index
        *index++
        *stack = append(*stack, nodeID)
        node.InStack = true

        // Visit all neighbors
        for _, edge := range graph[nodeID] </span><span class="cov0" title="0">{
                neighbor := nodes[edge.To]

                if neighbor.Index == -1 </span><span class="cov0" title="0">{
                        // Neighbor not visited, recurse
                        neighbor.Parent = node
                        s.tarjanDFS(edge.To, graph, nodes, stack, index, cycles)

                        // Update low link
                        if neighbor.LowLink &lt; node.LowLink </span><span class="cov0" title="0">{
                                node.LowLink = neighbor.LowLink
                        }</span>
                } else<span class="cov0" title="0"> if neighbor.InStack </span><span class="cov0" title="0">{
                        // Neighbor is in stack, we found a cycle
                        if neighbor.Index &lt; node.LowLink </span><span class="cov0" title="0">{
                                node.LowLink = neighbor.Index
                        }</span>

                        // Extract cycle
                        <span class="cov0" title="0">cycle := s.extractCycle(nodeID, edge.To, nodes)
                        if len(cycle) &gt; 0 </span><span class="cov0" title="0">{
                                *cycles = append(*cycles, models.CircularDependency{
                                        Path: cycle,
                                })
                        }</span>
                }
        }

        // Check if node is a root of SCC
        <span class="cov0" title="0">if node.LowLink == node.Index </span><span class="cov0" title="0">{
                // Pop from stack until we reach current node
                for </span><span class="cov0" title="0">{
                        if len(*stack) == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">topID := (*stack)[len(*stack)-1]
                        *stack = (*stack)[:len(*stack)-1]
                        nodes[topID].InStack = false

                        if topID == nodeID </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
}

// extractCycle extracts a cycle path from the graph
func (s *DependencyGraphService) extractCycle(from, to int64, nodes map[int64]*graphNode) []int64 <span class="cov0" title="0">{
        path := []int64{from}
        current := nodes[from].Parent

        for current != nil &amp;&amp; current.ID != to </span><span class="cov0" title="0">{
                path = append([]int64{current.ID}, path...)
                current = current.Parent

                // Prevent infinite loop
                if len(path) &gt; 100 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if current != nil &amp;&amp; current.ID == to </span><span class="cov0" title="0">{
                path = append([]int64{to}, path...)
        }</span>

        <span class="cov0" title="0">return path</span>
}

// ValidateNewDependency checks if adding a dependency would create a cycle
func (s *DependencyGraphService) ValidateNewDependency(
        dependentID, dependencyID int64,
) (*models.DependencyValidationResult, error) <span class="cov0" title="0">{
        result := &amp;models.DependencyValidationResult{
                IsValid:  true,
                Errors:   make([]string, 0),
                Warnings: make([]string, 0),
                Cycles:   make([]models.CircularDependency, 0),
        }

        // Check for self-dependency
        if dependentID == dependencyID </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, "Self-dependencies are not allowed")
                return result, nil
        }</span>

        // Check if dependency already exists
        <span class="cov0" title="0">existing, err := s.dependencyRepo.GetDependency(dependentID, dependencyID)
        if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, "Dependency already exists")
        }</span>

        // Check if adding this would create a cycle
        <span class="cov0" title="0">wouldCreateCycle, cyclePath, err := s.wouldCreateCycle(dependentID, dependencyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check for cycles: %w", err)
        }</span>

        <span class="cov0" title="0">if wouldCreateCycle </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, "Adding this dependency would create a circular dependency")

                details, _ := s.getNodeDetails(cyclePath)
                result.Cycles = append(result.Cycles, models.CircularDependency{
                        Path:        cyclePath,
                        NodeDetails: details,
                })
        }</span>

        // Check domain rules
        <span class="cov0" title="0">rules, err := s.dependencyRepo.GetActiveRules(dependentID)
        if err == nil </span><span class="cov0" title="0">{
                for _, rule := range rules </span><span class="cov0" title="0">{
                        if !s.validateRule(*rule, dependentID, dependencyID) </span><span class="cov0" title="0">{
                                result.IsValid = false
                                result.Errors = append(result.Errors, fmt.Sprintf("Violates rule: %s", rule.RuleName))
                        }</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// wouldCreateCycle checks if adding a dependency would create a cycle
func (s *DependencyGraphService) wouldCreateCycle(dependentID, dependencyID int64) (bool, []int64, error) <span class="cov0" title="0">{
        // Use DFS to check if there's already a path from dependency to dependent
        visited := make(map[int64]bool)
        path := []int64{dependencyID}

        return s.dfsCheckPath(dependencyID, dependentID, visited, &amp;path)
}</span>

// dfsCheckPath performs depth-first search to find a path
func (s *DependencyGraphService) dfsCheckPath(
        current, target int64,
        visited map[int64]bool,
        path *[]int64,
) (bool, []int64, error) <span class="cov0" title="0">{
        if current == target </span><span class="cov0" title="0">{
                return true, *path, nil
        }</span>

        <span class="cov0" title="0">if visited[current] </span><span class="cov0" title="0">{
                return false, nil, nil
        }</span>

        <span class="cov0" title="0">visited[current] = true

        // Get all dependencies of current node
        deps, err := s.dependencyRepo.GetNodeDependencies(current)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>

        <span class="cov0" title="0">for _, dep := range deps </span><span class="cov0" title="0">{
                *path = append(*path, dep.DependencyNodeID)

                found, cyclePath, err := s.dfsCheckPath(dep.DependencyNodeID, target, visited, path)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>

                <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                        return true, cyclePath, nil
                }</span>

                // Backtrack
                <span class="cov0" title="0">*path = (*path)[:len(*path)-1]</span>
        }

        <span class="cov0" title="0">return false, nil, nil</span>
}

// GetDependencyGraph builds a complete dependency graph for a node
func (s *DependencyGraphService) GetDependencyGraph(
        nodeID int64,
        maxDepth int,
) (*models.DependencyGraph, error) <span class="cov0" title="0">{
        graph := &amp;models.DependencyGraph{
                NodeID:       nodeID,
                Dependencies: make([]models.DependencyNode, 0),
                Dependents:   make([]models.DependencyNode, 0),
                Metadata:     make(map[string]interface{}),
        }

        // Check cache first
        cached, err := s.dependencyRepo.GetCachedGraph(nodeID)
        if err == nil &amp;&amp; cached != nil &amp;&amp; !s.isCacheExpired(cached) </span><span class="cov0" title="0">{
                // Parse and return cached graph
                return s.parseCachedGraph(cached)
        }</span>

        // Build dependencies tree
        <span class="cov0" title="0">depVisited := make(map[int64]bool)
        dependencies, depthDeps, err := s.buildDependencyTree(nodeID, 0, maxDepth, depVisited)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build dependency tree: %w", err)
        }</span>
        <span class="cov0" title="0">graph.Dependencies = dependencies

        // Build dependents tree
        depVisited = make(map[int64]bool)
        dependents, depthDents, err := s.buildDependentTree(nodeID, 0, maxDepth, depVisited)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build dependent tree: %w", err)
        }</span>
        <span class="cov0" title="0">graph.Dependents = dependents

        // Calculate metadata
        graph.Depth = max(depthDeps, depthDents)
        graph.HasCircular = s.hasCircularDependency(nodeID)
        graph.Metadata["total_dependencies"] = len(dependencies)
        graph.Metadata["total_dependents"] = len(dependents)

        // Cache the result
        if err := s.cacheGraph(nodeID, graph); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail
                fmt.Fprintf(os.Stderr, "Failed to cache graph: %v\n", err)
        }</span>

        <span class="cov0" title="0">return graph, nil</span>
}

// buildDependencyTree recursively builds the dependency tree
func (s *DependencyGraphService) buildDependencyTree(
        nodeID int64,
        currentDepth, maxDepth int,
        visited map[int64]bool,
) ([]models.DependencyNode, int, error) <span class="cov0" title="0">{
        if currentDepth &gt;= maxDepth || visited[nodeID] </span><span class="cov0" title="0">{
                return nil, currentDepth, nil
        }</span>

        <span class="cov0" title="0">visited[nodeID] = true

        deps, err := s.dependencyRepo.GetNodeDependencies(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, currentDepth, err
        }</span>

        <span class="cov0" title="0">nodes := make([]models.DependencyNode, 0, len(deps))
        maxFoundDepth := currentDepth

        for _, dep := range deps </span><span class="cov0" title="0">{
                node, err := s.nodeRepo.GetByID(int(dep.DependencyNodeID))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">depNode := models.DependencyNode{
                        NodeID:         dep.DependencyNodeID,
                        CompositeID:    s.buildCompositeID(node),
                        Title:          node.Title,
                        DependencyType: dep.DependencyType,
                        Category:       s.getCategoryForType(dep.DependencyType),
                        Strength:       s.getStrength(dep),
                        Priority:       s.getPriority(dep),
                        IsRequired:     s.getIsRequired(dep),
                }

                // Parse metadata
                if dep.Metadata != nil </span><span class="cov0" title="0">{
                        metadata, _ := dep.ParseMetadata()
                        depNode.Metadata = metadata
                }</span>

                // Recursively get children
                <span class="cov0" title="0">children, childDepth, _ := s.buildDependencyTree(
                        dep.DependencyNodeID,
                        currentDepth+1,
                        maxDepth,
                        visited,
                )
                depNode.Children = children

                if childDepth &gt; maxFoundDepth </span><span class="cov0" title="0">{
                        maxFoundDepth = childDepth
                }</span>

                <span class="cov0" title="0">nodes = append(nodes, depNode)</span>
        }

        <span class="cov0" title="0">return nodes, maxFoundDepth, nil</span>
}

// buildDependentTree recursively builds the dependent tree
func (s *DependencyGraphService) buildDependentTree(
        nodeID int64,
        currentDepth, maxDepth int,
        visited map[int64]bool,
) ([]models.DependencyNode, int, error) <span class="cov0" title="0">{
        if currentDepth &gt;= maxDepth || visited[nodeID] </span><span class="cov0" title="0">{
                return nil, currentDepth, nil
        }</span>

        <span class="cov0" title="0">visited[nodeID] = true

        deps, err := s.dependencyRepo.GetNodeDependents(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, currentDepth, err
        }</span>

        <span class="cov0" title="0">nodes := make([]models.DependencyNode, 0, len(deps))
        maxFoundDepth := currentDepth

        for _, dep := range deps </span><span class="cov0" title="0">{
                node, err := s.nodeRepo.GetByID(int(dep.DependentNodeID))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">depNode := models.DependencyNode{
                        NodeID:         dep.DependentNodeID,
                        CompositeID:    s.buildCompositeID(node),
                        Title:          node.Title,
                        DependencyType: dep.DependencyType,
                        Category:       s.getCategoryForType(dep.DependencyType),
                        Strength:       s.getStrength(dep),
                        Priority:       s.getPriority(dep),
                        IsRequired:     s.getIsRequired(dep),
                }

                // Parse metadata
                if dep.Metadata != nil </span><span class="cov0" title="0">{
                        metadata, _ := dep.ParseMetadata()
                        depNode.Metadata = metadata
                }</span>

                // Recursively get children
                <span class="cov0" title="0">children, childDepth, _ := s.buildDependentTree(
                        dep.DependentNodeID,
                        currentDepth+1,
                        maxDepth,
                        visited,
                )
                depNode.Children = children

                if childDepth &gt; maxFoundDepth </span><span class="cov0" title="0">{
                        maxFoundDepth = childDepth
                }</span>

                <span class="cov0" title="0">nodes = append(nodes, depNode)</span>
        }

        <span class="cov0" title="0">return nodes, maxFoundDepth, nil</span>
}

// Helper types and methods

type dependencyEdge struct {
        To       int64
        Type     string
        Strength int
}

func (s *DependencyGraphService) buildGraph(domainID int64) (map[int64][]dependencyEdge, error) <span class="cov0" title="0">{
        // Implementation would fetch all dependencies for the domain
        // and build an adjacency list representation
        return nil, fmt.Errorf("not implemented")
}</span>

func (s *DependencyGraphService) getNodeDetails(nodeIDs []int64) ([]string, error) <span class="cov0" title="0">{
        details := make([]string, 0, len(nodeIDs))
        for _, id := range nodeIDs </span><span class="cov0" title="0">{
                node, err := s.nodeRepo.GetByID(int(id))
                if err != nil </span><span class="cov0" title="0">{
                        details = append(details, fmt.Sprintf("Node %d (unknown)", id))
                        continue</span>
                }
                <span class="cov0" title="0">details = append(details, fmt.Sprintf("%s (%s)", node.Title, s.buildCompositeID(node)))</span>
        }
        <span class="cov0" title="0">return details, nil</span>
}

func (s *DependencyGraphService) calculateCycleStrength(path []int64, graph map[int64][]dependencyEdge) int <span class="cov0" title="0">{
        minStrength := 100
        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov0" title="0">{
                from := path[i]
                to := path[i+1]

                for _, edge := range graph[from] </span><span class="cov0" title="0">{
                        if edge.To == to &amp;&amp; edge.Strength &lt; minStrength </span><span class="cov0" title="0">{
                                minStrength = edge.Strength
                        }</span>
                }
        }
        <span class="cov0" title="0">return minStrength</span>
}

func (s *DependencyGraphService) validateRule(rule models.DependencyRule, dependentID, dependencyID int64) bool <span class="cov0" title="0">{
        // Implementation would validate based on rule type and config
        return true
}</span>

func (s *DependencyGraphService) isCacheExpired(cache *models.DependencyGraphCache) bool <span class="cov0" title="0">{
        if cache.ExpiresAt == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return cache.ExpiresAt.Before(time.Now())</span>
}

func (s *DependencyGraphService) parseCachedGraph(cache *models.DependencyGraphCache) (*models.DependencyGraph, error) <span class="cov0" title="0">{
        // Implementation would parse JSON graph data
        return nil, fmt.Errorf("not implemented")
}</span>

func (s *DependencyGraphService) cacheGraph(nodeID int64, graph *models.DependencyGraph) error <span class="cov0" title="0">{
        // Implementation would serialize and cache the graph
        return nil
}</span>

func (s *DependencyGraphService) hasCircularDependency(nodeID int64) bool <span class="cov0" title="0">{
        // Quick check for circular dependencies involving this node
        return false
}</span>

func (s *DependencyGraphService) buildCompositeID(node *models.Node) string <span class="cov0" title="0">{
        // Implementation would build composite ID
        return fmt.Sprintf("url-db:domain:%d", node.ID)
}</span>

func (s *DependencyGraphService) getCategoryForType(depType string) string <span class="cov0" title="0">{
        switch depType </span>{
        case models.DependencyTypeHard, models.DependencyTypeSoft, models.DependencyTypeReference:<span class="cov0" title="0">
                return models.CategoryStructural</span>
        case models.DependencyTypeRuntime, models.DependencyTypeCompile, models.DependencyTypeOptional:<span class="cov0" title="0">
                return models.CategoryBehavioral</span>
        case models.DependencyTypeSync, models.DependencyTypeAsync:<span class="cov0" title="0">
                return models.CategoryData</span>
        default:<span class="cov0" title="0">
                return models.CategoryStructural</span>
        }
}

func (s *DependencyGraphService) getStrength(dep *models.NodeDependency) int <span class="cov0" title="0">{
        // For V1, use default strengths based on type
        switch dep.DependencyType </span>{
        case models.DependencyTypeHard:<span class="cov0" title="0">
                return 90</span>
        case models.DependencyTypeSoft:<span class="cov0" title="0">
                return 50</span>
        case models.DependencyTypeReference:<span class="cov0" title="0">
                return 30</span>
        default:<span class="cov0" title="0">
                return 50</span>
        }
}

func (s *DependencyGraphService) getPriority(dep *models.NodeDependency) int <span class="cov0" title="0">{
        // For V1, use default priorities
        return 50
}</span>

func (s *DependencyGraphService) getIsRequired(dep *models.NodeDependency) bool <span class="cov0" title="0">{
        // For V1, check type
        return dep.DependencyType != models.DependencyTypeOptional &amp;&amp;
                dep.DependencyType != models.DependencyTypeReference
}</span>

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package services

import (
        "context"
        "fmt"
        "time"
        "url-db/internal/models"
        "url-db/internal/repositories"
)

// DependencyImpactAnalyzer provides impact analysis for dependency changes
type DependencyImpactAnalyzer struct {
        dependencyRepo *repositories.DependencyRepository
        nodeRepo       repositories.NodeRepository
        graphService   *DependencyGraphService
}

// NewDependencyImpactAnalyzer creates a new impact analyzer
func NewDependencyImpactAnalyzer(
        depRepo *repositories.DependencyRepository,
        nodeRepo repositories.NodeRepository,
        graphService *DependencyGraphService,
) *DependencyImpactAnalyzer <span class="cov0" title="0">{
        return &amp;DependencyImpactAnalyzer{
                dependencyRepo: depRepo,
                nodeRepo:       nodeRepo,
                graphService:   graphService,
        }
}</span>

// AnalyzeImpact performs comprehensive impact analysis for a dependency change
func (a *DependencyImpactAnalyzer) AnalyzeImpact(
        ctx context.Context,
        sourceNodeID int64,
        impactType string,
) (*models.ImpactAnalysisResult, error) <span class="cov0" title="0">{
        // Get source node
        sourceNode, err := a.nodeRepo.GetByID(int(sourceNodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get source node: %w", err)
        }</span>

        <span class="cov0" title="0">result := &amp;models.ImpactAnalysisResult{
                SourceNodeID:    sourceNodeID,
                SourceComposite: a.buildCompositeID(sourceNode),
                ImpactType:      impactType,
                AffectedNodes:   make([]models.AffectedNode, 0),
                Warnings:        make([]string, 0),
                Recommendations: make([]string, 0),
        }

        // Analyze based on impact type
        switch impactType </span>{
        case "delete":<span class="cov0" title="0">
                return a.analyzeDeleteImpact(ctx, sourceNodeID, result)</span>
        case "update":<span class="cov0" title="0">
                return a.analyzeUpdateImpact(ctx, sourceNodeID, result)</span>
        case "version_change":<span class="cov0" title="0">
                return a.analyzeVersionChangeImpact(ctx, sourceNodeID, result)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported impact type: %s", impactType)</span>
        }
}

// analyzeDeleteImpact analyzes the impact of deleting a node
func (a *DependencyImpactAnalyzer) analyzeDeleteImpact(
        ctx context.Context,
        nodeID int64,
        result *models.ImpactAnalysisResult,
) (*models.ImpactAnalysisResult, error) <span class="cov0" title="0">{
        // Find all nodes that depend on this node
        dependents, err := a.dependencyRepo.GetNodeDependents(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependents: %w", err)
        }</span>

        <span class="cov0" title="0">visited := make(map[int64]bool)
        maxDepth := 0
        totalImpactScore := 0

        for _, dep := range dependents </span><span class="cov0" title="0">{
                impact, depth := a.analyzeNodeDeleteImpact(ctx, dep, []int64{nodeID}, visited)
                if impact != nil </span><span class="cov0" title="0">{
                        result.AffectedNodes = append(result.AffectedNodes, *impact)
                        totalImpactScore += a.getImpactScore(impact.ImpactLevel)
                        if depth &gt; maxDepth </span><span class="cov0" title="0">{
                                maxDepth = depth
                        }</span>
                }
        }

        // Calculate overall impact score and metadata
        <span class="cov0" title="0">result.ImpactScore = a.normalizeImpactScore(totalImpactScore, len(result.AffectedNodes))
        result.CascadeDepth = maxDepth
        result.EstimatedTime = a.estimateDeleteTime(len(result.AffectedNodes), maxDepth)

        // Add recommendations
        a.addDeleteRecommendations(result)

        return result, nil</span>
}

// analyzeUpdateImpact analyzes the impact of updating a node
func (a *DependencyImpactAnalyzer) analyzeUpdateImpact(
        ctx context.Context,
        nodeID int64,
        result *models.ImpactAnalysisResult,
) (*models.ImpactAnalysisResult, error) <span class="cov0" title="0">{
        // Find nodes that depend on this node with cascade_update=true
        dependents, err := a.dependencyRepo.GetNodeDependents(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependents: %w", err)
        }</span>

        <span class="cov0" title="0">visited := make(map[int64]bool)
        maxDepth := 0
        totalImpactScore := 0

        for _, dep := range dependents </span><span class="cov0" title="0">{
                if dep.CascadeUpdate </span><span class="cov0" title="0">{
                        impact, depth := a.analyzeNodeUpdateImpact(ctx, dep, []int64{nodeID}, visited)
                        if impact != nil </span><span class="cov0" title="0">{
                                result.AffectedNodes = append(result.AffectedNodes, *impact)
                                totalImpactScore += a.getImpactScore(impact.ImpactLevel)
                                if depth &gt; maxDepth </span><span class="cov0" title="0">{
                                        maxDepth = depth
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">result.ImpactScore = a.normalizeImpactScore(totalImpactScore, len(result.AffectedNodes))
        result.CascadeDepth = maxDepth
        result.EstimatedTime = a.estimateUpdateTime(len(result.AffectedNodes), maxDepth)

        a.addUpdateRecommendations(result)

        return result, nil</span>
}

// analyzeVersionChangeImpact analyzes the impact of changing a node's version
func (a *DependencyImpactAnalyzer) analyzeVersionChangeImpact(
        ctx context.Context,
        nodeID int64,
        result *models.ImpactAnalysisResult,
) (*models.ImpactAnalysisResult, error) <span class="cov0" title="0">{
        // Find nodes with version constraints on this node
        dependents, err := a.dependencyRepo.GetNodeDependents(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependents: %w", err)
        }</span>

        <span class="cov0" title="0">visited := make(map[int64]bool)
        maxDepth := 0
        totalImpactScore := 0

        for _, dep := range dependents </span><span class="cov0" title="0">{
                impact, depth := a.analyzeNodeVersionImpact(ctx, dep, []int64{nodeID}, visited)
                if impact != nil </span><span class="cov0" title="0">{
                        result.AffectedNodes = append(result.AffectedNodes, *impact)
                        totalImpactScore += a.getImpactScore(impact.ImpactLevel)
                        if depth &gt; maxDepth </span><span class="cov0" title="0">{
                                maxDepth = depth
                        }</span>
                }
        }

        <span class="cov0" title="0">result.ImpactScore = a.normalizeImpactScore(totalImpactScore, len(result.AffectedNodes))
        result.CascadeDepth = maxDepth
        result.EstimatedTime = a.estimateVersionChangeTime(len(result.AffectedNodes))

        a.addVersionChangeRecommendations(result)

        return result, nil</span>
}

// analyzeNodeDeleteImpact analyzes impact on a specific node from deletion
func (a *DependencyImpactAnalyzer) analyzeNodeDeleteImpact(
        ctx context.Context,
        dependency *models.NodeDependency,
        path []int64,
        visited map[int64]bool,
) (*models.AffectedNode, int) <span class="cov0" title="0">{
        nodeID := dependency.DependentNodeID

        if visited[nodeID] </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        <span class="cov0" title="0">visited[nodeID] = true

        node, err := a.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0
        }</span>

        <span class="cov0" title="0">impactLevel := a.calculateDeleteImpactLevel(dependency)
        actionNeeded := a.determineDeleteAction(dependency, impactLevel)

        affected := &amp;models.AffectedNode{
                NodeID:       nodeID,
                CompositeID:  a.buildCompositeID(node),
                Title:        node.Title,
                ImpactLevel:  impactLevel,
                Reason:       fmt.Sprintf("Depends on deleted node with %s dependency", dependency.DependencyType),
                ActionNeeded: actionNeeded,
                Path:         append([]int64(nil), path...),
        }

        // Recursively analyze cascade effects if cascade_delete is enabled
        depth := 1
        if dependency.CascadeDelete </span><span class="cov0" title="0">{
                childDeps, _ := a.dependencyRepo.GetNodeDependents(nodeID)
                for _, childDep := range childDeps </span><span class="cov0" title="0">{
                        childPath := append(path, nodeID)
                        childAffected, childDepth := a.analyzeNodeDeleteImpact(ctx, childDep, childPath, visited)
                        if childAffected != nil </span><span class="cov0" title="0">{
                                depth = max(depth, childDepth+1)
                        }</span>
                }
        }

        <span class="cov0" title="0">return affected, depth</span>
}

// analyzeNodeUpdateImpact analyzes impact on a specific node from update
func (a *DependencyImpactAnalyzer) analyzeNodeUpdateImpact(
        ctx context.Context,
        dependency *models.NodeDependency,
        path []int64,
        visited map[int64]bool,
) (*models.AffectedNode, int) <span class="cov0" title="0">{
        nodeID := dependency.DependentNodeID

        if visited[nodeID] </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        <span class="cov0" title="0">visited[nodeID] = true

        node, err := a.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0
        }</span>

        <span class="cov0" title="0">impactLevel := a.calculateUpdateImpactLevel(dependency)
        actionNeeded := a.determineUpdateAction(dependency, impactLevel)

        affected := &amp;models.AffectedNode{
                NodeID:       nodeID,
                CompositeID:  a.buildCompositeID(node),
                Title:        node.Title,
                ImpactLevel:  impactLevel,
                Reason:       fmt.Sprintf("May need update due to %s dependency change", dependency.DependencyType),
                ActionNeeded: actionNeeded,
                Path:         append([]int64(nil), path...),
        }

        // Recursively analyze cascade effects
        depth := 1
        if dependency.CascadeUpdate </span><span class="cov0" title="0">{
                childDeps, _ := a.dependencyRepo.GetNodeDependents(nodeID)
                for _, childDep := range childDeps </span><span class="cov0" title="0">{
                        if childDep.CascadeUpdate </span><span class="cov0" title="0">{
                                childPath := append(path, nodeID)
                                childAffected, childDepth := a.analyzeNodeUpdateImpact(ctx, childDep, childPath, visited)
                                if childAffected != nil </span><span class="cov0" title="0">{
                                        depth = max(depth, childDepth+1)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return affected, depth</span>
}

// analyzeNodeVersionImpact analyzes version constraint impact
func (a *DependencyImpactAnalyzer) analyzeNodeVersionImpact(
        ctx context.Context,
        dependency *models.NodeDependency,
        path []int64,
        visited map[int64]bool,
) (*models.AffectedNode, int) <span class="cov0" title="0">{
        nodeID := dependency.DependentNodeID

        if visited[nodeID] </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        <span class="cov0" title="0">visited[nodeID] = true

        node, err := a.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0
        }</span>

        // Check if this dependency has version constraints
        <span class="cov0" title="0">hasVersionConstraint := false
        if metadata, err := dependency.ParseMetadata(); err == nil &amp;&amp; metadata != nil </span><span class="cov0" title="0">{
                if _, exists := metadata["version_constraint"]; exists </span><span class="cov0" title="0">{
                        hasVersionConstraint = true
                }</span>
        }

        <span class="cov0" title="0">if !hasVersionConstraint </span><span class="cov0" title="0">{
                return nil, 0
        }</span>

        <span class="cov0" title="0">impactLevel := a.calculateVersionImpactLevel(dependency)
        actionNeeded := a.determineVersionAction(dependency, impactLevel)

        affected := &amp;models.AffectedNode{
                NodeID:       nodeID,
                CompositeID:  a.buildCompositeID(node),
                Title:        node.Title,
                ImpactLevel:  impactLevel,
                Reason:       "Has version constraint that may be affected",
                ActionNeeded: actionNeeded,
                Path:         append([]int64(nil), path...),
        }

        return affected, 1</span>
}

// Helper methods for impact calculation

func (a *DependencyImpactAnalyzer) calculateDeleteImpactLevel(dep *models.NodeDependency) string <span class="cov0" title="0">{
        if dep.CascadeDelete </span><span class="cov0" title="0">{
                return models.ImpactLevelCritical
        }</span>

        <span class="cov0" title="0">switch dep.DependencyType </span>{
        case models.DependencyTypeHard:<span class="cov0" title="0">
                return models.ImpactLevelHigh</span>
        case models.DependencyTypeSoft:<span class="cov0" title="0">
                return models.ImpactLevelMedium</span>
        case models.DependencyTypeReference:<span class="cov0" title="0">
                return models.ImpactLevelLow</span>
        default:<span class="cov0" title="0">
                return models.ImpactLevelMedium</span>
        }
}

func (a *DependencyImpactAnalyzer) calculateUpdateImpactLevel(dep *models.NodeDependency) string <span class="cov0" title="0">{
        if dep.CascadeUpdate </span><span class="cov0" title="0">{
                return models.ImpactLevelHigh
        }</span>

        <span class="cov0" title="0">switch dep.DependencyType </span>{
        case models.DependencyTypeHard:<span class="cov0" title="0">
                return models.ImpactLevelMedium</span>
        case models.DependencyTypeSoft:<span class="cov0" title="0">
                return models.ImpactLevelLow</span>
        case models.DependencyTypeReference:<span class="cov0" title="0">
                return models.ImpactLevelLow</span>
        default:<span class="cov0" title="0">
                return models.ImpactLevelLow</span>
        }
}

func (a *DependencyImpactAnalyzer) calculateVersionImpactLevel(dep *models.NodeDependency) string <span class="cov0" title="0">{
        switch dep.DependencyType </span>{
        case models.DependencyTypeHard, models.DependencyTypeRuntime:<span class="cov0" title="0">
                return models.ImpactLevelHigh</span>
        case models.DependencyTypeCompile:<span class="cov0" title="0">
                return models.ImpactLevelMedium</span>
        default:<span class="cov0" title="0">
                return models.ImpactLevelLow</span>
        }
}

func (a *DependencyImpactAnalyzer) determineDeleteAction(dep *models.NodeDependency, impactLevel string) string <span class="cov0" title="0">{
        if dep.CascadeDelete </span><span class="cov0" title="0">{
                return "Will be automatically deleted"
        }</span>

        <span class="cov0" title="0">switch impactLevel </span>{
        case models.ImpactLevelCritical, models.ImpactLevelHigh:<span class="cov0" title="0">
                return "Review and update or remove dependency"</span>
        case models.ImpactLevelMedium:<span class="cov0" title="0">
                return "Consider updating configuration"</span>
        case models.ImpactLevelLow:<span class="cov0" title="0">
                return "Update documentation if needed"</span>
        default:<span class="cov0" title="0">
                return "Monitor for issues"</span>
        }
}

func (a *DependencyImpactAnalyzer) determineUpdateAction(dep *models.NodeDependency, impactLevel string) string <span class="cov0" title="0">{
        if dep.CascadeUpdate </span><span class="cov0" title="0">{
                return "Will be automatically updated"
        }</span>

        <span class="cov0" title="0">switch impactLevel </span>{
        case models.ImpactLevelHigh:<span class="cov0" title="0">
                return "Review and test changes"</span>
        case models.ImpactLevelMedium:<span class="cov0" title="0">
                return "Monitor for compatibility issues"</span>
        case models.ImpactLevelLow:<span class="cov0" title="0">
                return "Update documentation if needed"</span>
        default:<span class="cov0" title="0">
                return "No action required"</span>
        }
}

func (a *DependencyImpactAnalyzer) determineVersionAction(dep *models.NodeDependency, impactLevel string) string <span class="cov0" title="0">{
        switch impactLevel </span>{
        case models.ImpactLevelHigh:<span class="cov0" title="0">
                return "Verify version compatibility and update constraints"</span>
        case models.ImpactLevelMedium:<span class="cov0" title="0">
                return "Test with new version"</span>
        case models.ImpactLevelLow:<span class="cov0" title="0">
                return "Update version constraint if needed"</span>
        default:<span class="cov0" title="0">
                return "Monitor for issues"</span>
        }
}

func (a *DependencyImpactAnalyzer) getImpactScore(level string) int <span class="cov0" title="0">{
        switch level </span>{
        case models.ImpactLevelCritical:<span class="cov0" title="0">
                return 100</span>
        case models.ImpactLevelHigh:<span class="cov0" title="0">
                return 75</span>
        case models.ImpactLevelMedium:<span class="cov0" title="0">
                return 50</span>
        case models.ImpactLevelLow:<span class="cov0" title="0">
                return 25</span>
        default:<span class="cov0" title="0">
                return 25</span>
        }
}

func (a *DependencyImpactAnalyzer) normalizeImpactScore(total, count int) int <span class="cov0" title="0">{
        if count == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">avg := total / count

        // Apply curve based on count of affected nodes
        if count &gt; 10 </span><span class="cov0" title="0">{
                avg = int(float64(avg) * 1.2) // Amplify for many affected nodes
        }</span> else<span class="cov0" title="0"> if count &gt; 5 </span><span class="cov0" title="0">{
                avg = int(float64(avg) * 1.1)
        }</span>

        <span class="cov0" title="0">if avg &gt; 100 </span><span class="cov0" title="0">{
                return 100
        }</span>
        <span class="cov0" title="0">return avg</span>
}

func (a *DependencyImpactAnalyzer) estimateDeleteTime(affectedCount, depth int) string <span class="cov0" title="0">{
        base := time.Duration(affectedCount) * 5 * time.Minute // 5 minutes per affected node
        cascade := time.Duration(depth) * 10 * time.Minute     // 10 minutes per depth level
        total := base + cascade

        if total &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d minutes", int(total.Minutes()))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f hours", total.Hours())</span>
}

func (a *DependencyImpactAnalyzer) estimateUpdateTime(affectedCount, depth int) string <span class="cov0" title="0">{
        base := time.Duration(affectedCount) * 2 * time.Minute // 2 minutes per affected node
        cascade := time.Duration(depth) * 5 * time.Minute      // 5 minutes per depth level
        total := base + cascade

        if total &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d minutes", int(total.Minutes()))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f hours", total.Hours())</span>
}

func (a *DependencyImpactAnalyzer) estimateVersionChangeTime(affectedCount int) string <span class="cov0" title="0">{
        total := time.Duration(affectedCount) * 3 * time.Minute // 3 minutes per affected node

        if total &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d minutes", int(total.Minutes()))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f hours", total.Hours())</span>
}

func (a *DependencyImpactAnalyzer) addDeleteRecommendations(result *models.ImpactAnalysisResult) <span class="cov0" title="0">{
        criticalCount := 0
        highCount := 0

        for _, node := range result.AffectedNodes </span><span class="cov0" title="0">{
                switch node.ImpactLevel </span>{
                case models.ImpactLevelCritical:<span class="cov0" title="0">
                        criticalCount++</span>
                case models.ImpactLevelHigh:<span class="cov0" title="0">
                        highCount++</span>
                }
        }

        <span class="cov0" title="0">if criticalCount &gt; 0 </span><span class="cov0" title="0">{
                result.Recommendations = append(result.Recommendations,
                        fmt.Sprintf("⚠️  %d nodes will be automatically deleted due to cascade delete", criticalCount))
                result.Recommendations = append(result.Recommendations,
                        "Consider backing up data before proceeding")
        }</span>

        <span class="cov0" title="0">if highCount &gt; 0 </span><span class="cov0" title="0">{
                result.Recommendations = append(result.Recommendations,
                        fmt.Sprintf("🔍 Review %d nodes with high impact dependencies", highCount))
        }</span>

        <span class="cov0" title="0">if len(result.AffectedNodes) &gt; 5 </span><span class="cov0" title="0">{
                result.Recommendations = append(result.Recommendations,
                        "Consider phased deletion approach to minimize disruption")
        }</span>
}

func (a *DependencyImpactAnalyzer) addUpdateRecommendations(result *models.ImpactAnalysisResult) <span class="cov0" title="0">{
        if len(result.AffectedNodes) &gt; 0 </span><span class="cov0" title="0">{
                result.Recommendations = append(result.Recommendations,
                        "Test in staging environment before production deployment")
        }</span>

        <span class="cov0" title="0">if result.CascadeDepth &gt; 3 </span><span class="cov0" title="0">{
                result.Recommendations = append(result.Recommendations,
                        "Deep cascade detected - consider gradual rollout")
        }</span>
}

func (a *DependencyImpactAnalyzer) addVersionChangeRecommendations(result *models.ImpactAnalysisResult) <span class="cov0" title="0">{
        if len(result.AffectedNodes) &gt; 0 </span><span class="cov0" title="0">{
                result.Recommendations = append(result.Recommendations,
                        "Verify version constraints are compatible")
                result.Recommendations = append(result.Recommendations,
                        "Run compatibility tests before deployment")
        }</span>
}

func (a *DependencyImpactAnalyzer) buildCompositeID(node *models.Node) string <span class="cov0" title="0">{
        return fmt.Sprintf("url-db:%d", node.ID)
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "time"

        "url-db/internal/models"
)

type AttributeRepository interface {
        Create(ctx context.Context, attribute *models.Attribute) error
        GetByID(ctx context.Context, id int) (*models.Attribute, error)
        GetByDomainAndName(ctx context.Context, domainID int, name string) (*models.Attribute, error)
        ListByDomain(ctx context.Context, domainID int) ([]*models.Attribute, error)
        Update(ctx context.Context, attribute *models.Attribute) error
        Delete(ctx context.Context, id int) error
        ExistsByDomainAndName(ctx context.Context, domainID int, name string) (bool, error)
}

type attributeService struct {
        attributeRepo AttributeRepository
        domainRepo    DomainRepository
        logger        *log.Logger
}

func NewAttributeService(attributeRepo AttributeRepository, domainRepo DomainRepository, logger *log.Logger) AttributeService <span class="cov0" title="0">{
        return &amp;attributeService{
                attributeRepo: attributeRepo,
                domainRepo:    domainRepo,
                logger:        logger,
        }
}</span>

func (s *attributeService) CreateAttribute(ctx context.Context, domainID int, req *models.CreateAttributeRequest) (*models.Attribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Name = normalizeString(req.Name)
        req.Type = models.AttributeType(normalizeString(string(req.Type)))
        req.Description = normalizeString(req.Description)

        if err := validateAttributeName(req.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateAttributeType(string(req.Type)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainRepo.GetByID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">exists, err := s.attributeRepo.ExistsByDomainAndName(ctx, domainID, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to check attribute existence: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, NewAttributeAlreadyExistsError(domainID, req.Name)
        }</span>

        <span class="cov0" title="0">attribute := &amp;models.Attribute{
                DomainID:    domainID,
                Name:        req.Name,
                Type:        req.Type,
                Description: req.Description,
                CreatedAt:   time.Now(),
        }

        if err := s.attributeRepo.Create(ctx, attribute); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to create attribute: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Created attribute: %s in domain %s (ID: %d)", attribute.Name, domain.Name, attribute.ID)
        return attribute, nil</span>
}

func (s *attributeService) GetAttribute(ctx context.Context, id int) (*models.Attribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return attribute, nil</span>
}

func (s *attributeService) ListAttributesByDomain(ctx context.Context, domainID int) (*models.AttributeListResponse, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainRepo.GetByID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">attributes, err := s.attributeRepo.ListByDomain(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to list attributes: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">attributeList := make([]models.Attribute, len(attributes))
        for i, attribute := range attributes </span><span class="cov0" title="0">{
                attributeList[i] = *attribute
        }</span>

        <span class="cov0" title="0">return &amp;models.AttributeListResponse{
                Attributes: attributeList,
                Domain:     domain,
        }, nil</span>
}

func (s *attributeService) UpdateAttribute(ctx context.Context, id int, req *models.UpdateAttributeRequest) (*models.Attribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Description = normalizeString(req.Description)

        if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">attribute.Description = req.Description

        if err := s.attributeRepo.Update(ctx, attribute); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to update attribute: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Updated attribute: %s (ID: %d)", attribute.Name, attribute.ID)
        return attribute, nil</span>
}

func (s *attributeService) DeleteAttribute(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err := s.attributeRepo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to delete attribute: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">s.logger.Printf("Deleted attribute with ID: %d", id)
        return nil</span>
}

func (s *attributeService) ValidateAttributeValue(ctx context.Context, attributeID int, value string) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(attributeID, "attributeID"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">value = normalizeString(value)

        attribute, err := s.attributeRepo.GetByID(ctx, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewAttributeNotFoundError(attributeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">if err := validateAttributeValue(string(attribute.Type), value); err != nil </span><span class="cov0" title="0">{
                return NewAttributeValueInvalidError(attributeID, value, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">package services

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "url-db/internal/models"
)

type compositeKeyService struct {
        toolName string
}

func NewCompositeKeyService(toolName string) CompositeKeyService <span class="cov0" title="0">{
        return &amp;compositeKeyService{
                toolName: toolName,
        }
}</span>

func (s *compositeKeyService) Create(domainName string, id int) string <span class="cov0" title="0">{
        normalizedDomain := s.normalizeName(domainName)
        return fmt.Sprintf("%s:%s:%d", s.toolName, normalizedDomain, id)
}</span>

func (s *compositeKeyService) Parse(compositeKey string) (*models.CompositeKey, error) <span class="cov0" title="0">{
        if compositeKey == "" </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "composite key is empty")
        }</span>

        <span class="cov0" title="0">parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "invalid format, expected 'tool:domain:id'")
        }</span>

        <span class="cov0" title="0">toolName := parts[0]
        domainName := parts[1]
        idStr := parts[2]

        if toolName == "" </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "tool name is empty")
        }</span>

        <span class="cov0" title="0">if toolName != s.toolName </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, fmt.Sprintf("invalid tool name, expected '%s'", s.toolName))
        }</span>

        <span class="cov0" title="0">if domainName == "" </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "domain name is empty")
        }</span>

        <span class="cov0" title="0">if idStr == "" </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "ID is empty")
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "ID must be a valid integer")
        }</span>

        <span class="cov0" title="0">if id &lt;= 0 </span><span class="cov0" title="0">{
                return nil, NewInvalidCompositeKeyError(compositeKey, "ID must be positive")
        }</span>

        <span class="cov0" title="0">return &amp;models.CompositeKey{
                ToolName:   toolName,
                DomainName: domainName,
                ID:         id,
        }, nil</span>
}

func (s *compositeKeyService) Validate(compositeKey string) error <span class="cov0" title="0">{
        _, err := s.Parse(compositeKey)
        return err
}</span>

func (s *compositeKeyService) GetToolName() string <span class="cov0" title="0">{
        return s.toolName
}</span>

func (s *compositeKeyService) normalizeName(name string) string <span class="cov0" title="0">{
        normalized := strings.ToLower(name)

        reg := regexp.MustCompile(`[^a-z0-9\-_]`)
        normalized = reg.ReplaceAllString(normalized, "-")

        reg = regexp.MustCompile(`-+`)
        normalized = reg.ReplaceAllString(normalized, "-")

        normalized = strings.Trim(normalized, "-")

        if normalized == "" </span><span class="cov0" title="0">{
                normalized = "default"
        }</span>

        <span class="cov0" title="0">return normalized</span>
}

func (s *compositeKeyService) DenormalizeName(normalizedName string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(normalizedName, "-", " ")
}</span>

func (s *compositeKeyService) ExtractComponents(compositeKey string) (toolName, domainName string, id int, err error) <span class="cov0" title="0">{
        ck, err := s.Parse(compositeKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", 0, err
        }</span>

        <span class="cov0" title="0">return ck.ToolName, ck.DomainName, ck.ID, nil</span>
}

func (s *compositeKeyService) IsValid(compositeKey string) bool <span class="cov0" title="0">{
        return s.Validate(compositeKey) == nil
}</span>

func (s *compositeKeyService) GenerateFromNode(node *models.Node, domainName string) string <span class="cov0" title="0">{
        return s.Create(domainName, node.ID)
}</span>

func (s *compositeKeyService) GenerateFromDomain(domain *models.Domain) string <span class="cov0" title="0">{
        return s.Create(domain.Name, domain.ID)
}</span>
</pre>
		
		<pre class="file" id="file149" style="display: none">package services

import (
        "fmt"

        "url-db/internal/models"
        "url-db/internal/repositories"
)

// DependencyService handles business logic for dependencies
type DependencyService struct {
        dependencyRepo *repositories.DependencyRepository
        nodeRepo       repositories.NodeRepository
        eventRepo      *repositories.EventRepository
}

// NewDependencyService creates a new dependency service
func NewDependencyService(
        dependencyRepo *repositories.DependencyRepository,
        nodeRepo repositories.NodeRepository,
        eventRepo *repositories.EventRepository,
) *DependencyService <span class="cov0" title="0">{
        return &amp;DependencyService{
                dependencyRepo: dependencyRepo,
                nodeRepo:       nodeRepo,
                eventRepo:      eventRepo,
        }
}</span>

// CreateDependency creates a new dependency
func (s *DependencyService) CreateDependency(dependentNodeID int64, req *models.CreateNodeDependencyRequest) (*models.NodeDependency, error) <span class="cov0" title="0">{
        // Verify both nodes exist
        dependentNode, err := s.nodeRepo.GetByID(int(dependentNodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependent node: %w", err)
        }</span>
        <span class="cov0" title="0">if dependentNode == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependent node not found")
        }</span>

        <span class="cov0" title="0">dependencyNode, err := s.nodeRepo.GetByID(int(req.DependencyNodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependency node: %w", err)
        }</span>
        <span class="cov0" title="0">if dependencyNode == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependency node not found")
        }</span>

        // Check for circular dependency
        <span class="cov0" title="0">hasCircular, err := s.dependencyRepo.CheckCircularDependency(dependentNodeID, req.DependencyNodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check circular dependency: %w", err)
        }</span>
        <span class="cov0" title="0">if hasCircular </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("circular dependency detected")
        }</span>

        // Create dependency
        <span class="cov0" title="0">dependency := &amp;models.NodeDependency{
                DependentNodeID:  dependentNodeID,
                DependencyNodeID: req.DependencyNodeID,
                DependencyType:   req.DependencyType,
                CascadeDelete:    req.CascadeDelete,
                CascadeUpdate:    req.CascadeUpdate,
                Metadata:         req.Metadata,
        }

        err = s.dependencyRepo.Create(dependency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create dependency: %w", err)
        }</span>

        <span class="cov0" title="0">return dependency, nil</span>
}

// GetDependency retrieves a dependency by ID
func (s *DependencyService) GetDependency(id int64) (*models.NodeDependency, error) <span class="cov0" title="0">{
        dependency, err := s.dependencyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dependency: %w", err)
        }</span>
        <span class="cov0" title="0">if dependency == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependency not found")
        }</span>

        <span class="cov0" title="0">return dependency, nil</span>
}

// DeleteDependency deletes a dependency
func (s *DependencyService) DeleteDependency(id int64) error <span class="cov0" title="0">{
        err := s.dependencyRepo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete dependency: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetNodeDependencies retrieves all dependencies for a node (as dependent)
func (s *DependencyService) GetNodeDependencies(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        <span class="cov0" title="0">return s.dependencyRepo.GetByDependentNode(nodeID)</span>
}

// GetNodeDependents retrieves all nodes that depend on a given node
func (s *DependencyService) GetNodeDependents(nodeID int64) ([]*models.NodeDependency, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        <span class="cov0" title="0">return s.dependencyRepo.GetByDependencyNode(nodeID)</span>
}

// HandleNodeDeletion handles cascading deletes when a node is deleted
func (s *DependencyService) HandleNodeDeletion(nodeID int64) error <span class="cov0" title="0">{
        // Get all dependents with cascade delete
        dependentIDs, err := s.dependencyRepo.GetDependentsWithCascadeDelete(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get cascade delete dependents: %w", err)
        }</span>

        // Delete each dependent node (this will trigger their own cascades)
        <span class="cov0" title="0">for _, depID := range dependentIDs </span><span class="cov0" title="0">{
                err = s.nodeRepo.Delete(int(depID))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete dependent node %d: %w", depID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// HandleNodeUpdate handles cascading updates when a node is updated
func (s *DependencyService) HandleNodeUpdate(nodeID int64, changes *models.EventChanges) error <span class="cov0" title="0">{
        // Get all dependents with cascade update
        dependentIDs, err := s.dependencyRepo.GetDependentsWithCascadeUpdate(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get cascade update dependents: %w", err)
        }</span>

        // Create update event for each dependent
        <span class="cov0" title="0">for _, depID := range dependentIDs </span><span class="cov0" title="0">{
                eventData := &amp;models.EventData{
                        NodeID:    depID,
                        EventType: "dependency_updated",
                        Metadata: map[string]interface{}{
                                "dependency_node_id": nodeID,
                                "changes":            changes,
                        },
                }

                event := &amp;models.NodeEvent{
                        NodeID:    depID,
                        EventType: "dependency_updated",
                        EventData: eventData,
                }

                err = s.eventRepo.Create(event)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create update event for dependent %d: %w", depID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "time"

        "url-db/internal/models"
)

type DomainRepository interface {
        Create(ctx context.Context, domain *models.Domain) error
        GetByID(ctx context.Context, id int) (*models.Domain, error)
        GetByName(ctx context.Context, name string) (*models.Domain, error)
        List(ctx context.Context, page, size int) ([]*models.Domain, int, error)
        Update(ctx context.Context, domain *models.Domain) error
        Delete(ctx context.Context, id int) error
        ExistsByName(ctx context.Context, name string) (bool, error)
}

type domainService struct {
        domainRepo DomainRepository
        logger     *log.Logger
}

func NewDomainService(domainRepo DomainRepository, logger *log.Logger) DomainService <span class="cov8" title="1">{
        return &amp;domainService{
                domainRepo: domainRepo,
                logger:     logger,
        }
}</span>

func (s *domainService) CreateDomain(ctx context.Context, req *models.CreateDomainRequest) (*models.Domain, error) <span class="cov8" title="1">{
        req.Name = normalizeString(req.Name)
        req.Description = normalizeString(req.Description)

        if err := validateDomainName(req.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">exists, err := s.domainRepo.ExistsByName(ctx, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to check domain existence: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov0" title="0">{
                return nil, NewDomainAlreadyExistsError(req.Name)
        }</span>

        <span class="cov8" title="1">domain := &amp;models.Domain{
                Name:        req.Name,
                Description: req.Description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        if err := s.domainRepo.Create(ctx, domain); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to create domain: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Created domain: %s (ID: %d)", domain.Name, domain.ID)
        return domain, nil</span>
}

func (s *domainService) GetDomain(ctx context.Context, id int) (*models.Domain, error) <span class="cov8" title="1">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">domain, err := s.domainRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, NewDomainNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov8" title="1">return domain, nil</span>
}

func (s *domainService) GetDomainByName(ctx context.Context, name string) (*models.Domain, error) <span class="cov0" title="0">{
        name = normalizeString(name)

        if err := validateDomainName(name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainRepo.GetByName(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(0)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain by name: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return domain, nil</span>
}

func (s *domainService) ListDomains(ctx context.Context, page, size int) (*models.DomainListResponse, error) <span class="cov8" title="1">{
        page, size, err := validatePaginationParams(page, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">domains, totalCount, err := s.domainRepo.List(ctx, page, size)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to list domains: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">domainList := make([]models.Domain, len(domains))
        for i, domain := range domains </span><span class="cov8" title="1">{
                domainList[i] = *domain
        }</span>

        <span class="cov8" title="1">totalPages := (totalCount + size - 1) / size

        return &amp;models.DomainListResponse{
                Domains:    domainList,
                TotalCount: totalCount,
                Page:       page,
                Size:       size,
                TotalPages: totalPages,
        }, nil</span>
}

func (s *domainService) UpdateDomain(ctx context.Context, id int, req *models.UpdateDomainRequest) (*models.Domain, error) <span class="cov8" title="1">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req.Description = normalizeString(req.Description)

        if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">domain, err := s.domainRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov8" title="1">domain.Description = req.Description
        domain.UpdatedAt = time.Now()

        if err := s.domainRepo.Update(ctx, domain); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to update domain: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Updated domain: %s (ID: %d)", domain.Name, domain.ID)
        return domain, nil</span>
}

func (s *domainService) DeleteDomain(ctx context.Context, id int) error <span class="cov8" title="1">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err := s.domainRepo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewDomainNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to delete domain: %v", err)
                return err</span>
        }

        <span class="cov8" title="1">s.logger.Printf("Deleted domain with ID: %d", id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package services

import "fmt"

type ServiceError struct {
        Code    string
        Message string
        Details interface{}
}

func (e *ServiceError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func NewValidationError(field, message string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "VALIDATION_ERROR",
                Message: fmt.Sprintf("Validation failed for field '%s': %s", field, message),
                Details: map[string]string{"field": field, "message": message},
        }
}</span>

func NewDomainAlreadyExistsError(name string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "DOMAIN_ALREADY_EXISTS",
                Message: fmt.Sprintf("Domain '%s' already exists", name),
                Details: map[string]string{"domain": name},
        }
}</span>

func NewNodeAlreadyExistsError(url string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "NODE_ALREADY_EXISTS",
                Message: fmt.Sprintf("Node with URL '%s' already exists", url),
                Details: map[string]string{"url": url},
        }
}</span>

func NewAttributeAlreadyExistsError(domainID int, name string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "ATTRIBUTE_ALREADY_EXISTS",
                Message: fmt.Sprintf("Attribute '%s' already exists in domain %d", name, domainID),
                Details: map[string]interface{}{"domain_id": domainID, "name": name},
        }
}</span>

func NewInvalidCompositeKeyError(key, reason string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "INVALID_COMPOSITE_KEY",
                Message: fmt.Sprintf("Invalid composite key '%s': %s", key, reason),
                Details: map[string]string{"key": key, "reason": reason},
        }
}</span>

func NewDomainNotFoundError(id int) *ServiceError <span class="cov8" title="1">{
        return &amp;ServiceError{
                Code:    "DOMAIN_NOT_FOUND",
                Message: fmt.Sprintf("Domain with id %d not found", id),
                Details: map[string]int{"id": id},
        }
}</span>

func NewNodeNotFoundError(id int) *ServiceError <span class="cov8" title="1">{
        return &amp;ServiceError{
                Code:    "NODE_NOT_FOUND",
                Message: fmt.Sprintf("Node with id %d not found", id),
                Details: map[string]int{"id": id},
        }
}</span>

func NewAttributeNotFoundError(id int) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "ATTRIBUTE_NOT_FOUND",
                Message: fmt.Sprintf("Attribute with id %d not found", id),
                Details: map[string]int{"id": id},
        }
}</span>

func NewNodeAttributeNotFoundError(id int) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "NODE_ATTRIBUTE_NOT_FOUND",
                Message: fmt.Sprintf("Node attribute with id %d not found", id),
                Details: map[string]int{"id": id},
        }
}</span>

func NewAttributeValueInvalidError(attributeID int, value, reason string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "ATTRIBUTE_VALUE_INVALID",
                Message: fmt.Sprintf("Invalid value '%s' for attribute %d: %s", value, attributeID, reason),
                Details: map[string]interface{}{"attribute_id": attributeID, "value": value, "reason": reason},
        }
}</span>

func NewBusinessLogicError(message string) *ServiceError <span class="cov0" title="0">{
        return &amp;ServiceError{
                Code:    "BUSINESS_LOGIC_ERROR",
                Message: message,
                Details: nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">package services

import (
        "fmt"
        "time"

        "url-db/internal/models"
        "url-db/internal/repositories"
)

// EventService handles business logic for events
type EventService struct {
        eventRepo *repositories.EventRepository
        nodeRepo  repositories.NodeRepository
}

// NewEventService creates a new event service
func NewEventService(
        eventRepo *repositories.EventRepository,
        nodeRepo repositories.NodeRepository,
) *EventService <span class="cov0" title="0">{
        return &amp;EventService{
                eventRepo: eventRepo,
                nodeRepo:  nodeRepo,
        }
}</span>

// GetNodeEvents retrieves events for a specific node
func (s *EventService) GetNodeEvents(nodeID int64, limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        <span class="cov0" title="0">if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">return s.eventRepo.GetByNode(nodeID, limit)</span>
}

// GetPendingEvents retrieves unprocessed events
func (s *EventService) GetPendingEvents(limit int) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        if limit &lt;= 0 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">return s.eventRepo.GetPendingEvents(limit)</span>
}

// ProcessEvent marks an event as processed
func (s *EventService) ProcessEvent(eventID int64) error <span class="cov0" title="0">{
        // Verify event exists
        event, err := s.eventRepo.GetByID(eventID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get event: %w", err)
        }</span>
        <span class="cov0" title="0">if event == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event not found")
        }</span>

        <span class="cov0" title="0">if event.ProcessedAt != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event already processed")
        }</span>

        <span class="cov0" title="0">return s.eventRepo.MarkAsProcessed(eventID)</span>
}

// GetEventsByTypeAndDateRange retrieves events by type within a date range
func (s *EventService) GetEventsByTypeAndDateRange(eventType string, start, end time.Time) ([]*models.NodeEvent, error) <span class="cov0" title="0">{
        // Validate date range
        if end.Before(start) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("end date must be after start date")
        }</span>

        <span class="cov0" title="0">return s.eventRepo.GetByTypeAndDateRange(eventType, start, end)</span>
}

// CleanupOldEvents deletes processed events older than the specified duration
func (s *EventService) CleanupOldEvents(olderThan time.Duration) (int64, error) <span class="cov0" title="0">{
        if olderThan &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("minimum retention period is 24 hours")
        }</span>

        <span class="cov0" title="0">return s.eventRepo.DeleteOldEvents(olderThan)</span>
}

// GetEventStats retrieves statistics about events
func (s *EventService) GetEventStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        return s.eventRepo.GetEventStats()
}</span>

// CreateNodeEvent creates a new event for a node
func (s *EventService) CreateNodeEvent(nodeID int64, eventType string, changes *models.EventChanges) error <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("node not found")
        }</span>

        // Create event data
        <span class="cov0" title="0">eventData := &amp;models.EventData{
                NodeID:    nodeID,
                EventType: eventType,
                Timestamp: time.Now(),
                Changes:   changes,
                Metadata: map[string]interface{}{
                        "domain_id": node.DomainID,
                },
        }

        // Create event
        event := &amp;models.NodeEvent{
                NodeID:    nodeID,
                EventType: eventType,
                EventData: eventData,
        }

        return s.eventRepo.Create(event)</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package services

import (
        "context"
        "fmt"
        "log"

        "url-db/internal/models"
)

type mcpService struct {
        nodeService          NodeService
        domainService        DomainService
        attributeService     AttributeService
        nodeAttributeService NodeAttributeService
        compositeKeyService  CompositeKeyService
        toolName             string
        version              string
        logger               *log.Logger
}

func NewMCPService(
        nodeService NodeService,
        domainService DomainService,
        attributeService AttributeService,
        nodeAttributeService NodeAttributeService,
        compositeKeyService CompositeKeyService,
        toolName, version string,
        logger *log.Logger,
) MCPService <span class="cov0" title="0">{
        return &amp;mcpService{
                nodeService:          nodeService,
                domainService:        domainService,
                attributeService:     attributeService,
                nodeAttributeService: nodeAttributeService,
                compositeKeyService:  compositeKeyService,
                toolName:             toolName,
                version:              version,
                logger:               logger,
        }
}</span>

func (s *mcpService) CreateNode(ctx context.Context, req *models.CreateMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        req.DomainName = normalizeString(req.DomainName)
        req.URL = normalizeString(req.URL)
        req.Title = normalizeString(req.Title)
        req.Description = normalizeString(req.Description)

        if err := validateDomainName(req.DomainName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, req.DomainName)
        if err != nil </span><span class="cov0" title="0">{
                if serviceErr, ok := err.(*ServiceError); ok &amp;&amp; serviceErr.Code == "DOMAIN_NOT_FOUND" </span><span class="cov0" title="0">{
                        createDomainReq := &amp;models.CreateDomainRequest{
                                Name:        req.DomainName,
                                Description: fmt.Sprintf("Auto-created domain for %s", req.DomainName),
                        }
                        domain, err = s.domainService.CreateDomain(ctx, createDomainReq)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">createNodeReq := &amp;models.CreateNodeRequest{
                URL:         req.URL,
                Title:       req.Title,
                Description: req.Description,
        }

        node, err := s.nodeService.CreateNode(ctx, domain.ID, createNodeReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.convertToMCPNode(node, domain), nil</span>
}

func (s *mcpService) GetNode(ctx context.Context, compositeID string) (*models.MCPNode, error) <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">node, err := s.nodeService.GetNode(ctx, ck.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomain(ctx, node.DomainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.convertToMCPNode(node, domain), nil</span>
}

func (s *mcpService) ListNodes(ctx context.Context, domainName string, page, size int, search string) (*models.MCPNodeListResponse, error) <span class="cov0" title="0">{
        domainName = normalizeString(domainName)

        if err := validateDomainName(domainName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, domainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeListResp, err := s.nodeService.ListNodesByDomain(ctx, domain.ID, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mcpNodes := make([]models.MCPNode, len(nodeListResp.Nodes))
        for i, node := range nodeListResp.Nodes </span><span class="cov0" title="0">{
                mcpNodes[i] = *s.convertToMCPNode(&amp;node, domain)
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPNodeListResponse{
                Nodes:      mcpNodes,
                TotalCount: nodeListResp.TotalCount,
                Page:       nodeListResp.Page,
                Size:       nodeListResp.Size,
                TotalPages: nodeListResp.TotalPages,
        }, nil</span>
}

func (s *mcpService) UpdateNode(ctx context.Context, compositeID string, req *models.UpdateMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updateReq := &amp;models.UpdateNodeRequest{
                Title:       req.Title,
                Description: req.Description,
        }

        node, err := s.nodeService.UpdateNode(ctx, ck.ID, updateReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomain(ctx, node.DomainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.convertToMCPNode(node, domain), nil</span>
}

func (s *mcpService) DeleteNode(ctx context.Context, compositeID string) error <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.nodeService.DeleteNode(ctx, ck.ID)</span>
}

func (s *mcpService) FindNodeByURL(ctx context.Context, req *models.FindMCPNodeRequest) (*models.MCPNode, error) <span class="cov0" title="0">{
        req.DomainName = normalizeString(req.DomainName)

        if err := validateDomainName(req.DomainName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">domain, err := s.domainService.GetDomainByName(ctx, req.DomainName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">findReq := &amp;models.FindNodeByURLRequest{
                URL: req.URL,
        }

        node, err := s.nodeService.FindNodeByURL(ctx, domain.ID, findReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.convertToMCPNode(node, domain), nil</span>
}

func (s *mcpService) BatchGetNodes(ctx context.Context, req *models.BatchMCPNodeRequest) (*models.BatchMCPNodeResponse, error) <span class="cov0" title="0">{
        results := make([]models.MCPNode, 0, len(req.CompositeIDs))
        errors := make([]string, 0)

        for _, compositeID := range req.CompositeIDs </span><span class="cov0" title="0">{
                node, err := s.GetNode(ctx, compositeID)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Failed to get node %s: %v", compositeID, err))
                        continue</span>
                }
                <span class="cov0" title="0">results = append(results, *node)</span>
        }

        <span class="cov0" title="0">return &amp;models.BatchMCPNodeResponse{
                Nodes:  results,
                Errors: errors,
        }, nil</span>
}

func (s *mcpService) ListDomains(ctx context.Context) (*models.MCPDomainListResponse, error) <span class="cov0" title="0">{
        domainsResp, err := s.domainService.ListDomains(ctx, 1, 100)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mcpDomains := make([]models.MCPDomain, len(domainsResp.Domains))
        for i, domain := range domainsResp.Domains </span><span class="cov0" title="0">{
                mcpDomains[i] = models.MCPDomain{
                        Name:        domain.Name,
                        Description: domain.Description,
                        CreatedAt:   domain.CreatedAt,
                        UpdatedAt:   domain.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomainListResponse{
                Domains: mcpDomains,
        }, nil</span>
}

func (s *mcpService) CreateDomain(ctx context.Context, req *models.CreateMCPDomainRequest) (*models.MCPDomain, error) <span class="cov0" title="0">{
        createReq := &amp;models.CreateDomainRequest{
                Name:        req.Name,
                Description: req.Description,
        }

        domain, err := s.domainService.CreateDomain(ctx, createReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPDomain{
                Name:        domain.Name,
                Description: domain.Description,
                CreatedAt:   domain.CreatedAt,
                UpdatedAt:   domain.UpdatedAt,
        }, nil</span>
}

func (s *mcpService) GetNodeAttributes(ctx context.Context, compositeID string) (*models.MCPNodeAttributeResponse, error) <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeAttrsResp, err := s.nodeAttributeService.ListNodeAttributesByNode(ctx, ck.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">attributes := make([]models.MCPAttribute, len(nodeAttrsResp.NodeAttributes))
        for i, nodeAttr := range nodeAttrsResp.NodeAttributes </span><span class="cov0" title="0">{
                attributes[i] = models.MCPAttribute{
                        Name:  fmt.Sprintf("attr_%d", nodeAttr.AttributeID),
                        Type:  string(nodeAttr.Type),
                        Value: nodeAttr.Value,
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.MCPNodeAttributeResponse{
                CompositeID: compositeID,
                Attributes:  attributes,
        }, nil</span>
}

func (s *mcpService) SetNodeAttributes(ctx context.Context, compositeID string, req *models.SetMCPNodeAttributesRequest) error <span class="cov0" title="0">{
        ck, err := s.compositeKeyService.Parse(compositeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // SetNodeAttributes functionality is not yet implemented
        // This would require:
        // 1. Finding or creating attribute definitions in the domain
        // 2. Creating node_attribute entries with the found attribute IDs
        // 3. Handling validation and type checking
        <span class="cov0" title="0">s.logger.Printf("SetNodeAttributes called for node %d with %d attributes (not implemented)",
                ck.ID, len(req.Attributes))

        return fmt.Errorf("SetNodeAttributes is not yet implemented")</span>
}

func (s *mcpService) GetServerInfo(ctx context.Context) (*models.MCPServerInfo, error) <span class="cov0" title="0">{
        return &amp;models.MCPServerInfo{
                Name:        s.toolName,
                Version:     s.version,
                Description: "URL Database Management System",
        }, nil
}</span>

func (s *mcpService) convertToMCPNode(node *models.Node, domain *models.Domain) *models.MCPNode <span class="cov0" title="0">{
        compositeID := s.compositeKeyService.Create(domain.Name, node.ID)

        return &amp;models.MCPNode{
                CompositeID: compositeID,
                URL:         node.Content,
                DomainName:  domain.Name,
                Title:       node.Title,
                Description: node.Description,
                CreatedAt:   node.CreatedAt,
                UpdatedAt:   node.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file154" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "time"

        "url-db/internal/models"
)

type NodeRepository interface {
        Create(ctx context.Context, node *models.Node) error
        GetByID(ctx context.Context, id int) (*models.Node, error)
        GetByDomainAndContent(ctx context.Context, domainID int, content string) (*models.Node, error)
        ListByDomain(ctx context.Context, domainID int, page, size int, search string) ([]*models.Node, int, error)
        Update(ctx context.Context, node *models.Node) error
        Delete(ctx context.Context, id int) error
        ExistsByDomainAndContent(ctx context.Context, domainID int, content string) (bool, error)
}

type nodeService struct {
        nodeRepo   NodeRepository
        domainRepo DomainRepository
        logger     *log.Logger
}

func NewNodeService(nodeRepo NodeRepository, domainRepo DomainRepository, logger *log.Logger) NodeService <span class="cov8" title="1">{
        return &amp;nodeService{
                nodeRepo:   nodeRepo,
                domainRepo: domainRepo,
                logger:     logger,
        }
}</span>

func (s *nodeService) CreateNode(ctx context.Context, domainID int, req *models.CreateNodeRequest) (*models.Node, error) <span class="cov8" title="1">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req.URL = normalizeString(req.URL)
        req.Title = normalizeString(req.Title)
        req.Description = normalizeString(req.Description)

        if err := validateURL(req.URL); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := validateTitle(req.Title); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">domain, err := s.domainRepo.GetByID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov8" title="1">exists, err := s.nodeRepo.ExistsByDomainAndContent(ctx, domainID, req.URL)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to check node existence: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov0" title="0">{
                return nil, NewNodeAlreadyExistsError(req.URL)
        }</span>

        <span class="cov8" title="1">title := req.Title
        if title == "" </span><span class="cov0" title="0">{
                title = generateTitleFromURL(req.URL)
        }</span>

        <span class="cov8" title="1">node := &amp;models.Node{
                Content:     req.URL,
                DomainID:    domainID,
                Title:       title,
                Description: req.Description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        if err := s.nodeRepo.Create(ctx, node); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to create node: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Created node: %s in domain %s (ID: %d)", node.Content, domain.Name, node.ID)
        return node, nil</span>
}

func (s *nodeService) GetNode(ctx context.Context, id int) (*models.Node, error) <span class="cov8" title="1">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">node, err := s.nodeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, NewNodeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return nil, err</span>
        }

        <span class="cov8" title="1">return node, nil</span>
}

func (s *nodeService) GetNodeByDomainAndURL(ctx context.Context, domainID int, url string) (*models.Node, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url = normalizeString(url)
        if err := validateURL(url); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">node, err := s.nodeRepo.GetByDomainAndContent(ctx, domainID, url)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeNotFoundError(0)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node by domain and URL: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return node, nil</span>
}

func (s *nodeService) ListNodesByDomain(ctx context.Context, domainID int, page, size int, search string) (*models.NodeListResponse, error) <span class="cov8" title="1">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">page, size, err := validatePaginationParams(page, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">search = normalizeString(search)

        _, err = s.domainRepo.GetByID(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewDomainNotFoundError(domainID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get domain: %v", err)
                return nil, err</span>
        }

        <span class="cov8" title="1">nodes, totalCount, err := s.nodeRepo.ListByDomain(ctx, domainID, page, size, search)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to list nodes: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">nodeList := make([]models.Node, len(nodes))
        for i, node := range nodes </span><span class="cov8" title="1">{
                nodeList[i] = *node
        }</span>

        <span class="cov8" title="1">totalPages := (totalCount + size - 1) / size

        return &amp;models.NodeListResponse{
                Nodes:      nodeList,
                TotalCount: totalCount,
                Page:       page,
                Size:       size,
                TotalPages: totalPages,
        }, nil</span>
}

func (s *nodeService) UpdateNode(ctx context.Context, id int, req *models.UpdateNodeRequest) (*models.Node, error) <span class="cov8" title="1">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req.Title = normalizeString(req.Title)
        req.Description = normalizeString(req.Description)

        if err := validateTitle(req.Title); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := validateDescription(req.Description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">node, err := s.nodeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return nil, err</span>
        }

        <span class="cov8" title="1">node.Title = req.Title
        node.Description = req.Description
        node.UpdatedAt = time.Now()

        if err := s.nodeRepo.Update(ctx, node); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to update node: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Updated node: %s (ID: %d)", node.Content, node.ID)
        return node, nil</span>
}

func (s *nodeService) DeleteNode(ctx context.Context, id int) error <span class="cov8" title="1">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err := s.nodeRepo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewNodeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to delete node: %v", err)
                return err</span>
        }

        <span class="cov8" title="1">s.logger.Printf("Deleted node with ID: %d", id)
        return nil</span>
}

func (s *nodeService) FindNodeByURL(ctx context.Context, domainID int, req *models.FindNodeByURLRequest) (*models.Node, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(domainID, "domainID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.URL = normalizeString(req.URL)
        if err := validateURL(req.URL); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GetNodeByDomainAndURL(ctx, domainID, req.URL)</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "time"

        "url-db/internal/models"
)

type NodeAttributeRepository interface {
        Create(ctx context.Context, nodeAttribute *models.NodeAttribute) error
        GetByID(ctx context.Context, id int) (*models.NodeAttribute, error)
        GetByNodeAndAttribute(ctx context.Context, nodeID, attributeID int) (*models.NodeAttribute, error)
        ListByNode(ctx context.Context, nodeID int) ([]*models.NodeAttribute, error)
        Update(ctx context.Context, nodeAttribute *models.NodeAttribute) error
        Delete(ctx context.Context, id int) error
        ExistsByNodeAndAttribute(ctx context.Context, nodeID, attributeID int) (bool, error)
}

type nodeAttributeService struct {
        nodeAttributeRepo NodeAttributeRepository
        nodeRepo          NodeRepository
        attributeRepo     AttributeRepository
        logger            *log.Logger
}

func NewNodeAttributeService(nodeAttributeRepo NodeAttributeRepository, nodeRepo NodeRepository, attributeRepo AttributeRepository, logger *log.Logger) NodeAttributeService <span class="cov0" title="0">{
        return &amp;nodeAttributeService{
                nodeAttributeRepo: nodeAttributeRepo,
                nodeRepo:          nodeRepo,
                attributeRepo:     attributeRepo,
                logger:            logger,
        }
}</span>

func (s *nodeAttributeService) CreateNodeAttribute(ctx context.Context, nodeID int, req *models.CreateNodeAttributeRequest) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(nodeID, "nodeID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validatePositiveInteger(req.AttributeID, "attributeID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Value = normalizeString(req.Value)

        node, err := s.nodeRepo.GetByID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeNotFoundError(nodeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, req.AttributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewAttributeNotFoundError(req.AttributeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">if node.DomainID != attribute.DomainID </span><span class="cov0" title="0">{
                return nil, NewBusinessLogicError("node and attribute must belong to the same domain")
        }</span>

        <span class="cov0" title="0">if err := validateAttributeValue(string(attribute.Type), req.Value); err != nil </span><span class="cov0" title="0">{
                return nil, NewAttributeValueInvalidError(req.AttributeID, req.Value, err.Error())
        }</span>

        <span class="cov0" title="0">exists, err := s.nodeAttributeRepo.ExistsByNodeAndAttribute(ctx, nodeID, req.AttributeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to check node attribute existence: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, NewBusinessLogicError("node attribute already exists")
        }</span>

        <span class="cov0" title="0">nodeAttribute := &amp;models.NodeAttribute{
                NodeID:      nodeID,
                AttributeID: req.AttributeID,
                Value:       req.Value,
                OrderIndex:  req.OrderIndex,
                CreatedAt:   time.Now(),
        }

        if err := s.nodeAttributeRepo.Create(ctx, nodeAttribute); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to create node attribute: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Created node attribute: node %d, attribute %d (ID: %d)", nodeID, req.AttributeID, nodeAttribute.ID)
        return nodeAttribute, nil</span>
}

func (s *nodeAttributeService) GetNodeAttribute(ctx context.Context, id int) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeAttribute, err := s.nodeAttributeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return nodeAttribute, nil</span>
}

func (s *nodeAttributeService) ListNodeAttributesByNode(ctx context.Context, nodeID int) (*models.NodeAttributeListResponse, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(nodeID, "nodeID"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err := s.nodeRepo.GetByID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeNotFoundError(nodeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">nodeAttributes, err := s.nodeAttributeRepo.ListByNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to list node attributes: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeAttributeList := make([]models.NodeAttributeWithInfo, len(nodeAttributes))
        for i, nodeAttribute := range nodeAttributes </span><span class="cov0" title="0">{
                // Convert NodeAttribute to NodeAttributeWithInfo
                // This is a placeholder - in reality you'd need to fetch attribute details
                nodeAttributeList[i] = models.NodeAttributeWithInfo{
                        ID:          nodeAttribute.ID,
                        NodeID:      nodeAttribute.NodeID,
                        AttributeID: nodeAttribute.AttributeID,
                        Name:        "unknown", // Would need to fetch from attribute table
                        Type:        "string",  // Would need to fetch from attribute table
                        Value:       nodeAttribute.Value,
                        OrderIndex:  nodeAttribute.OrderIndex,
                        CreatedAt:   nodeAttribute.CreatedAt,
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.NodeAttributeListResponse{
                NodeAttributes: nodeAttributeList,
                Attributes:     nodeAttributeList, // For backward compatibility
        }, nil</span>
}

func (s *nodeAttributeService) UpdateNodeAttribute(ctx context.Context, id int, req *models.UpdateNodeAttributeRequest) (*models.NodeAttribute, error) <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Value = normalizeString(req.Value)

        nodeAttribute, err := s.nodeAttributeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewNodeAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, nodeAttribute.AttributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, NewAttributeNotFoundError(nodeAttribute.AttributeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">if err := validateAttributeValue(string(attribute.Type), req.Value); err != nil </span><span class="cov0" title="0">{
                return nil, NewAttributeValueInvalidError(nodeAttribute.AttributeID, req.Value, err.Error())
        }</span>

        <span class="cov0" title="0">nodeAttribute.Value = req.Value
        nodeAttribute.OrderIndex = req.OrderIndex

        if err := s.nodeAttributeRepo.Update(ctx, nodeAttribute); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to update node attribute: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Updated node attribute: node %d, attribute %d (ID: %d)", nodeAttribute.NodeID, nodeAttribute.AttributeID, nodeAttribute.ID)
        return nodeAttribute, nil</span>
}

func (s *nodeAttributeService) DeleteNodeAttribute(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(id, "id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err := s.nodeAttributeRepo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewNodeAttributeNotFoundError(id)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to delete node attribute: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">s.logger.Printf("Deleted node attribute with ID: %d", id)
        return nil</span>
}

func (s *nodeAttributeService) ValidateNodeAttributeValue(ctx context.Context, nodeID, attributeID int, value string) error <span class="cov0" title="0">{
        if err := validatePositiveInteger(nodeID, "nodeID"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validatePositiveInteger(attributeID, "attributeID"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">value = normalizeString(value)

        node, err := s.nodeRepo.GetByID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewNodeNotFoundError(nodeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get node: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">attribute, err := s.attributeRepo.GetByID(ctx, attributeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return NewAttributeNotFoundError(attributeID)
                }</span>
                <span class="cov0" title="0">s.logger.Printf("Failed to get attribute: %v", err)
                return err</span>
        }

        <span class="cov0" title="0">if node.DomainID != attribute.DomainID </span><span class="cov0" title="0">{
                return NewBusinessLogicError("node and attribute must belong to the same domain")
        }</span>

        <span class="cov0" title="0">if err := validateAttributeValue(string(attribute.Type), value); err != nil </span><span class="cov0" title="0">{
                return NewAttributeValueInvalidError(attributeID, value, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package services

import (
        "context"
        "fmt"
)

// NodeCountService provides methods to count nodes by domain
type NodeCountService interface {
        GetNodeCountByDomain(ctx context.Context, domainID int) (int, error)
}

// NodeCountRepository interface for data access
type NodeCountRepository interface {
        CountNodesByDomain(ctx context.Context, domainID int) (int, error)
}

// nodeCountService implements NodeCountService
type nodeCountService struct {
        nodeRepo NodeCountRepository
}

// NewNodeCountService creates a new node count service
func NewNodeCountService(nodeRepo NodeCountRepository) NodeCountService <span class="cov0" title="0">{
        return &amp;nodeCountService{
                nodeRepo: nodeRepo,
        }
}</span>

// GetNodeCountByDomain returns the count of nodes for a specific domain
func (s *nodeCountService) GetNodeCountByDomain(ctx context.Context, domainID int) (int, error) <span class="cov0" title="0">{
        if domainID &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("domain ID must be positive")
        }</span>

        <span class="cov0" title="0">count, err := s.nodeRepo.CountNodesByDomain(ctx, domainID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count nodes by domain: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">package services

import (
        "fmt"

        "url-db/internal/models"
        "url-db/internal/repositories"
)

// SubscriptionService handles business logic for subscriptions
type SubscriptionService struct {
        subscriptionRepo *repositories.SubscriptionRepository
        nodeRepo         repositories.NodeRepository
        eventRepo        *repositories.EventRepository
}

// NewSubscriptionService creates a new subscription service
func NewSubscriptionService(
        subscriptionRepo *repositories.SubscriptionRepository,
        nodeRepo repositories.NodeRepository,
        eventRepo *repositories.EventRepository,
) *SubscriptionService <span class="cov0" title="0">{
        return &amp;SubscriptionService{
                subscriptionRepo: subscriptionRepo,
                nodeRepo:         nodeRepo,
                eventRepo:        eventRepo,
        }
}</span>

// CreateSubscription creates a new subscription
func (s *SubscriptionService) CreateSubscription(nodeID int64, req *models.CreateNodeSubscriptionRequest) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        // Create subscription
        <span class="cov0" title="0">subscription := &amp;models.NodeSubscription{
                SubscriberService:  req.SubscriberService,
                SubscriberEndpoint: req.SubscriberEndpoint,
                SubscribedNodeID:   nodeID,
                EventTypes:         models.EventTypeList(req.EventTypes),
                FilterConditions:   req.FilterConditions,
                IsActive:           true,
        }

        err = s.subscriptionRepo.Create(subscription)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return subscription, nil</span>
}

// GetSubscription retrieves a subscription by ID
func (s *SubscriptionService) GetSubscription(id int64) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        subscription, err := s.subscriptionRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subscription: %w", err)
        }</span>
        <span class="cov0" title="0">if subscription == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("subscription not found")
        }</span>

        <span class="cov0" title="0">return subscription, nil</span>
}

// UpdateSubscription updates a subscription
func (s *SubscriptionService) UpdateSubscription(id int64, req *models.UpdateNodeSubscriptionRequest) (*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Verify subscription exists
        subscription, err := s.subscriptionRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subscription: %w", err)
        }</span>
        <span class="cov0" title="0">if subscription == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("subscription not found")
        }</span>

        // Build updates
        <span class="cov0" title="0">updates := make(map[string]interface{})

        if req.SubscriberEndpoint != nil </span><span class="cov0" title="0">{
                updates["subscriber_endpoint"] = req.SubscriberEndpoint
        }</span>

        <span class="cov0" title="0">if len(req.EventTypes) &gt; 0 </span><span class="cov0" title="0">{
                updates["event_types"] = models.EventTypeList(req.EventTypes)
        }</span>

        <span class="cov0" title="0">if req.FilterConditions != nil </span><span class="cov0" title="0">{
                updates["filter_conditions"] = req.FilterConditions
        }</span>

        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                updates["is_active"] = *req.IsActive
        }</span>

        // Update subscription
        <span class="cov0" title="0">err = s.subscriptionRepo.Update(id, updates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update subscription: %w", err)
        }</span>

        // Get updated subscription
        <span class="cov0" title="0">return s.subscriptionRepo.GetByID(id)</span>
}

// DeleteSubscription deletes a subscription
func (s *SubscriptionService) DeleteSubscription(id int64) error <span class="cov0" title="0">{
        err := s.subscriptionRepo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetNodeSubscriptions retrieves all subscriptions for a node
func (s *SubscriptionService) GetNodeSubscriptions(nodeID int64) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        // Verify node exists
        node, err := s.nodeRepo.GetByID(int(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node not found")
        }</span>

        <span class="cov0" title="0">return s.subscriptionRepo.GetByNode(nodeID)</span>
}

// GetServiceSubscriptions retrieves all subscriptions for a service
func (s *SubscriptionService) GetServiceSubscriptions(service string) ([]*models.NodeSubscription, error) <span class="cov0" title="0">{
        return s.subscriptionRepo.GetByService(service)
}</span>

// GetAllSubscriptions retrieves all subscriptions with pagination
func (s *SubscriptionService) GetAllSubscriptions(page, pageSize int) ([]*models.NodeSubscription, int, error) <span class="cov0" title="0">{
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize
        return s.subscriptionRepo.GetAll(offset, pageSize)</span>
}

// TriggerNodeEvent creates an event and notifies relevant subscribers
func (s *SubscriptionService) TriggerNodeEvent(nodeID int64, eventType string, eventData *models.EventData) error <span class="cov0" title="0">{
        // Create event
        event := &amp;models.NodeEvent{
                NodeID:    nodeID,
                EventType: eventType,
                EventData: eventData,
        }

        err := s.eventRepo.Create(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create event: %w", err)
        }</span>

        // Get active subscriptions for this node
        <span class="cov0" title="0">subscriptions, err := s.subscriptionRepo.GetByNode(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get subscriptions: %w", err)
        }</span>

        // Filter subscriptions by event type
        <span class="cov0" title="0">for _, sub := range subscriptions </span><span class="cov0" title="0">{
                shouldNotify := false
                for _, et := range sub.EventTypes </span><span class="cov0" title="0">{
                        if et == eventType </span><span class="cov0" title="0">{
                                shouldNotify = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if shouldNotify </span><span class="cov0" title="0">{
                        // Webhook notification would be implemented here in production
                        // For now, we just acknowledge that notification should be sent
                        _ = sub.SubscriberService // Acknowledge subscription service
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">package services

import (
        "context"
        "database/sql"
        "log"
        "os"
        "testing"
        "time"

        "url-db/internal/models"
)

type MockDomainRepository struct {
        domains     map[int]*models.Domain
        nextID      int
        nameToID    map[string]int
        shouldError bool
}

func NewMockDomainRepository() *MockDomainRepository <span class="cov8" title="1">{
        return &amp;MockDomainRepository{
                domains:  make(map[int]*models.Domain),
                nextID:   1,
                nameToID: make(map[string]int),
        }
}</span>

func (m *MockDomainRepository) SetShouldError(shouldError bool) <span class="cov8" title="1">{
        m.shouldError = shouldError
}</span>

func (m *MockDomainRepository) Create(ctx context.Context, domain *models.Domain) error <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">domain.ID = m.nextID
        m.nextID++
        domain.CreatedAt = time.Now()
        domain.UpdatedAt = time.Now()

        m.domains[domain.ID] = domain
        m.nameToID[domain.Name] = domain.ID

        return nil</span>
}

func (m *MockDomainRepository) GetByID(ctx context.Context, id int) (*models.Domain, error) <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">domain, exists := m.domains[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, sql.ErrNoRows
        }</span>

        <span class="cov8" title="1">return domain, nil</span>
}

func (m *MockDomainRepository) GetByName(ctx context.Context, name string) (*models.Domain, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">id, exists := m.nameToID[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return m.domains[id], nil</span>
}

func (m *MockDomainRepository) List(ctx context.Context, page, size int) ([]*models.Domain, int, error) <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, 0, sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">var domains []*models.Domain
        for _, domain := range m.domains </span><span class="cov8" title="1">{
                domains = append(domains, domain)
        }</span>

        <span class="cov8" title="1">offset := (page - 1) * size
        totalCount := len(domains)

        if offset &gt;= totalCount </span><span class="cov0" title="0">{
                return []*models.Domain{}, totalCount, nil
        }</span>

        <span class="cov8" title="1">end := offset + size
        if end &gt; totalCount </span><span class="cov8" title="1">{
                end = totalCount
        }</span>

        <span class="cov8" title="1">return domains[offset:end], totalCount, nil</span>
}

func (m *MockDomainRepository) Update(ctx context.Context, domain *models.Domain) error <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">_, exists := m.domains[domain.ID]
        if !exists </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov8" title="1">domain.UpdatedAt = time.Now()
        m.domains[domain.ID] = domain

        return nil</span>
}

func (m *MockDomainRepository) Delete(ctx context.Context, id int) error <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">domain, exists := m.domains[id]
        if !exists </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov8" title="1">delete(m.domains, id)
        delete(m.nameToID, domain.Name)

        return nil</span>
}

func (m *MockDomainRepository) ExistsByName(ctx context.Context, name string) (bool, error) <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return false, sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">_, exists := m.nameToID[name]
        return exists, nil</span>
}

type MockNodeRepository struct {
        nodes       map[int]*models.Node
        nextID      int
        shouldError bool
}

func NewMockNodeRepository() *MockNodeRepository <span class="cov8" title="1">{
        return &amp;MockNodeRepository{
                nodes:  make(map[int]*models.Node),
                nextID: 1,
        }
}</span>

func (m *MockNodeRepository) SetShouldError(shouldError bool) <span class="cov0" title="0">{
        m.shouldError = shouldError
}</span>

func (m *MockNodeRepository) Create(ctx context.Context, node *models.Node) error <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">node.ID = m.nextID
        m.nextID++
        node.CreatedAt = time.Now()
        node.UpdatedAt = time.Now()

        m.nodes[node.ID] = node

        return nil</span>
}

func (m *MockNodeRepository) GetByID(ctx context.Context, id int) (*models.Node, error) <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">node, exists := m.nodes[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, sql.ErrNoRows
        }</span>

        <span class="cov8" title="1">return node, nil</span>
}

func (m *MockNodeRepository) GetByDomainAndContent(ctx context.Context, domainID int, content string) (*models.Node, error) <span class="cov0" title="0">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, sql.ErrConnDone
        }</span>

        <span class="cov0" title="0">for _, node := range m.nodes </span><span class="cov0" title="0">{
                if node.DomainID == domainID &amp;&amp; node.Content == content </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, sql.ErrNoRows</span>
}

func (m *MockNodeRepository) ListByDomain(ctx context.Context, domainID int, page, size int, search string) ([]*models.Node, int, error) <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return nil, 0, sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">var nodes []*models.Node
        for _, node := range m.nodes </span><span class="cov8" title="1">{
                if node.DomainID == domainID </span><span class="cov8" title="1">{
                        nodes = append(nodes, node)
                }</span>
        }

        <span class="cov8" title="1">offset := (page - 1) * size
        totalCount := len(nodes)

        if offset &gt;= totalCount </span><span class="cov0" title="0">{
                return []*models.Node{}, totalCount, nil
        }</span>

        <span class="cov8" title="1">end := offset + size
        if end &gt; totalCount </span><span class="cov8" title="1">{
                end = totalCount
        }</span>

        <span class="cov8" title="1">return nodes[offset:end], totalCount, nil</span>
}

func (m *MockNodeRepository) Update(ctx context.Context, node *models.Node) error <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">_, exists := m.nodes[node.ID]
        if !exists </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov8" title="1">node.UpdatedAt = time.Now()
        m.nodes[node.ID] = node

        return nil</span>
}

func (m *MockNodeRepository) Delete(ctx context.Context, id int) error <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">_, exists := m.nodes[id]
        if !exists </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov8" title="1">delete(m.nodes, id)

        return nil</span>
}

func (m *MockNodeRepository) ExistsByDomainAndContent(ctx context.Context, domainID int, content string) (bool, error) <span class="cov8" title="1">{
        if m.shouldError </span><span class="cov0" title="0">{
                return false, sql.ErrConnDone
        }</span>

        <span class="cov8" title="1">for _, node := range m.nodes </span><span class="cov0" title="0">{
                if node.DomainID == domainID &amp;&amp; node.Content == content </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

func CreateTestDomainService(t *testing.T) (DomainService, *MockDomainRepository) <span class="cov8" title="1">{
        mockRepo := NewMockDomainRepository()
        logger := log.New(os.Stdout, "[TEST] ", log.LstdFlags)
        service := NewDomainService(mockRepo, logger)

        return service, mockRepo
}</span>

func CreateTestNodeService(t *testing.T) (NodeService, *MockNodeRepository, *MockDomainRepository) <span class="cov8" title="1">{
        mockNodeRepo := NewMockNodeRepository()
        mockDomainRepo := NewMockDomainRepository()
        logger := log.New(os.Stdout, "[TEST] ", log.LstdFlags)
        service := NewNodeService(mockNodeRepo, mockDomainRepo, logger)

        return service, mockNodeRepo, mockDomainRepo
}</span>

func CreateTestCompositeKeyService(t *testing.T) CompositeKeyService <span class="cov0" title="0">{
        return NewCompositeKeyService("test-tool")
}</span>

func CreateTestDomain(name, description string) *models.Domain <span class="cov8" title="1">{
        return &amp;models.Domain{
                Name:        name,
                Description: description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }
}</span>

func CreateTestNode(domainID int, url, title, description string) *models.Node <span class="cov8" title="1">{
        return &amp;models.Node{
                DomainID:    domainID,
                Content:     url,
                Title:       title,
                Description: description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }
}</span>

func CreateTestAttribute(domainID int, name, attributeType, description string) *models.Attribute <span class="cov0" title="0">{
        return &amp;models.Attribute{
                DomainID:    domainID,
                Name:        name,
                Type:        models.AttributeType(attributeType),
                Description: description,
                CreatedAt:   time.Now(),
        }
}</span>

func CreateTestContext() context.Context <span class="cov8" title="1">{
        return context.Background()
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">package services

import (
        "regexp"
        "strconv"
        "strings"
)

var (
        domainNameRegex = regexp.MustCompile(`^[a-zA-Z0-9-]+$`)
        urlRegex        = regexp.MustCompile(`^https?://[^\s/$.?#].[^\s]*$`)
        emailRegex      = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
)

func validateDomainName(name string) error <span class="cov8" title="1">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("name", "domain name is required")
        }</span>
        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov0" title="0">{
                return NewValidationError("name", "domain name cannot exceed 255 characters")
        }</span>
        <span class="cov8" title="1">if !domainNameRegex.MatchString(name) </span><span class="cov0" title="0">{
                return NewValidationError("name", "domain name can only contain alphanumeric characters and hyphens")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateDescription(description string) error <span class="cov8" title="1">{
        if len(description) &gt; 1000 </span><span class="cov0" title="0">{
                return NewValidationError("description", "description cannot exceed 1000 characters")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateURL(url string) error <span class="cov8" title="1">{
        if len(url) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("url", "URL is required")
        }</span>
        <span class="cov8" title="1">if len(url) &gt; 2000 </span><span class="cov0" title="0">{
                return NewValidationError("url", "URL cannot exceed 2000 characters")
        }</span>
        <span class="cov8" title="1">if !urlRegex.MatchString(url) </span><span class="cov0" title="0">{
                return NewValidationError("url", "invalid URL format")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateTitle(title string) error <span class="cov8" title="1">{
        if len(title) &gt; 500 </span><span class="cov0" title="0">{
                return NewValidationError("title", "title cannot exceed 500 characters")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateAttributeName(name string) error <span class="cov0" title="0">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("name", "attribute name is required")
        }</span>
        <span class="cov0" title="0">if len(name) &gt; 255 </span><span class="cov0" title="0">{
                return NewValidationError("name", "attribute name cannot exceed 255 characters")
        }</span>
        <span class="cov0" title="0">if !regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).MatchString(name) </span><span class="cov0" title="0">{
                return NewValidationError("name", "attribute name can only contain alphanumeric characters, underscores, and hyphens")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateAttributeType(attributeType string) error <span class="cov0" title="0">{
        validTypes := []string{"tag", "ordered_tag", "number", "string", "markdown", "image"}
        for _, validType := range validTypes </span><span class="cov0" title="0">{
                if attributeType == validType </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return NewValidationError("type", "invalid attribute type")</span>
}

func validateAttributeValue(attributeType, value string) error <span class="cov0" title="0">{
        if len(value) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("value", "attribute value is required")
        }</span>

        <span class="cov0" title="0">switch attributeType </span>{
        case "tag", "ordered_tag":<span class="cov0" title="0">
                if len(value) &gt; 100 </span><span class="cov0" title="0">{
                        return NewValidationError("value", "tag value cannot exceed 100 characters")
                }</span>
                <span class="cov0" title="0">if !regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).MatchString(value) </span><span class="cov0" title="0">{
                        return NewValidationError("value", "tag value can only contain alphanumeric characters, underscores, and hyphens")
                }</span>
        case "number":<span class="cov0" title="0">
                if _, err := strconv.ParseFloat(value, 64); err != nil </span><span class="cov0" title="0">{
                        return NewValidationError("value", "number value must be a valid number")
                }</span>
        case "string":<span class="cov0" title="0">
                if len(value) &gt; 1000 </span><span class="cov0" title="0">{
                        return NewValidationError("value", "string value cannot exceed 1000 characters")
                }</span>
        case "markdown":<span class="cov0" title="0">
                if len(value) &gt; 10000 </span><span class="cov0" title="0">{
                        return NewValidationError("value", "markdown value cannot exceed 10000 characters")
                }</span>
        case "image":<span class="cov0" title="0">
                if len(value) &gt; 500 </span><span class="cov0" title="0">{
                        return NewValidationError("value", "image URL cannot exceed 500 characters")
                }</span>
                <span class="cov0" title="0">if !urlRegex.MatchString(value) </span><span class="cov0" title="0">{
                        return NewValidationError("value", "image value must be a valid URL")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func validatePositiveInteger(value int, fieldName string) error <span class="cov8" title="1">{
        if value &lt;= 0 </span><span class="cov0" title="0">{
                return NewValidationError(fieldName, fieldName+" must be a positive integer")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validatePaginationParams(page, size int) (int, int, error) <span class="cov8" title="1">{
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if size &lt; 1 </span><span class="cov0" title="0">{
                size = 20
        }</span>
        <span class="cov8" title="1">if size &gt; 100 </span><span class="cov0" title="0">{
                size = 100
        }</span>
        <span class="cov8" title="1">return page, size, nil</span>
}

func normalizeString(s string) string <span class="cov8" title="1">{
        return strings.TrimSpace(s)
}</span>

func generateTitleFromURL(url string) string <span class="cov0" title="0">{
        parts := strings.Split(url, "/")
        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                domain := parts[2]
                if len(parts) &gt; 3 </span><span class="cov0" title="0">{
                        path := parts[len(parts)-1]
                        if path != "" </span><span class="cov0" title="0">{
                                return strings.Title(strings.ReplaceAll(path, "-", " "))
                        }</span>
                }
                <span class="cov0" title="0">return strings.Title(domain)</span>
        }
        <span class="cov0" title="0">return "Untitled"</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">package compositekey

import (
        "strconv"
        "strings"
)

// CompositeKey 는 합성키 구조를 나타냅니다.
type CompositeKey struct {
        ToolName   string `json:"tool_name"`
        DomainName string `json:"domain_name"`
        ID         int    `json:"id"`
}

// String 은 CompositeKey를 문자열로 변환합니다.
func (ck CompositeKey) String() string <span class="cov8" title="1">{
        return strings.Join([]string{ck.ToolName, ck.DomainName, strconv.Itoa(ck.ID)}, ":")
}</span>

// Create 는 주어진 구성 요소로 합성키를 생성합니다.
func Create(toolName, domainName string, id int) CompositeKey <span class="cov8" title="1">{
        return CompositeKey{
                ToolName:   toolName,
                DomainName: domainName,
                ID:         id,
        }
}</span>

// Parse 는 합성키 문자열을 파싱하여 CompositeKey 구조체로 변환합니다.
func Parse(compositeKey string) (CompositeKey, error) <span class="cov8" title="1">{
        parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return CompositeKey{}, NewInvalidFormatError("합성키는 정확히 3개의 구성 요소를 가져야 합니다")
        }</span>

        <span class="cov8" title="1">toolName := parts[0]
        domainName := parts[1]
        idStr := parts[2]

        // ID를 정수로 변환
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov8" title="1">{
                return CompositeKey{}, NewInvalidIDError("ID는 유효한 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov8" title="1">{
                return CompositeKey{}, NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return CompositeKey{
                ToolName:   toolName,
                DomainName: domainName,
                ID:         id,
        }, nil</span>
}

// IsValid 는 합성키의 유효성을 검사합니다.
func IsValid(compositeKey string) bool <span class="cov8" title="1">{
        _, err := Parse(compositeKey)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file161" style="display: none">package compositekey

import "fmt"

// 에러 코드 정의
const (
        ErrInvalidFormat     = "COMPOSITE_KEY_INVALID_FORMAT"
        ErrInvalidToolName   = "COMPOSITE_KEY_INVALID_TOOL_NAME"
        ErrInvalidDomainName = "COMPOSITE_KEY_INVALID_DOMAIN_NAME"
        ErrInvalidID         = "COMPOSITE_KEY_INVALID_ID"
        ErrTooLong           = "COMPOSITE_KEY_TOO_LONG"
)

// CompositeKeyError 는 합성키 관련 에러를 나타냅니다.
type CompositeKeyError struct {
        Code    string
        Message string
}

func (e CompositeKeyError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s: %s", e.Code, e.Message)
}</span>

// 에러 생성 함수들
func NewInvalidFormatError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrInvalidFormat,
                Message: message,
        }
}</span>

func NewInvalidToolNameError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrInvalidToolName,
                Message: message,
        }
}</span>

func NewInvalidDomainNameError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrInvalidDomainName,
                Message: message,
        }
}</span>

func NewInvalidIDError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrInvalidID,
                Message: message,
        }
}</span>

func NewTooLongError(message string) error <span class="cov8" title="1">{
        return CompositeKeyError{
                Code:    ErrTooLong,
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file162" style="display: none">package compositekey

import (
        "regexp"
        "strings"
)

// 정규화 규칙에 따른 상수들
const (
        MaxToolNameLength   = 50
        MaxDomainNameLength = 50
        MaxIDLength         = 20
)

// 특수문자를 하이픈으로 변환하는 정규표현식
var (
        // 영문자, 숫자, 하이픈, 언더스코어가 아닌 문자를 매칭
        invalidCharsRegex = regexp.MustCompile(`[^a-zA-Z0-9\-_]`)
        // 연속된 하이픈이나 언더스코어를 매칭
        multipleDelimiterRegex = regexp.MustCompile(`[-_]+`)
)

// NormalizeToolName 은 도구명을 정규화합니다.
func NormalizeToolName(toolName string) (string, error) <span class="cov8" title="1">{
        normalized := normalizeString(toolName)

        if len(normalized) == 0 </span><span class="cov8" title="1">{
                return "", NewInvalidToolNameError("도구명이 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(normalized) &gt; MaxToolNameLength </span><span class="cov8" title="1">{
                return "", NewTooLongError("도구명이 너무 깁니다")
        }</span>

        <span class="cov8" title="1">return normalized, nil</span>
}

// NormalizeDomainName 은 도메인명을 정규화합니다.
func NormalizeDomainName(domainName string) (string, error) <span class="cov8" title="1">{
        normalized := normalizeString(domainName)

        if len(normalized) == 0 </span><span class="cov8" title="1">{
                return "", NewInvalidDomainNameError("도메인명이 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(normalized) &gt; MaxDomainNameLength </span><span class="cov8" title="1">{
                return "", NewTooLongError("도메인명이 너무 깁니다")
        }</span>

        <span class="cov8" title="1">return normalized, nil</span>
}

// normalizeString 은 문자열을 정규화합니다.
func normalizeString(input string) string <span class="cov8" title="1">{
        if input == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // 1. 앞뒤 공백 제거
        <span class="cov8" title="1">normalized := strings.TrimSpace(input)

        // 2. 소문자로 변환
        normalized = strings.ToLower(normalized)

        // 3. 특수문자를 하이픈으로 변환
        normalized = invalidCharsRegex.ReplaceAllString(normalized, "-")

        // 4. 연속된 구분자를 단일 하이픈으로 변환
        normalized = multipleDelimiterRegex.ReplaceAllString(normalized, "-")

        // 5. 앞뒤 하이픈 제거
        normalized = strings.Trim(normalized, "-")

        return normalized</span>
}

// CreateNormalized 는 정규화된 구성 요소로 합성키를 생성합니다.
func CreateNormalized(toolName, domainName string, id int) (CompositeKey, error) <span class="cov8" title="1">{
        normalizedToolName, err := NormalizeToolName(toolName)
        if err != nil </span><span class="cov8" title="1">{
                return CompositeKey{}, err
        }</span>

        <span class="cov8" title="1">normalizedDomainName, err := NormalizeDomainName(domainName)
        if err != nil </span><span class="cov8" title="1">{
                return CompositeKey{}, err
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov8" title="1">{
                return CompositeKey{}, NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return CompositeKey{
                ToolName:   normalizedToolName,
                DomainName: normalizedDomainName,
                ID:         id,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">package compositekey

import "strings"

// Service 는 합성키 서비스를 나타냅니다.
type Service struct {
        defaultToolName string
}

// NewService 는 새로운 합성키 서비스를 생성합니다.
func NewService(defaultToolName string) *Service <span class="cov8" title="1">{
        return &amp;Service{
                defaultToolName: defaultToolName,
        }
}</span>

// Create 는 주어진 구성 요소로 합성키를 생성합니다.
func (s *Service) Create(domainName string, id int) (string, error) <span class="cov8" title="1">{
        compositeKey, err := CreateNormalized(s.defaultToolName, domainName, id)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return compositeKey.String(), nil</span>
}

// CreateWithTool 은 도구명을 포함하여 합성키를 생성합니다.
func (s *Service) CreateWithTool(toolName, domainName string, id int) (string, error) <span class="cov8" title="1">{
        compositeKey, err := CreateNormalized(toolName, domainName, id)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return compositeKey.String(), nil</span>
}

// Parse 는 합성키 문자열을 파싱하여 CompositeKey 구조체로 변환합니다.
func (s *Service) Parse(compositeKey string) (CompositeKey, error) <span class="cov8" title="1">{
        // 먼저 검증
        if err := ValidateCompositeKey(compositeKey); err != nil </span><span class="cov8" title="1">{
                return CompositeKey{}, err
        }</span>

        // 파싱
        <span class="cov8" title="1">return Parse(compositeKey)</span>
}

// Validate 는 합성키의 유효성을 검증합니다.
func (s *Service) Validate(compositeKey string) bool <span class="cov8" title="1">{
        return ValidateCompositeKey(compositeKey) == nil
}</span>

// ParseComponents 는 합성키를 구성 요소로 분해하여 반환합니다.
func (s *Service) ParseComponents(compositeKey string) (toolName, domainName string, id int, err error) <span class="cov8" title="1">{
        ck, err := s.Parse(compositeKey)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", 0, err
        }</span>

        <span class="cov8" title="1">return ck.ToolName, ck.DomainName, ck.ID, nil</span>
}

// GetToolName 은 합성키에서 도구명을 추출합니다.
func (s *Service) GetToolName(compositeKey string) (string, error) <span class="cov8" title="1">{
        parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return "", NewInvalidFormatError("합성키 형식이 올바르지 않습니다")
        }</span>

        <span class="cov8" title="1">return parts[0], nil</span>
}

// GetDomainName 은 합성키에서 도메인명을 추출합니다.
func (s *Service) GetDomainName(compositeKey string) (string, error) <span class="cov8" title="1">{
        parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return "", NewInvalidFormatError("합성키 형식이 올바르지 않습니다")
        }</span>

        <span class="cov8" title="1">return parts[1], nil</span>
}

// GetID 는 합성키에서 ID를 추출합니다.
func (s *Service) GetID(compositeKey string) (int, error) <span class="cov8" title="1">{
        ck, err := s.Parse(compositeKey)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return ck.ID, nil</span>
}

// IsValidFormat 은 합성키의 기본 형식만 검증합니다.
func (s *Service) IsValidFormat(compositeKey string) bool <span class="cov8" title="1">{
        return ValidateFormat(compositeKey) == nil
}</span>

// NormalizeComponents 는 구성 요소를 정규화합니다.
func (s *Service) NormalizeComponents(toolName, domainName string) (string, string, error) <span class="cov8" title="1">{
        normalizedToolName, err := NormalizeToolName(toolName)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">normalizedDomainName, err := NormalizeDomainName(domainName)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return normalizedToolName, normalizedDomainName, nil</span>
}

// ValidateComponents 는 구성 요소들을 개별적으로 검증합니다.
func (s *Service) ValidateComponents(toolName, domainName string, id int) error <span class="cov8" title="1">{
        if err := ValidateToolName(toolName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := ValidateDomainName(domainName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">package compositekey

import (
        "regexp"
        "strconv"
        "strings"
)

// 검증에 사용되는 정규표현식
var (
        // 유효한 문자 (영문자, 숫자, 하이픈, 언더스코어)
        validCharsRegex = regexp.MustCompile(`^[a-zA-Z0-9\-_]+$`)
)

// ValidateFormat 은 합성키의 기본 형식을 검증합니다.
func ValidateFormat(compositeKey string) error <span class="cov8" title="1">{
        if compositeKey == "" </span><span class="cov8" title="1">{
                return NewInvalidFormatError("합성키가 비어있습니다")
        }</span>

        <span class="cov8" title="1">parts := strings.Split(compositeKey, ":")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return NewInvalidFormatError("합성키는 정확히 3개의 구성 요소를 가져야 합니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateToolName 은 도구명을 검증합니다.
func ValidateToolName(toolName string) error <span class="cov8" title="1">{
        if toolName == "" </span><span class="cov8" title="1">{
                return NewInvalidToolNameError("도구명이 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(toolName) &gt; MaxToolNameLength </span><span class="cov8" title="1">{
                return NewTooLongError("도구명이 너무 깁니다")
        }</span>

        <span class="cov8" title="1">if !validCharsRegex.MatchString(toolName) </span><span class="cov8" title="1">{
                return NewInvalidToolNameError("도구명에 유효하지 않은 문자가 포함되어 있습니다")
        }</span>

        // 하이픈으로 시작하거나 끝나면 안됨
        <span class="cov8" title="1">if strings.HasPrefix(toolName, "-") || strings.HasSuffix(toolName, "-") </span><span class="cov8" title="1">{
                return NewInvalidToolNameError("도구명은 하이픈으로 시작하거나 끝날 수 없습니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateDomainName 은 도메인명을 검증합니다.
func ValidateDomainName(domainName string) error <span class="cov8" title="1">{
        if domainName == "" </span><span class="cov8" title="1">{
                return NewInvalidDomainNameError("도메인명이 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(domainName) &gt; MaxDomainNameLength </span><span class="cov8" title="1">{
                return NewTooLongError("도메인명이 너무 깁니다")
        }</span>

        <span class="cov8" title="1">if !validCharsRegex.MatchString(domainName) </span><span class="cov8" title="1">{
                return NewInvalidDomainNameError("도메인명에 유효하지 않은 문자가 포함되어 있습니다")
        }</span>

        // 하이픈으로 시작하거나 끝나면 안됨
        <span class="cov8" title="1">if strings.HasPrefix(domainName, "-") || strings.HasSuffix(domainName, "-") </span><span class="cov8" title="1">{
                return NewInvalidDomainNameError("도메인명은 하이픈으로 시작하거나 끝날 수 없습니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateID 는 ID를 검증합니다.
func ValidateID(idStr string) error <span class="cov8" title="1">{
        if idStr == "" </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID가 비어있습니다")
        }</span>

        <span class="cov8" title="1">if len(idStr) &gt; MaxIDLength </span><span class="cov8" title="1">{
                return NewTooLongError("ID가 너무 깁니다")
        }</span>

        <span class="cov8" title="1">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID는 유효한 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateCompositeKey 는 합성키 전체를 검증합니다.
func ValidateCompositeKey(compositeKey string) error <span class="cov8" title="1">{
        // 1. 기본 형식 검증
        if err := ValidateFormat(compositeKey); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 2. 구성 요소 분해
        <span class="cov8" title="1">parts := strings.Split(compositeKey, ":")
        toolName := parts[0]
        domainName := parts[1]
        idStr := parts[2]

        // 3. 각 구성 요소 검증
        if err := ValidateToolName(toolName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := ValidateDomainName(domainName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := ValidateID(idStr); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateCompositeKeyStruct 는 CompositeKey 구조체를 검증합니다.
func ValidateCompositeKeyStruct(ck CompositeKey) error <span class="cov8" title="1">{
        if err := ValidateToolName(ck.ToolName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := ValidateDomainName(ck.DomainName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if ck.ID &lt;= 0 </span><span class="cov8" title="1">{
                return NewInvalidIDError("ID는 양의 정수여야 합니다")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
